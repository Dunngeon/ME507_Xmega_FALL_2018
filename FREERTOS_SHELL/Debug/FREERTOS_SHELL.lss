
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000039ec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000086  00802000  000039ec  00003a80  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010a8  00802086  00802086  00003b06  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003b06  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003b38  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000618  00000000  00000000  00003b78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ee9b  00000000  00000000  00004190  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006291  00000000  00000000  0001302b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000047e3  00000000  00000000  000192bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000117c  00000000  00000000  0001daa0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005337  00000000  00000000  0001ec1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005373  00000000  00000000  00023f53  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004f8  00000000  00000000  000292c6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 9d 02 	jmp	0x53a	; 0x53a <__ctors_end>
       4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
       8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
       c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      10:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      14:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      18:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      1c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      20:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      24:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      28:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      2c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      30:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      34:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      38:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      3c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      40:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      44:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      48:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      4c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      50:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      54:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      58:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      5c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      60:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      64:	0c 94 d8 03 	jmp	0x7b0	; 0x7b0 <__vector_25>
      68:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      6c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      70:	0c 94 30 04 	jmp	0x860	; 0x860 <__vector_28>
      74:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      78:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      7c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      80:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      84:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      88:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      8c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      90:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      94:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      98:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      9c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      a0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      a4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      a8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      ac:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      b0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      b4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      b8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      bc:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      c0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      c4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      c8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      cc:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      d0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      d4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      d8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      dc:	0c 94 6f 0c 	jmp	0x18de	; 0x18de <__vector_55>
      e0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      e4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      e8:	0c 94 38 05 	jmp	0xa70	; 0xa70 <__vector_58>
      ec:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      f0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      f4:	0c 94 90 05 	jmp	0xb20	; 0xb20 <__vector_61>
      f8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
      fc:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     100:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     104:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     108:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     10c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     110:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     114:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     118:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     11c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     120:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     124:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     128:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     12c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     130:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     134:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     138:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     13c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     140:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     144:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     148:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     14c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     150:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     154:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     158:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     15c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     160:	0c 94 88 04 	jmp	0x910	; 0x910 <__vector_88>
     164:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     168:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     16c:	0c 94 e0 04 	jmp	0x9c0	; 0x9c0 <__vector_91>
     170:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     174:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     178:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     17c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     180:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     184:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     188:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     18c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     190:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     194:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     198:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     19c:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1a0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1a4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1a8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1ac:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1b0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1b4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1b8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1bc:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1c0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1c4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1c8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1cc:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1d0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1d4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1d8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1dc:	0c 94 e8 05 	jmp	0xbd0	; 0xbd0 <__vector_119>
     1e0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1e4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1e8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1ec:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1f0:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1f4:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1f8:	0c 94 ce 02 	jmp	0x59c	; 0x59c <__bad_interrupt>
     1fc:	63 1a       	sub	r6, r19
     1fe:	66 1a       	sub	r6, r22
     200:	69 1a       	sub	r6, r25
     202:	6c 1a       	sub	r6, r28
     204:	6f 1a       	sub	r6, r31
     206:	72 1a       	sub	r7, r18
     208:	74 1a       	sub	r7, r20
     20a:	85 1a       	sub	r8, r21
     20c:	8d 1a       	sub	r8, r29
     20e:	97 1a       	sub	r9, r23
     210:	95 1a       	sub	r9, r21

00000212 <__trampolines_start>:
     212:	0c 94 03 08 	jmp	0x1006	; 0x1006 <_ZN9task_user3runEv>
     216:	0c 94 63 1a 	jmp	0x34c6	; 0x34c6 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     21a:	0c 94 9d 17 	jmp	0x2f3a	; 0x2f3a <_ZN14frt_text_queue7putcharEc>
     21e:	0c 94 74 17 	jmp	0x2ee8	; 0x2ee8 <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 6c 1a 	jmp	0x34d8	; 0x34d8 <_ZN8emstreamlsE15ser_manipulator+0x30>
     226:	0c 94 66 1a 	jmp	0x34cc	; 0x34cc <_ZN8emstreamlsE15ser_manipulator+0x24>
     22a:	0c 94 40 06 	jmp	0xc80	; 0xc80 <_ZN8task_LED3runEv>
     22e:	0c 94 2d 03 	jmp	0x65a	; 0x65a <_ZN5rs23212clear_screenEv>
     232:	0c 94 fb 0e 	jmp	0x1df6	; 0x1df6 <prvIdleTask>
     236:	0c 94 74 1a 	jmp	0x34e8	; 0x34e8 <_ZN8emstreamlsE15ser_manipulator+0x40>
     23a:	0c 94 08 1a 	jmp	0x3410	; 0x3410 <_ZN8emstream7getcharEv>
     23e:	0c 94 ef 1b 	jmp	0x37de	; 0x37de <_GLOBAL__sub_I_print_ser_queue>
     242:	0c 94 f4 02 	jmp	0x5e8	; 0x5e8 <_ZN5rs2327getcharEv>
     246:	0c 94 0d 1a 	jmp	0x341a	; 0x341a <_ZN8emstream12transmit_nowEv>
     24a:	0c 94 d0 02 	jmp	0x5a0	; 0x5a0 <_ZN5rs2327putcharEc>
     24e:	0c 94 85 1a 	jmp	0x350a	; 0x350a <_ZN8emstreamlsE15ser_manipulator+0x62>
     252:	0c 94 97 1a 	jmp	0x352e	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
     256:	0c 94 92 17 	jmp	0x2f24	; 0x2f24 <_ZN14frt_text_queue14check_for_charEv>
     25a:	0c 94 6f 1a 	jmp	0x34de	; 0x34de <_ZN8emstreamlsE15ser_manipulator+0x36>
     25e:	0c 94 06 1a 	jmp	0x340c	; 0x340c <_ZN8emstream13ready_to_sendEv>
     262:	0c 94 8d 1a 	jmp	0x351a	; 0x351a <_ZN8emstreamlsE15ser_manipulator+0x72>
     266:	0c 94 95 1a 	jmp	0x352a	; 0x352a <_ZN8emstreamlsE15ser_manipulator+0x82>
     26a:	0c 94 9a 02 	jmp	0x534	; 0x534 <_call_static_run_method>
     26e:	0c 94 2a 16 	jmp	0x2c54	; 0x2c54 <_ZN8frt_task12print_statusER8emstream>
     272:	0c 94 0b 1a 	jmp	0x3416	; 0x3416 <_ZN8emstream14check_for_charEv>
     276:	0c 94 1a 03 	jmp	0x634	; 0x634 <_ZN5rs23214check_for_charEv>
     27a:	0c 94 72 1a 	jmp	0x34e4	; 0x34e4 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     27e:	0c 94 0e 1a 	jmp	0x341c	; 0x341c <_ZN8emstream12clear_screenEv>
     282:	0c 94 55 19 	jmp	0x32aa	; 0x32aa <__cxa_pure_virtual>
     286:	0c 94 69 1a 	jmp	0x34d2	; 0x34d2 <_ZN8emstreamlsE15ser_manipulator+0x2a>

0000028a <__trampolines_end>:
     28a:	2c 20       	and	r2, r12
     28c:	54 43       	sbci	r21, 0x34	; 52
     28e:	43 30       	cpi	r20, 0x03	; 3
     290:	43 43       	sbci	r20, 0x33	; 51
     292:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000295 <_ZZN9task_user11show_statusEvE3__c_3>:
     295:	2f 00                                               /.

00000297 <_ZZN9task_user11show_statusEvE3__c_2>:
     297:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002a5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2a5:	54 69 6d 65 3a 20 00                                Time: .

000002ac <_ZZN9task_user11show_statusEvE3__c_0>:
     2ac:	4e 6f 76 20 32 30 20 32 30 31 38 00                 Nov 20 2018.

000002b8 <_ZZN9task_user11show_statusEvE3__c>:
     2b8:	4d 45 35 30 37 20 46 72 65 65 52 54 4f 53 20 78     ME507 FreeRTOS x
     2c8:	6d 65 67 61 20 70 6f 72 74 20 00                    mega port .

000002d3 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2d3:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002e2 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2e2:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     2f2:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

000002fd <_ZZN9task_user18print_help_messageEvE3__c_8>:
     2fd:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     30d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000031b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     31b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     32b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     33b:	6d 61 74 69 6f 6e 00                                mation.

00000342 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     342:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     352:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000363 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     363:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     373:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000037b <_ZZN9task_user18print_help_messageEvE3__c_4>:
     37b:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     38b:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000397 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     397:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3a7:	68 65 20 41 56 52 00                                he AVR.

000003ae <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3ae:	20 68 65 6c 70 00                                    help.

000003b4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3b4:	4d 45 35 30 37 20 46 72 65 65 52 54 4f 53 20 78     ME507 FreeRTOS x
     3c4:	6d 65 67 61 20 70 6f 72 74 20 00                    mega port .

000003cf <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3cf:	1b 5b 33 30 6d 00                                   .[30m.

000003d5 <_ZZN9task_user18print_help_messageEvE3__c>:
     3d5:	1b 5b 34 36 6d 00                                   .[46m.

000003db <_ZZN9task_user3runEvE3__c_3>:
     3db:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     3eb:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

000003f8 <_ZZN9task_user3runEvE3__c_2>:
     3f8:	3a 57 54 46 3f 00                                   :WTF?.

000003fe <_ZZN9task_user3runEvE3__c_1>:
     3fe:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     40e:	65 00                                               e.

00000410 <_ZZN9task_user3runEvE3__c_0>:
     410:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000041e <_ZZN9task_user3runEvE3__c>:
     41e:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     42e:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

0000043c <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     43c:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000446 <_ZZN8frt_task15emergency_resetEvE3__c>:
     446:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000455 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     455:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     465:	61 73 6b 20 00                                      ask .

0000046a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     46a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000478 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     478:	20 63 72 65 61 74 65 64 00                           created.

00000481 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     481:	54 61 73 6b 20 00                                   Task .

00000487 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     487:	1b 5b 32 32 6d 00                                   .[22m.

0000048d <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     48d:	54 61 73 6b 3a 20 00                                Task: .

00000494 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     494:	1b 5b 31 6d 00                                      .[1m.

00000499 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     499:	1b 5b 32 32 6d 00                                   .[22m.

0000049f <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     49f:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004aa <_ZZ17print_task_stacksP8emstreamE3__c>:
     4aa:	1b 5b 31 6d 00                                      .[1m.

000004af <_ZZ15print_task_listP8emstreamE3__c_9>:
     4af:	09 09 00                                            ...

000004b2 <_ZZ15print_task_listP8emstreamE3__c_8>:
     4b2:	2f 00                                               /.

000004b4 <_ZZ15print_task_listP8emstreamE3__c_7>:
     4b4:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004bf <_ZZ15print_task_listP8emstreamE3__c_6>:
     4bf:	09 2d 2d 2d 2d 00                                   .----.

000004c5 <_ZZ15print_task_listP8emstreamE3__c_5>:
     4c5:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004d1 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4d1:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004e2 <_ZZ15print_task_listP8emstreamE3__c_3>:
     4e2:	09 52 75 6e 73 00                                   .Runs.

000004e8 <_ZZ15print_task_listP8emstreamE3__c_2>:
     4e8:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000004f4 <_ZZ15print_task_listP8emstreamE3__c_1>:
     4f4:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000505 <_ZZ15print_task_listP8emstreamE3__c_0>:
     505:	09 53 74 61 63 6b 00                                .Stack.

0000050c <_ZZ15print_task_listP8emstreamE3__c>:
     50c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000517 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     517:	09 00                                               ..

00000519 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     519:	09 00                                               ..

0000051b <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     51b:	2f 00                                               /.

0000051d <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     51d:	09 00                                               ..

0000051f <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     51f:	09 00                                               ..

00000521 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     521:	1b 5b 32 32 6d 00                                   .[22m.

00000527 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     527:	1b 5b 31 6d 00                                      .[1m.

0000052c <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     52c:	1b 5b 31 6d 00                                      .[1m.

00000531 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     531:	20 20 00                                              .

00000534 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     534:	0e 94 c2 14 	call	0x2984	; 0x2984 <_ZN8frt_task22_call_users_run_methodEPS_>

00000538 <__ctors_start>:
     538:	ef 1b       	sub	r30, r31

0000053a <__ctors_end>:
     53a:	11 24       	eor	r1, r1
     53c:	1f be       	out	0x3f, r1	; 63
     53e:	cf ef       	ldi	r28, 0xFF	; 255
     540:	cd bf       	out	0x3d, r28	; 61
     542:	df e3       	ldi	r29, 0x3F	; 63
     544:	de bf       	out	0x3e, r29	; 62
     546:	00 e0       	ldi	r16, 0x00	; 0
     548:	0c bf       	out	0x3c, r16	; 60

0000054a <__do_copy_data>:
     54a:	10 e2       	ldi	r17, 0x20	; 32
     54c:	a0 e0       	ldi	r26, 0x00	; 0
     54e:	b0 e2       	ldi	r27, 0x20	; 32
     550:	ec ee       	ldi	r30, 0xEC	; 236
     552:	f9 e3       	ldi	r31, 0x39	; 57
     554:	00 e0       	ldi	r16, 0x00	; 0
     556:	0b bf       	out	0x3b, r16	; 59
     558:	02 c0       	rjmp	.+4      	; 0x55e <__do_copy_data+0x14>
     55a:	07 90       	elpm	r0, Z+
     55c:	0d 92       	st	X+, r0
     55e:	a6 38       	cpi	r26, 0x86	; 134
     560:	b1 07       	cpc	r27, r17
     562:	d9 f7       	brne	.-10     	; 0x55a <__do_copy_data+0x10>

00000564 <__do_clear_bss>:
     564:	21 e3       	ldi	r18, 0x31	; 49
     566:	a6 e8       	ldi	r26, 0x86	; 134
     568:	b0 e2       	ldi	r27, 0x20	; 32
     56a:	01 c0       	rjmp	.+2      	; 0x56e <.do_clear_bss_start>

0000056c <.do_clear_bss_loop>:
     56c:	1d 92       	st	X+, r1

0000056e <.do_clear_bss_start>:
     56e:	ae 32       	cpi	r26, 0x2E	; 46
     570:	b2 07       	cpc	r27, r18
     572:	e1 f7       	brne	.-8      	; 0x56c <.do_clear_bss_loop>

00000574 <__do_global_ctors>:
     574:	12 e0       	ldi	r17, 0x02	; 2
     576:	cd e9       	ldi	r28, 0x9D	; 157
     578:	d2 e0       	ldi	r29, 0x02	; 2
     57a:	00 e0       	ldi	r16, 0x00	; 0
     57c:	06 c0       	rjmp	.+12     	; 0x58a <__do_global_ctors+0x16>
     57e:	21 97       	sbiw	r28, 0x01	; 1
     580:	01 09       	sbc	r16, r1
     582:	80 2f       	mov	r24, r16
     584:	fe 01       	movw	r30, r28
     586:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__tablejump2__>
     58a:	cc 39       	cpi	r28, 0x9C	; 156
     58c:	d1 07       	cpc	r29, r17
     58e:	80 e0       	ldi	r24, 0x00	; 0
     590:	08 07       	cpc	r16, r24
     592:	a9 f7       	brne	.-22     	; 0x57e <__do_global_ctors+0xa>
     594:	0e 94 91 1b 	call	0x3722	; 0x3722 <main>
     598:	0c 94 f4 1c 	jmp	0x39e8	; 0x39e8 <_exit>

0000059c <__bad_interrupt>:
     59c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005a0 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
     5a0:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     5a2:	50 96       	adiw	r26, 0x10	; 16
     5a4:	ed 91       	ld	r30, X+
     5a6:	fc 91       	ld	r31, X
     5a8:	51 97       	sbiw	r26, 0x11	; 17
     5aa:	80 81       	ld	r24, Z
     5ac:	54 96       	adiw	r26, 0x14	; 20
     5ae:	4c 91       	ld	r20, X
     5b0:	54 97       	sbiw	r26, 0x14	; 20
     5b2:	84 23       	and	r24, r20
     5b4:	29 f0       	breq	.+10     	; 0x5c0 <_ZN5rs2327putcharEc+0x20>
     5b6:	09 c0       	rjmp	.+18     	; 0x5ca <_ZN5rs2327putcharEc+0x2a>
     5b8:	21 50       	subi	r18, 0x01	; 1
     5ba:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
     5bc:	19 f4       	brne	.+6      	; 0x5c4 <_ZN5rs2327putcharEc+0x24>
     5be:	12 c0       	rjmp	.+36     	; 0x5e4 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     5c0:	21 e2       	ldi	r18, 0x21	; 33
     5c2:	3e e4       	ldi	r19, 0x4E	; 78
     5c4:	90 81       	ld	r25, Z
     5c6:	94 23       	and	r25, r20
     5c8:	b9 f3       	breq	.-18     	; 0x5b8 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
     5ca:	90 81       	ld	r25, Z
     5cc:	56 96       	adiw	r26, 0x16	; 22
     5ce:	8c 91       	ld	r24, X
     5d0:	56 97       	sbiw	r26, 0x16	; 22
     5d2:	89 2b       	or	r24, r25
     5d4:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
     5d6:	1e 96       	adiw	r26, 0x0e	; 14
     5d8:	ed 91       	ld	r30, X+
     5da:	fc 91       	ld	r31, X
     5dc:	1f 97       	sbiw	r26, 0x0f	; 15
     5de:	60 83       	st	Z, r22
	return (true);
     5e0:	81 e0       	ldi	r24, 0x01	; 1
     5e2:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
     5e4:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
     5e6:	08 95       	ret

000005e8 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
     5e8:	cf 93       	push	r28
     5ea:	df 93       	push	r29
     5ec:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
     5ee:	c1 8d       	ldd	r28, Z+25	; 0x19
     5f0:	d2 8d       	ldd	r29, Z+26	; 0x1a
     5f2:	28 81       	ld	r18, Y
     5f4:	39 81       	ldd	r19, Y+1	; 0x01
     5f6:	a3 8d       	ldd	r26, Z+27	; 0x1b
     5f8:	b4 8d       	ldd	r27, Z+28	; 0x1c
     5fa:	4d 91       	ld	r20, X+
     5fc:	5c 91       	ld	r21, X
     5fe:	24 17       	cp	r18, r20
     600:	35 07       	cpc	r19, r21
     602:	e9 f3       	breq	.-6      	; 0x5fe <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
     604:	a7 89       	ldd	r26, Z+23	; 0x17
     606:	b0 8d       	ldd	r27, Z+24	; 0x18
     608:	0d 90       	ld	r0, X+
     60a:	bc 91       	ld	r27, X
     60c:	a0 2d       	mov	r26, r0
     60e:	a2 0f       	add	r26, r18
     610:	b3 1f       	adc	r27, r19
     612:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
     614:	2f 5f       	subi	r18, 0xFF	; 255
     616:	3f 4f       	sbci	r19, 0xFF	; 255
     618:	28 83       	st	Y, r18
     61a:	39 83       	std	Y+1, r19	; 0x01
     61c:	24 36       	cpi	r18, 0x64	; 100
     61e:	31 05       	cpc	r19, r1
     620:	28 f0       	brcs	.+10     	; 0x62c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
     622:	01 8c       	ldd	r0, Z+25	; 0x19
     624:	f2 8d       	ldd	r31, Z+26	; 0x1a
     626:	e0 2d       	mov	r30, r0
     628:	10 82       	st	Z, r1
     62a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	df 91       	pop	r29
     630:	cf 91       	pop	r28
     632:	08 95       	ret

00000634 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
     634:	cf 93       	push	r28
     636:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
     638:	ec 01       	movw	r28, r24
     63a:	a9 8d       	ldd	r26, Y+25	; 0x19
     63c:	ba 8d       	ldd	r27, Y+26	; 0x1a
     63e:	eb 8d       	ldd	r30, Y+27	; 0x1b
     640:	fc 8d       	ldd	r31, Y+28	; 0x1c
     642:	81 e0       	ldi	r24, 0x01	; 1
     644:	4d 91       	ld	r20, X+
     646:	5c 91       	ld	r21, X
     648:	20 81       	ld	r18, Z
     64a:	31 81       	ldd	r19, Z+1	; 0x01
     64c:	42 17       	cp	r20, r18
     64e:	53 07       	cpc	r21, r19
     650:	09 f4       	brne	.+2      	; 0x654 <_ZN5rs23214check_for_charEv+0x20>
     652:	80 e0       	ldi	r24, 0x00	; 0
}
     654:	df 91       	pop	r29
     656:	cf 91       	pop	r28
     658:	08 95       	ret

0000065a <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
     65a:	dc 01       	movw	r26, r24
     65c:	ed 91       	ld	r30, X+
     65e:	fc 91       	ld	r31, X
     660:	02 80       	ldd	r0, Z+2	; 0x02
     662:	f3 81       	ldd	r31, Z+3	; 0x03
     664:	e0 2d       	mov	r30, r0
     666:	6c e0       	ldi	r22, 0x0C	; 12
     668:	19 95       	eicall
     66a:	08 95       	ret

0000066c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
     66c:	ef 92       	push	r14
     66e:	ff 92       	push	r15
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
     678:	ec 01       	movw	r28, r24
     67a:	7b 01       	movw	r14, r22
     67c:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
     67e:	0e 94 0f 1a 	call	0x341e	; 0x341e <_ZN8emstreamC1Ev>
     682:	a8 01       	movw	r20, r16
     684:	b7 01       	movw	r22, r14
     686:	ce 01       	movw	r24, r28
     688:	08 96       	adiw	r24, 0x08	; 8
     68a:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN7base232C1EjP12USART_struct>
     68e:	8a e0       	ldi	r24, 0x0A	; 10
     690:	90 e2       	ldi	r25, 0x20	; 32
     692:	88 83       	st	Y, r24
     694:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
     696:	00 3a       	cpi	r16, 0xA0	; 160
     698:	88 e0       	ldi	r24, 0x08	; 8
     69a:	18 07       	cpc	r17, r24
     69c:	69 f4       	brne	.+26     	; 0x6b8 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
     69e:	8e ea       	ldi	r24, 0xAE	; 174
     6a0:	90 e2       	ldi	r25, 0x20	; 32
     6a2:	8f 8b       	std	Y+23, r24	; 0x17
     6a4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
     6a6:	80 ea       	ldi	r24, 0xA0	; 160
     6a8:	90 e2       	ldi	r25, 0x20	; 32
     6aa:	89 8f       	std	Y+25, r24	; 0x19
     6ac:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
     6ae:	82 e9       	ldi	r24, 0x92	; 146
     6b0:	90 e2       	ldi	r25, 0x20	; 32
     6b2:	8b 8f       	std	Y+27, r24	; 0x1b
     6b4:	9c 8f       	std	Y+28, r25	; 0x1c
     6b6:	64 c0       	rjmp	.+200    	; 0x780 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
     6b8:	00 3b       	cpi	r16, 0xB0	; 176
     6ba:	e8 e0       	ldi	r30, 0x08	; 8
     6bc:	1e 07       	cpc	r17, r30
     6be:	69 f4       	brne	.+26     	; 0x6da <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
     6c0:	8c ea       	ldi	r24, 0xAC	; 172
     6c2:	90 e2       	ldi	r25, 0x20	; 32
     6c4:	8f 8b       	std	Y+23, r24	; 0x17
     6c6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
     6c8:	8e e9       	ldi	r24, 0x9E	; 158
     6ca:	90 e2       	ldi	r25, 0x20	; 32
     6cc:	89 8f       	std	Y+25, r24	; 0x19
     6ce:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
     6d0:	80 e9       	ldi	r24, 0x90	; 144
     6d2:	90 e2       	ldi	r25, 0x20	; 32
     6d4:	8b 8f       	std	Y+27, r24	; 0x1b
     6d6:	9c 8f       	std	Y+28, r25	; 0x1c
     6d8:	53 c0       	rjmp	.+166    	; 0x780 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
     6da:	00 3a       	cpi	r16, 0xA0	; 160
     6dc:	f9 e0       	ldi	r31, 0x09	; 9
     6de:	1f 07       	cpc	r17, r31
     6e0:	69 f4       	brne	.+26     	; 0x6fc <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
     6e2:	8a ea       	ldi	r24, 0xAA	; 170
     6e4:	90 e2       	ldi	r25, 0x20	; 32
     6e6:	8f 8b       	std	Y+23, r24	; 0x17
     6e8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
     6ea:	8c e9       	ldi	r24, 0x9C	; 156
     6ec:	90 e2       	ldi	r25, 0x20	; 32
     6ee:	89 8f       	std	Y+25, r24	; 0x19
     6f0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
     6f2:	8e e8       	ldi	r24, 0x8E	; 142
     6f4:	90 e2       	ldi	r25, 0x20	; 32
     6f6:	8b 8f       	std	Y+27, r24	; 0x1b
     6f8:	9c 8f       	std	Y+28, r25	; 0x1c
     6fa:	42 c0       	rjmp	.+132    	; 0x780 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
     6fc:	00 3b       	cpi	r16, 0xB0	; 176
     6fe:	89 e0       	ldi	r24, 0x09	; 9
     700:	18 07       	cpc	r17, r24
     702:	69 f4       	brne	.+26     	; 0x71e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
     704:	88 ea       	ldi	r24, 0xA8	; 168
     706:	90 e2       	ldi	r25, 0x20	; 32
     708:	8f 8b       	std	Y+23, r24	; 0x17
     70a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
     70c:	8a e9       	ldi	r24, 0x9A	; 154
     70e:	90 e2       	ldi	r25, 0x20	; 32
     710:	89 8f       	std	Y+25, r24	; 0x19
     712:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
     714:	8c e8       	ldi	r24, 0x8C	; 140
     716:	90 e2       	ldi	r25, 0x20	; 32
     718:	8b 8f       	std	Y+27, r24	; 0x1b
     71a:	9c 8f       	std	Y+28, r25	; 0x1c
     71c:	31 c0       	rjmp	.+98     	; 0x780 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
     71e:	00 3a       	cpi	r16, 0xA0	; 160
     720:	ea e0       	ldi	r30, 0x0A	; 10
     722:	1e 07       	cpc	r17, r30
     724:	69 f4       	brne	.+26     	; 0x740 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
     726:	86 ea       	ldi	r24, 0xA6	; 166
     728:	90 e2       	ldi	r25, 0x20	; 32
     72a:	8f 8b       	std	Y+23, r24	; 0x17
     72c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
     72e:	88 e9       	ldi	r24, 0x98	; 152
     730:	90 e2       	ldi	r25, 0x20	; 32
     732:	89 8f       	std	Y+25, r24	; 0x19
     734:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
     736:	8a e8       	ldi	r24, 0x8A	; 138
     738:	90 e2       	ldi	r25, 0x20	; 32
     73a:	8b 8f       	std	Y+27, r24	; 0x1b
     73c:	9c 8f       	std	Y+28, r25	; 0x1c
     73e:	20 c0       	rjmp	.+64     	; 0x780 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTE1
	else if(p_usart == &USARTE1)
     740:	00 3b       	cpi	r16, 0xB0	; 176
     742:	fa e0       	ldi	r31, 0x0A	; 10
     744:	1f 07       	cpc	r17, r31
     746:	69 f4       	brne	.+26     	; 0x762 <_ZN5rs232C1EjP12USART_struct+0xf6>
	{
		p_rcv_buffer		= &rcvE1_buffer;
     748:	84 ea       	ldi	r24, 0xA4	; 164
     74a:	90 e2       	ldi	r25, 0x20	; 32
     74c:	8f 8b       	std	Y+23, r24	; 0x17
     74e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE1_read_index;
     750:	86 e9       	ldi	r24, 0x96	; 150
     752:	90 e2       	ldi	r25, 0x20	; 32
     754:	89 8f       	std	Y+25, r24	; 0x19
     756:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE1_write_index;
     758:	88 e8       	ldi	r24, 0x88	; 136
     75a:	90 e2       	ldi	r25, 0x20	; 32
     75c:	8b 8f       	std	Y+27, r24	; 0x1b
     75e:	9c 8f       	std	Y+28, r25	; 0x1c
     760:	0f c0       	rjmp	.+30     	; 0x780 <_ZN5rs232C1EjP12USART_struct+0x114>
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
     762:	00 3a       	cpi	r16, 0xA0	; 160
     764:	1b 40       	sbci	r17, 0x0B	; 11
     766:	61 f4       	brne	.+24     	; 0x780 <_ZN5rs232C1EjP12USART_struct+0x114>
	{
		p_rcv_buffer		= &rcvF0_buffer;
     768:	82 ea       	ldi	r24, 0xA2	; 162
     76a:	90 e2       	ldi	r25, 0x20	; 32
     76c:	8f 8b       	std	Y+23, r24	; 0x17
     76e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
     770:	84 e9       	ldi	r24, 0x94	; 148
     772:	90 e2       	ldi	r25, 0x20	; 32
     774:	89 8f       	std	Y+25, r24	; 0x19
     776:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
     778:	86 e8       	ldi	r24, 0x86	; 134
     77a:	90 e2       	ldi	r25, 0x20	; 32
     77c:	8b 8f       	std	Y+27, r24	; 0x1b
     77e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
     780:	0f 89       	ldd	r16, Y+23	; 0x17
     782:	18 8d       	ldd	r17, Y+24	; 0x18
     784:	84 e6       	ldi	r24, 0x64	; 100
     786:	90 e0       	ldi	r25, 0x00	; 0
     788:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_Znaj>
     78c:	f8 01       	movw	r30, r16
     78e:	80 83       	st	Z, r24
     790:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
     792:	e9 8d       	ldd	r30, Y+25	; 0x19
     794:	fa 8d       	ldd	r31, Y+26	; 0x1a
     796:	10 82       	st	Z, r1
     798:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
     79a:	eb 8d       	ldd	r30, Y+27	; 0x1b
     79c:	fc 8d       	ldd	r31, Y+28	; 0x1c
     79e:	10 82       	st	Z, r1
     7a0:	11 82       	std	Z+1, r1	; 0x01
}
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	1f 91       	pop	r17
     7a8:	0f 91       	pop	r16
     7aa:	ff 90       	pop	r15
     7ac:	ef 90       	pop	r14
     7ae:	08 95       	ret

000007b0 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
     7b0:	1f 92       	push	r1
     7b2:	0f 92       	push	r0
     7b4:	0f b6       	in	r0, 0x3f	; 63
     7b6:	0f 92       	push	r0
     7b8:	11 24       	eor	r1, r1
     7ba:	0b b6       	in	r0, 0x3b	; 59
     7bc:	0f 92       	push	r0
     7be:	2f 93       	push	r18
     7c0:	3f 93       	push	r19
     7c2:	8f 93       	push	r24
     7c4:	9f 93       	push	r25
     7c6:	ef 93       	push	r30
     7c8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
     7ca:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
     7ce:	e0 91 ae 20 	lds	r30, 0x20AE	; 0x8020ae <rcvC0_buffer>
     7d2:	f0 91 af 20 	lds	r31, 0x20AF	; 0x8020af <rcvC0_buffer+0x1>
     7d6:	80 91 92 20 	lds	r24, 0x2092	; 0x802092 <rcvC0_write_index>
     7da:	90 91 93 20 	lds	r25, 0x2093	; 0x802093 <rcvC0_write_index+0x1>
     7de:	e8 0f       	add	r30, r24
     7e0:	f9 1f       	adc	r31, r25
     7e2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
     7e4:	80 91 92 20 	lds	r24, 0x2092	; 0x802092 <rcvC0_write_index>
     7e8:	90 91 93 20 	lds	r25, 0x2093	; 0x802093 <rcvC0_write_index+0x1>
     7ec:	01 96       	adiw	r24, 0x01	; 1
     7ee:	84 36       	cpi	r24, 0x64	; 100
     7f0:	91 05       	cpc	r25, r1
     7f2:	60 f4       	brcc	.+24     	; 0x80c <__vector_25+0x5c>
     7f4:	80 93 92 20 	sts	0x2092, r24	; 0x802092 <rcvC0_write_index>
     7f8:	90 93 93 20 	sts	0x2093, r25	; 0x802093 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
     7fc:	20 91 a0 20 	lds	r18, 0x20A0	; 0x8020a0 <rcvC0_read_index>
     800:	30 91 a1 20 	lds	r19, 0x20A1	; 0x8020a1 <rcvC0_read_index+0x1>
     804:	82 17       	cp	r24, r18
     806:	93 07       	cpc	r25, r19
     808:	f1 f4       	brne	.+60     	; 0x846 <__vector_25+0x96>
     80a:	0c c0       	rjmp	.+24     	; 0x824 <__vector_25+0x74>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
     80c:	10 92 92 20 	sts	0x2092, r1	; 0x802092 <rcvC0_write_index>
     810:	10 92 93 20 	sts	0x2093, r1	; 0x802093 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
     814:	80 91 a0 20 	lds	r24, 0x20A0	; 0x8020a0 <rcvC0_read_index>
     818:	90 91 a1 20 	lds	r25, 0x20A1	; 0x8020a1 <rcvC0_read_index+0x1>
     81c:	18 16       	cp	r1, r24
     81e:	19 06       	cpc	r1, r25
     820:	91 f4       	brne	.+36     	; 0x846 <__vector_25+0x96>
     822:	0e c0       	rjmp	.+28     	; 0x840 <__vector_25+0x90>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
     824:	01 96       	adiw	r24, 0x01	; 1
     826:	84 36       	cpi	r24, 0x64	; 100
     828:	91 05       	cpc	r25, r1
     82a:	28 f4       	brcc	.+10     	; 0x836 <__vector_25+0x86>
     82c:	80 93 a0 20 	sts	0x20A0, r24	; 0x8020a0 <rcvC0_read_index>
     830:	90 93 a1 20 	sts	0x20A1, r25	; 0x8020a1 <rcvC0_read_index+0x1>
     834:	08 c0       	rjmp	.+16     	; 0x846 <__vector_25+0x96>
			rcvC0_read_index = 0;
     836:	10 92 a0 20 	sts	0x20A0, r1	; 0x8020a0 <rcvC0_read_index>
     83a:	10 92 a1 20 	sts	0x20A1, r1	; 0x8020a1 <rcvC0_read_index+0x1>
}
     83e:	03 c0       	rjmp	.+6      	; 0x846 <__vector_25+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	90 e0       	ldi	r25, 0x00	; 0
     844:	f3 cf       	rjmp	.-26     	; 0x82c <__vector_25+0x7c>
			rcvC0_read_index = 0;
}
     846:	ff 91       	pop	r31
     848:	ef 91       	pop	r30
     84a:	9f 91       	pop	r25
     84c:	8f 91       	pop	r24
     84e:	3f 91       	pop	r19
     850:	2f 91       	pop	r18
     852:	0f 90       	pop	r0
     854:	0b be       	out	0x3b, r0	; 59
     856:	0f 90       	pop	r0
     858:	0f be       	out	0x3f, r0	; 63
     85a:	0f 90       	pop	r0
     85c:	1f 90       	pop	r1
     85e:	18 95       	reti

00000860 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
     860:	1f 92       	push	r1
     862:	0f 92       	push	r0
     864:	0f b6       	in	r0, 0x3f	; 63
     866:	0f 92       	push	r0
     868:	11 24       	eor	r1, r1
     86a:	0b b6       	in	r0, 0x3b	; 59
     86c:	0f 92       	push	r0
     86e:	2f 93       	push	r18
     870:	3f 93       	push	r19
     872:	8f 93       	push	r24
     874:	9f 93       	push	r25
     876:	ef 93       	push	r30
     878:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
     87a:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
     87e:	e0 91 ac 20 	lds	r30, 0x20AC	; 0x8020ac <rcvC1_buffer>
     882:	f0 91 ad 20 	lds	r31, 0x20AD	; 0x8020ad <rcvC1_buffer+0x1>
     886:	80 91 90 20 	lds	r24, 0x2090	; 0x802090 <rcvC1_write_index>
     88a:	90 91 91 20 	lds	r25, 0x2091	; 0x802091 <rcvC1_write_index+0x1>
     88e:	e8 0f       	add	r30, r24
     890:	f9 1f       	adc	r31, r25
     892:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
     894:	80 91 90 20 	lds	r24, 0x2090	; 0x802090 <rcvC1_write_index>
     898:	90 91 91 20 	lds	r25, 0x2091	; 0x802091 <rcvC1_write_index+0x1>
     89c:	01 96       	adiw	r24, 0x01	; 1
     89e:	84 36       	cpi	r24, 0x64	; 100
     8a0:	91 05       	cpc	r25, r1
     8a2:	60 f4       	brcc	.+24     	; 0x8bc <__vector_28+0x5c>
     8a4:	80 93 90 20 	sts	0x2090, r24	; 0x802090 <rcvC1_write_index>
     8a8:	90 93 91 20 	sts	0x2091, r25	; 0x802091 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
     8ac:	20 91 9e 20 	lds	r18, 0x209E	; 0x80209e <rcvC1_read_index>
     8b0:	30 91 9f 20 	lds	r19, 0x209F	; 0x80209f <rcvC1_read_index+0x1>
     8b4:	82 17       	cp	r24, r18
     8b6:	93 07       	cpc	r25, r19
     8b8:	f1 f4       	brne	.+60     	; 0x8f6 <__vector_28+0x96>
     8ba:	0c c0       	rjmp	.+24     	; 0x8d4 <__vector_28+0x74>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
     8bc:	10 92 90 20 	sts	0x2090, r1	; 0x802090 <rcvC1_write_index>
     8c0:	10 92 91 20 	sts	0x2091, r1	; 0x802091 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
     8c4:	80 91 9e 20 	lds	r24, 0x209E	; 0x80209e <rcvC1_read_index>
     8c8:	90 91 9f 20 	lds	r25, 0x209F	; 0x80209f <rcvC1_read_index+0x1>
     8cc:	18 16       	cp	r1, r24
     8ce:	19 06       	cpc	r1, r25
     8d0:	91 f4       	brne	.+36     	; 0x8f6 <__vector_28+0x96>
     8d2:	0e c0       	rjmp	.+28     	; 0x8f0 <__vector_28+0x90>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
     8d4:	01 96       	adiw	r24, 0x01	; 1
     8d6:	84 36       	cpi	r24, 0x64	; 100
     8d8:	91 05       	cpc	r25, r1
     8da:	28 f4       	brcc	.+10     	; 0x8e6 <__vector_28+0x86>
     8dc:	80 93 9e 20 	sts	0x209E, r24	; 0x80209e <rcvC1_read_index>
     8e0:	90 93 9f 20 	sts	0x209F, r25	; 0x80209f <rcvC1_read_index+0x1>
     8e4:	08 c0       	rjmp	.+16     	; 0x8f6 <__vector_28+0x96>
	rcvC1_read_index = 0;
     8e6:	10 92 9e 20 	sts	0x209E, r1	; 0x80209e <rcvC1_read_index>
     8ea:	10 92 9f 20 	sts	0x209F, r1	; 0x80209f <rcvC1_read_index+0x1>
}
     8ee:	03 c0       	rjmp	.+6      	; 0x8f6 <__vector_28+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	f3 cf       	rjmp	.-26     	; 0x8dc <__vector_28+0x7c>
	rcvC1_read_index = 0;
}
     8f6:	ff 91       	pop	r31
     8f8:	ef 91       	pop	r30
     8fa:	9f 91       	pop	r25
     8fc:	8f 91       	pop	r24
     8fe:	3f 91       	pop	r19
     900:	2f 91       	pop	r18
     902:	0f 90       	pop	r0
     904:	0b be       	out	0x3b, r0	; 59
     906:	0f 90       	pop	r0
     908:	0f be       	out	0x3f, r0	; 63
     90a:	0f 90       	pop	r0
     90c:	1f 90       	pop	r1
     90e:	18 95       	reti

00000910 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
     910:	1f 92       	push	r1
     912:	0f 92       	push	r0
     914:	0f b6       	in	r0, 0x3f	; 63
     916:	0f 92       	push	r0
     918:	11 24       	eor	r1, r1
     91a:	0b b6       	in	r0, 0x3b	; 59
     91c:	0f 92       	push	r0
     91e:	2f 93       	push	r18
     920:	3f 93       	push	r19
     922:	8f 93       	push	r24
     924:	9f 93       	push	r25
     926:	ef 93       	push	r30
     928:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvD0_write_index] = USARTD0.DATA;
     92a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     92e:	e0 91 aa 20 	lds	r30, 0x20AA	; 0x8020aa <rcvD0_buffer>
     932:	f0 91 ab 20 	lds	r31, 0x20AB	; 0x8020ab <rcvD0_buffer+0x1>
     936:	80 91 8e 20 	lds	r24, 0x208E	; 0x80208e <rcvD0_write_index>
     93a:	90 91 8f 20 	lds	r25, 0x208F	; 0x80208f <rcvD0_write_index+0x1>
     93e:	e8 0f       	add	r30, r24
     940:	f9 1f       	adc	r31, r25
     942:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
     944:	80 91 8e 20 	lds	r24, 0x208E	; 0x80208e <rcvD0_write_index>
     948:	90 91 8f 20 	lds	r25, 0x208F	; 0x80208f <rcvD0_write_index+0x1>
     94c:	01 96       	adiw	r24, 0x01	; 1
     94e:	84 36       	cpi	r24, 0x64	; 100
     950:	91 05       	cpc	r25, r1
     952:	60 f4       	brcc	.+24     	; 0x96c <__vector_88+0x5c>
     954:	80 93 8e 20 	sts	0x208E, r24	; 0x80208e <rcvD0_write_index>
     958:	90 93 8f 20 	sts	0x208F, r25	; 0x80208f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
     95c:	20 91 9c 20 	lds	r18, 0x209C	; 0x80209c <rcvD0_read_index>
     960:	30 91 9d 20 	lds	r19, 0x209D	; 0x80209d <rcvD0_read_index+0x1>
     964:	82 17       	cp	r24, r18
     966:	93 07       	cpc	r25, r19
     968:	f1 f4       	brne	.+60     	; 0x9a6 <__vector_88+0x96>
     96a:	0c c0       	rjmp	.+24     	; 0x984 <__vector_88+0x74>

	rcvD0_buffer[rcvD0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
     96c:	10 92 8e 20 	sts	0x208E, r1	; 0x80208e <rcvD0_write_index>
     970:	10 92 8f 20 	sts	0x208F, r1	; 0x80208f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
     974:	80 91 9c 20 	lds	r24, 0x209C	; 0x80209c <rcvD0_read_index>
     978:	90 91 9d 20 	lds	r25, 0x209D	; 0x80209d <rcvD0_read_index+0x1>
     97c:	18 16       	cp	r1, r24
     97e:	19 06       	cpc	r1, r25
     980:	91 f4       	brne	.+36     	; 0x9a6 <__vector_88+0x96>
     982:	0e c0       	rjmp	.+28     	; 0x9a0 <__vector_88+0x90>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
     984:	01 96       	adiw	r24, 0x01	; 1
     986:	84 36       	cpi	r24, 0x64	; 100
     988:	91 05       	cpc	r25, r1
     98a:	28 f4       	brcc	.+10     	; 0x996 <__vector_88+0x86>
     98c:	80 93 9c 20 	sts	0x209C, r24	; 0x80209c <rcvD0_read_index>
     990:	90 93 9d 20 	sts	0x209D, r25	; 0x80209d <rcvD0_read_index+0x1>
     994:	08 c0       	rjmp	.+16     	; 0x9a6 <__vector_88+0x96>
	rcvD0_read_index = 0;
     996:	10 92 9c 20 	sts	0x209C, r1	; 0x80209c <rcvD0_read_index>
     99a:	10 92 9d 20 	sts	0x209D, r1	; 0x80209d <rcvD0_read_index+0x1>
}
     99e:	03 c0       	rjmp	.+6      	; 0x9a6 <__vector_88+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	f3 cf       	rjmp	.-26     	; 0x98c <__vector_88+0x7c>
	rcvD0_read_index = 0;
}
     9a6:	ff 91       	pop	r31
     9a8:	ef 91       	pop	r30
     9aa:	9f 91       	pop	r25
     9ac:	8f 91       	pop	r24
     9ae:	3f 91       	pop	r19
     9b0:	2f 91       	pop	r18
     9b2:	0f 90       	pop	r0
     9b4:	0b be       	out	0x3b, r0	; 59
     9b6:	0f 90       	pop	r0
     9b8:	0f be       	out	0x3f, r0	; 63
     9ba:	0f 90       	pop	r0
     9bc:	1f 90       	pop	r1
     9be:	18 95       	reti

000009c0 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
     9c0:	1f 92       	push	r1
     9c2:	0f 92       	push	r0
     9c4:	0f b6       	in	r0, 0x3f	; 63
     9c6:	0f 92       	push	r0
     9c8:	11 24       	eor	r1, r1
     9ca:	0b b6       	in	r0, 0x3b	; 59
     9cc:	0f 92       	push	r0
     9ce:	2f 93       	push	r18
     9d0:	3f 93       	push	r19
     9d2:	8f 93       	push	r24
     9d4:	9f 93       	push	r25
     9d6:	ef 93       	push	r30
     9d8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
     9da:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
     9de:	e0 91 a8 20 	lds	r30, 0x20A8	; 0x8020a8 <rcvD1_buffer>
     9e2:	f0 91 a9 20 	lds	r31, 0x20A9	; 0x8020a9 <rcvD1_buffer+0x1>
     9e6:	80 91 8c 20 	lds	r24, 0x208C	; 0x80208c <rcvD1_write_index>
     9ea:	90 91 8d 20 	lds	r25, 0x208D	; 0x80208d <rcvD1_write_index+0x1>
     9ee:	e8 0f       	add	r30, r24
     9f0:	f9 1f       	adc	r31, r25
     9f2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
     9f4:	80 91 8c 20 	lds	r24, 0x208C	; 0x80208c <rcvD1_write_index>
     9f8:	90 91 8d 20 	lds	r25, 0x208D	; 0x80208d <rcvD1_write_index+0x1>
     9fc:	01 96       	adiw	r24, 0x01	; 1
     9fe:	84 36       	cpi	r24, 0x64	; 100
     a00:	91 05       	cpc	r25, r1
     a02:	60 f4       	brcc	.+24     	; 0xa1c <__vector_91+0x5c>
     a04:	80 93 8c 20 	sts	0x208C, r24	; 0x80208c <rcvD1_write_index>
     a08:	90 93 8d 20 	sts	0x208D, r25	; 0x80208d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
     a0c:	20 91 9a 20 	lds	r18, 0x209A	; 0x80209a <rcvD1_read_index>
     a10:	30 91 9b 20 	lds	r19, 0x209B	; 0x80209b <rcvD1_read_index+0x1>
     a14:	82 17       	cp	r24, r18
     a16:	93 07       	cpc	r25, r19
     a18:	f1 f4       	brne	.+60     	; 0xa56 <__vector_91+0x96>
     a1a:	0c c0       	rjmp	.+24     	; 0xa34 <__vector_91+0x74>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
     a1c:	10 92 8c 20 	sts	0x208C, r1	; 0x80208c <rcvD1_write_index>
     a20:	10 92 8d 20 	sts	0x208D, r1	; 0x80208d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
     a24:	80 91 9a 20 	lds	r24, 0x209A	; 0x80209a <rcvD1_read_index>
     a28:	90 91 9b 20 	lds	r25, 0x209B	; 0x80209b <rcvD1_read_index+0x1>
     a2c:	18 16       	cp	r1, r24
     a2e:	19 06       	cpc	r1, r25
     a30:	91 f4       	brne	.+36     	; 0xa56 <__vector_91+0x96>
     a32:	0e c0       	rjmp	.+28     	; 0xa50 <__vector_91+0x90>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
     a34:	01 96       	adiw	r24, 0x01	; 1
     a36:	84 36       	cpi	r24, 0x64	; 100
     a38:	91 05       	cpc	r25, r1
     a3a:	28 f4       	brcc	.+10     	; 0xa46 <__vector_91+0x86>
     a3c:	80 93 9a 20 	sts	0x209A, r24	; 0x80209a <rcvD1_read_index>
     a40:	90 93 9b 20 	sts	0x209B, r25	; 0x80209b <rcvD1_read_index+0x1>
     a44:	08 c0       	rjmp	.+16     	; 0xa56 <__vector_91+0x96>
	rcvD1_read_index = 0;
     a46:	10 92 9a 20 	sts	0x209A, r1	; 0x80209a <rcvD1_read_index>
     a4a:	10 92 9b 20 	sts	0x209B, r1	; 0x80209b <rcvD1_read_index+0x1>
}
     a4e:	03 c0       	rjmp	.+6      	; 0xa56 <__vector_91+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
     a50:	81 e0       	ldi	r24, 0x01	; 1
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	f3 cf       	rjmp	.-26     	; 0xa3c <__vector_91+0x7c>
	rcvD1_read_index = 0;
}
     a56:	ff 91       	pop	r31
     a58:	ef 91       	pop	r30
     a5a:	9f 91       	pop	r25
     a5c:	8f 91       	pop	r24
     a5e:	3f 91       	pop	r19
     a60:	2f 91       	pop	r18
     a62:	0f 90       	pop	r0
     a64:	0b be       	out	0x3b, r0	; 59
     a66:	0f 90       	pop	r0
     a68:	0f be       	out	0x3f, r0	; 63
     a6a:	0f 90       	pop	r0
     a6c:	1f 90       	pop	r1
     a6e:	18 95       	reti

00000a70 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
     a70:	1f 92       	push	r1
     a72:	0f 92       	push	r0
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	0f 92       	push	r0
     a78:	11 24       	eor	r1, r1
     a7a:	0b b6       	in	r0, 0x3b	; 59
     a7c:	0f 92       	push	r0
     a7e:	2f 93       	push	r18
     a80:	3f 93       	push	r19
     a82:	8f 93       	push	r24
     a84:	9f 93       	push	r25
     a86:	ef 93       	push	r30
     a88:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
     a8a:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
     a8e:	e0 91 a6 20 	lds	r30, 0x20A6	; 0x8020a6 <rcvE0_buffer>
     a92:	f0 91 a7 20 	lds	r31, 0x20A7	; 0x8020a7 <rcvE0_buffer+0x1>
     a96:	80 91 8a 20 	lds	r24, 0x208A	; 0x80208a <rcvE0_write_index>
     a9a:	90 91 8b 20 	lds	r25, 0x208B	; 0x80208b <rcvE0_write_index+0x1>
     a9e:	e8 0f       	add	r30, r24
     aa0:	f9 1f       	adc	r31, r25
     aa2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
     aa4:	80 91 8a 20 	lds	r24, 0x208A	; 0x80208a <rcvE0_write_index>
     aa8:	90 91 8b 20 	lds	r25, 0x208B	; 0x80208b <rcvE0_write_index+0x1>
     aac:	01 96       	adiw	r24, 0x01	; 1
     aae:	84 36       	cpi	r24, 0x64	; 100
     ab0:	91 05       	cpc	r25, r1
     ab2:	60 f4       	brcc	.+24     	; 0xacc <__vector_58+0x5c>
     ab4:	80 93 8a 20 	sts	0x208A, r24	; 0x80208a <rcvE0_write_index>
     ab8:	90 93 8b 20 	sts	0x208B, r25	; 0x80208b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
     abc:	20 91 98 20 	lds	r18, 0x2098	; 0x802098 <rcvE0_read_index>
     ac0:	30 91 99 20 	lds	r19, 0x2099	; 0x802099 <rcvE0_read_index+0x1>
     ac4:	82 17       	cp	r24, r18
     ac6:	93 07       	cpc	r25, r19
     ac8:	f1 f4       	brne	.+60     	; 0xb06 <__vector_58+0x96>
     aca:	0c c0       	rjmp	.+24     	; 0xae4 <__vector_58+0x74>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
     acc:	10 92 8a 20 	sts	0x208A, r1	; 0x80208a <rcvE0_write_index>
     ad0:	10 92 8b 20 	sts	0x208B, r1	; 0x80208b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
     ad4:	80 91 98 20 	lds	r24, 0x2098	; 0x802098 <rcvE0_read_index>
     ad8:	90 91 99 20 	lds	r25, 0x2099	; 0x802099 <rcvE0_read_index+0x1>
     adc:	18 16       	cp	r1, r24
     ade:	19 06       	cpc	r1, r25
     ae0:	91 f4       	brne	.+36     	; 0xb06 <__vector_58+0x96>
     ae2:	0e c0       	rjmp	.+28     	; 0xb00 <__vector_58+0x90>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
     ae4:	01 96       	adiw	r24, 0x01	; 1
     ae6:	84 36       	cpi	r24, 0x64	; 100
     ae8:	91 05       	cpc	r25, r1
     aea:	28 f4       	brcc	.+10     	; 0xaf6 <__vector_58+0x86>
     aec:	80 93 98 20 	sts	0x2098, r24	; 0x802098 <rcvE0_read_index>
     af0:	90 93 99 20 	sts	0x2099, r25	; 0x802099 <rcvE0_read_index+0x1>
     af4:	08 c0       	rjmp	.+16     	; 0xb06 <__vector_58+0x96>
	rcvE0_read_index = 0;
     af6:	10 92 98 20 	sts	0x2098, r1	; 0x802098 <rcvE0_read_index>
     afa:	10 92 99 20 	sts	0x2099, r1	; 0x802099 <rcvE0_read_index+0x1>
}
     afe:	03 c0       	rjmp	.+6      	; 0xb06 <__vector_58+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	f3 cf       	rjmp	.-26     	; 0xaec <__vector_58+0x7c>
	rcvE0_read_index = 0;
}
     b06:	ff 91       	pop	r31
     b08:	ef 91       	pop	r30
     b0a:	9f 91       	pop	r25
     b0c:	8f 91       	pop	r24
     b0e:	3f 91       	pop	r19
     b10:	2f 91       	pop	r18
     b12:	0f 90       	pop	r0
     b14:	0b be       	out	0x3b, r0	; 59
     b16:	0f 90       	pop	r0
     b18:	0f be       	out	0x3f, r0	; 63
     b1a:	0f 90       	pop	r0
     b1c:	1f 90       	pop	r1
     b1e:	18 95       	reti

00000b20 <__vector_61>:
#endif

#ifdef USARTE1_RXC_vect
ISR (USARTE1_RXC_vect)
{
     b20:	1f 92       	push	r1
     b22:	0f 92       	push	r0
     b24:	0f b6       	in	r0, 0x3f	; 63
     b26:	0f 92       	push	r0
     b28:	11 24       	eor	r1, r1
     b2a:	0b b6       	in	r0, 0x3b	; 59
     b2c:	0f 92       	push	r0
     b2e:	2f 93       	push	r18
     b30:	3f 93       	push	r19
     b32:	8f 93       	push	r24
     b34:	9f 93       	push	r25
     b36:	ef 93       	push	r30
     b38:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;
     b3a:	20 91 b0 0a 	lds	r18, 0x0AB0	; 0x800ab0 <__TEXT_REGION_LENGTH__+0x700ab0>
     b3e:	e0 91 a4 20 	lds	r30, 0x20A4	; 0x8020a4 <rcvE1_buffer>
     b42:	f0 91 a5 20 	lds	r31, 0x20A5	; 0x8020a5 <rcvE1_buffer+0x1>
     b46:	80 91 88 20 	lds	r24, 0x2088	; 0x802088 <rcvE1_write_index>
     b4a:	90 91 89 20 	lds	r25, 0x2089	; 0x802089 <rcvE1_write_index+0x1>
     b4e:	e8 0f       	add	r30, r24
     b50:	f9 1f       	adc	r31, r25
     b52:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
     b54:	80 91 88 20 	lds	r24, 0x2088	; 0x802088 <rcvE1_write_index>
     b58:	90 91 89 20 	lds	r25, 0x2089	; 0x802089 <rcvE1_write_index+0x1>
     b5c:	01 96       	adiw	r24, 0x01	; 1
     b5e:	84 36       	cpi	r24, 0x64	; 100
     b60:	91 05       	cpc	r25, r1
     b62:	60 f4       	brcc	.+24     	; 0xb7c <__vector_61+0x5c>
     b64:	80 93 88 20 	sts	0x2088, r24	; 0x802088 <rcvE1_write_index>
     b68:	90 93 89 20 	sts	0x2089, r25	; 0x802089 <rcvE1_write_index+0x1>
	rcvE1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
     b6c:	20 91 96 20 	lds	r18, 0x2096	; 0x802096 <rcvE1_read_index>
     b70:	30 91 97 20 	lds	r19, 0x2097	; 0x802097 <rcvE1_read_index+0x1>
     b74:	82 17       	cp	r24, r18
     b76:	93 07       	cpc	r25, r19
     b78:	f1 f4       	brne	.+60     	; 0xbb6 <__vector_61+0x96>
     b7a:	0c c0       	rjmp	.+24     	; 0xb94 <__vector_61+0x74>

	rcvE1_buffer[rcvE1_write_index] = USARTE1.DATA;

	// Increment the write pointer
	if (++rcvE1_write_index >= RSINT_BUF_SIZE)
	rcvE1_write_index = 0;
     b7c:	10 92 88 20 	sts	0x2088, r1	; 0x802088 <rcvE1_write_index>
     b80:	10 92 89 20 	sts	0x2089, r1	; 0x802089 <rcvE1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
     b84:	80 91 96 20 	lds	r24, 0x2096	; 0x802096 <rcvE1_read_index>
     b88:	90 91 97 20 	lds	r25, 0x2097	; 0x802097 <rcvE1_read_index+0x1>
     b8c:	18 16       	cp	r1, r24
     b8e:	19 06       	cpc	r1, r25
     b90:	91 f4       	brne	.+36     	; 0xbb6 <__vector_61+0x96>
     b92:	0e c0       	rjmp	.+28     	; 0xbb0 <__vector_61+0x90>
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
     b94:	01 96       	adiw	r24, 0x01	; 1
     b96:	84 36       	cpi	r24, 0x64	; 100
     b98:	91 05       	cpc	r25, r1
     b9a:	28 f4       	brcc	.+10     	; 0xba6 <__vector_61+0x86>
     b9c:	80 93 96 20 	sts	0x2096, r24	; 0x802096 <rcvE1_read_index>
     ba0:	90 93 97 20 	sts	0x2097, r25	; 0x802097 <rcvE1_read_index+0x1>
     ba4:	08 c0       	rjmp	.+16     	; 0xbb6 <__vector_61+0x96>
	rcvE1_read_index = 0;
     ba6:	10 92 96 20 	sts	0x2096, r1	; 0x802096 <rcvE1_read_index>
     baa:	10 92 97 20 	sts	0x2097, r1	; 0x802097 <rcvE1_read_index+0x1>
}
     bae:	03 c0       	rjmp	.+6      	; 0xbb6 <__vector_61+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE1_write_index == rcvE1_read_index)
	if (++rcvE1_read_index >= RSINT_BUF_SIZE)
     bb0:	81 e0       	ldi	r24, 0x01	; 1
     bb2:	90 e0       	ldi	r25, 0x00	; 0
     bb4:	f3 cf       	rjmp	.-26     	; 0xb9c <__vector_61+0x7c>
	rcvE1_read_index = 0;
}
     bb6:	ff 91       	pop	r31
     bb8:	ef 91       	pop	r30
     bba:	9f 91       	pop	r25
     bbc:	8f 91       	pop	r24
     bbe:	3f 91       	pop	r19
     bc0:	2f 91       	pop	r18
     bc2:	0f 90       	pop	r0
     bc4:	0b be       	out	0x3b, r0	; 59
     bc6:	0f 90       	pop	r0
     bc8:	0f be       	out	0x3f, r0	; 63
     bca:	0f 90       	pop	r0
     bcc:	1f 90       	pop	r1
     bce:	18 95       	reti

00000bd0 <__vector_119>:
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
     bd0:	1f 92       	push	r1
     bd2:	0f 92       	push	r0
     bd4:	0f b6       	in	r0, 0x3f	; 63
     bd6:	0f 92       	push	r0
     bd8:	11 24       	eor	r1, r1
     bda:	0b b6       	in	r0, 0x3b	; 59
     bdc:	0f 92       	push	r0
     bde:	2f 93       	push	r18
     be0:	3f 93       	push	r19
     be2:	8f 93       	push	r24
     be4:	9f 93       	push	r25
     be6:	ef 93       	push	r30
     be8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
     bea:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
     bee:	e0 91 a2 20 	lds	r30, 0x20A2	; 0x8020a2 <rcvF0_buffer>
     bf2:	f0 91 a3 20 	lds	r31, 0x20A3	; 0x8020a3 <rcvF0_buffer+0x1>
     bf6:	80 91 86 20 	lds	r24, 0x2086	; 0x802086 <__data_end>
     bfa:	90 91 87 20 	lds	r25, 0x2087	; 0x802087 <__data_end+0x1>
     bfe:	e8 0f       	add	r30, r24
     c00:	f9 1f       	adc	r31, r25
     c02:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
     c04:	80 91 86 20 	lds	r24, 0x2086	; 0x802086 <__data_end>
     c08:	90 91 87 20 	lds	r25, 0x2087	; 0x802087 <__data_end+0x1>
     c0c:	01 96       	adiw	r24, 0x01	; 1
     c0e:	84 36       	cpi	r24, 0x64	; 100
     c10:	91 05       	cpc	r25, r1
     c12:	60 f4       	brcc	.+24     	; 0xc2c <__vector_119+0x5c>
     c14:	80 93 86 20 	sts	0x2086, r24	; 0x802086 <__data_end>
     c18:	90 93 87 20 	sts	0x2087, r25	; 0x802087 <__data_end+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
     c1c:	20 91 94 20 	lds	r18, 0x2094	; 0x802094 <rcvF0_read_index>
     c20:	30 91 95 20 	lds	r19, 0x2095	; 0x802095 <rcvF0_read_index+0x1>
     c24:	82 17       	cp	r24, r18
     c26:	93 07       	cpc	r25, r19
     c28:	f1 f4       	brne	.+60     	; 0xc66 <__vector_119+0x96>
     c2a:	0c c0       	rjmp	.+24     	; 0xc44 <__vector_119+0x74>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
     c2c:	10 92 86 20 	sts	0x2086, r1	; 0x802086 <__data_end>
     c30:	10 92 87 20 	sts	0x2087, r1	; 0x802087 <__data_end+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
     c34:	80 91 94 20 	lds	r24, 0x2094	; 0x802094 <rcvF0_read_index>
     c38:	90 91 95 20 	lds	r25, 0x2095	; 0x802095 <rcvF0_read_index+0x1>
     c3c:	18 16       	cp	r1, r24
     c3e:	19 06       	cpc	r1, r25
     c40:	91 f4       	brne	.+36     	; 0xc66 <__vector_119+0x96>
     c42:	0e c0       	rjmp	.+28     	; 0xc60 <__vector_119+0x90>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
     c44:	01 96       	adiw	r24, 0x01	; 1
     c46:	84 36       	cpi	r24, 0x64	; 100
     c48:	91 05       	cpc	r25, r1
     c4a:	28 f4       	brcc	.+10     	; 0xc56 <__vector_119+0x86>
     c4c:	80 93 94 20 	sts	0x2094, r24	; 0x802094 <rcvF0_read_index>
     c50:	90 93 95 20 	sts	0x2095, r25	; 0x802095 <rcvF0_read_index+0x1>
     c54:	08 c0       	rjmp	.+16     	; 0xc66 <__vector_119+0x96>
	rcvF0_read_index = 0;
     c56:	10 92 94 20 	sts	0x2094, r1	; 0x802094 <rcvF0_read_index>
     c5a:	10 92 95 20 	sts	0x2095, r1	; 0x802095 <rcvF0_read_index+0x1>
}
     c5e:	03 c0       	rjmp	.+6      	; 0xc66 <__vector_119+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
     c60:	81 e0       	ldi	r24, 0x01	; 1
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	f3 cf       	rjmp	.-26     	; 0xc4c <__vector_119+0x7c>
	rcvF0_read_index = 0;
}
     c66:	ff 91       	pop	r31
     c68:	ef 91       	pop	r30
     c6a:	9f 91       	pop	r25
     c6c:	8f 91       	pop	r24
     c6e:	3f 91       	pop	r19
     c70:	2f 91       	pop	r18
     c72:	0f 90       	pop	r0
     c74:	0b be       	out	0x3b, r0	; 59
     c76:	0f 90       	pop	r0
     c78:	0f be       	out	0x3f, r0	; 63
     c7a:	0f 90       	pop	r0
     c7c:	1f 90       	pop	r1
     c7e:	18 95       	reti

00000c80 <_ZN8task_LED3runEv>:
//-------------------------------------------------------------------------------------
/** This task blinks an LED attached to PORTR Pin 1
 */

void task_LED::run (void)
{
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
     c84:	00 d0       	rcall	.+0      	; 0xc86 <_ZN8task_LED3runEv+0x6>
     c86:	1f 92       	push	r1
     c88:	cd b7       	in	r28, 0x3d	; 61
     c8a:	de b7       	in	r29, 0x3e	; 62
     c8c:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     c8e:	0e 94 9a 10 	call	0x2134	; 0x2134 <xTaskGetTickCount>
     c92:	69 83       	std	Y+1, r22	; 0x01
     c94:	7a 83       	std	Y+2, r23	; 0x02
     c96:	8b 83       	std	Y+3, r24	; 0x03
     c98:	9c 83       	std	Y+4, r25	; 0x04
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     c9a:	6a e0       	ldi	r22, 0x0A	; 10
     c9c:	70 e0       	ldi	r23, 0x00	; 0
     c9e:	80 e0       	ldi	r24, 0x00	; 0
     ca0:	90 e0       	ldi	r25, 0x00	; 0
     ca2:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskDelay>
			PORTR.OUTSET = PIN0_bm;
			transition_to(LED_ON);
			break;
			
		case LED_ON:
			PORTR.OUTCLR = PIN0_bm;
     ca6:	0f 2e       	mov	r0, r31
     ca8:	f0 ee       	ldi	r31, 0xE0	; 224
     caa:	ef 2e       	mov	r14, r31
     cac:	f7 e0       	ldi	r31, 0x07	; 7
     cae:	ff 2e       	mov	r15, r31
     cb0:	f0 2d       	mov	r31, r0
     cb2:	dd 24       	eor	r13, r13
     cb4:	d3 94       	inc	r13
	delay_ms(10);


	while(1)
	{
		switch (state)
     cb6:	f8 01       	movw	r30, r16
     cb8:	84 85       	ldd	r24, Z+12	; 0x0c
     cba:	82 30       	cpi	r24, 0x02	; 2
     cbc:	e1 f0       	breq	.+56     	; 0xcf6 <_ZN8task_LED3runEv+0x76>
     cbe:	28 f4       	brcc	.+10     	; 0xcca <_ZN8task_LED3runEv+0x4a>
     cc0:	88 23       	and	r24, r24
     cc2:	41 f0       	breq	.+16     	; 0xcd4 <_ZN8task_LED3runEv+0x54>
     cc4:	81 30       	cpi	r24, 0x01	; 1
     cc6:	81 f0       	breq	.+32     	; 0xce8 <_ZN8task_LED3runEv+0x68>
     cc8:	36 c0       	rjmp	.+108    	; 0xd36 <_ZN8task_LED3runEv+0xb6>
     cca:	83 30       	cpi	r24, 0x03	; 3
     ccc:	11 f1       	breq	.+68     	; 0xd12 <_ZN8task_LED3runEv+0x92>
     cce:	84 30       	cpi	r24, 0x04	; 4
     cd0:	39 f1       	breq	.+78     	; 0xd20 <_ZN8task_LED3runEv+0xa0>
     cd2:	31 c0       	rjmp	.+98     	; 0xd36 <_ZN8task_LED3runEv+0xb6>
		{
		case INIT:
			ctr=0;
     cd4:	f8 01       	movw	r30, r16
     cd6:	12 8a       	std	Z+18, r1	; 0x12
			PORTR.OUTCLR = PIN0_bm;				// Make sure the pin is off before configuring it as output
     cd8:	f7 01       	movw	r30, r14
     cda:	d6 82       	std	Z+6, r13	; 0x06
			PORTR.DIRSET = PIN0_bm;				// Set the pin as an output
     cdc:	d1 82       	std	Z+1, r13	; 0x01
			transition_to(LED_SET);
     cde:	6d 2d       	mov	r22, r13
     ce0:	c8 01       	movw	r24, r16
     ce2:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <_ZN8frt_task13transition_toEh>
			break;
     ce6:	27 c0       	rjmp	.+78     	; 0xd36 <_ZN8task_LED3runEv+0xb6>
			
		case LED_SET:
			PORTR.OUTSET = PIN0_bm;
     ce8:	f7 01       	movw	r30, r14
     cea:	d5 82       	std	Z+5, r13	; 0x05
			transition_to(LED_ON);
     cec:	62 e0       	ldi	r22, 0x02	; 2
     cee:	c8 01       	movw	r24, r16
     cf0:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <_ZN8frt_task13transition_toEh>
			break;
     cf4:	20 c0       	rjmp	.+64     	; 0xd36 <_ZN8task_LED3runEv+0xb6>
			
		case LED_ON:
			PORTR.OUTCLR = PIN0_bm;
     cf6:	f7 01       	movw	r30, r14
     cf8:	d6 82       	std	Z+6, r13	; 0x06
			if(++ctr==10)
     cfa:	f8 01       	movw	r30, r16
     cfc:	82 89       	ldd	r24, Z+18	; 0x12
     cfe:	8f 5f       	subi	r24, 0xFF	; 255
     d00:	82 8b       	std	Z+18, r24	; 0x12
     d02:	8a 30       	cpi	r24, 0x0A	; 10
     d04:	c1 f4       	brne	.+48     	; 0xd36 <_ZN8task_LED3runEv+0xb6>
			{
				ctr = 0;
     d06:	12 8a       	std	Z+18, r1	; 0x12
				transition_to(LED_CLR);
     d08:	63 e0       	ldi	r22, 0x03	; 3
     d0a:	c8 01       	movw	r24, r16
     d0c:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <_ZN8frt_task13transition_toEh>
     d10:	12 c0       	rjmp	.+36     	; 0xd36 <_ZN8task_LED3runEv+0xb6>
			}
			break;
			
		case LED_CLR:
			PORTR.OUTSET = PIN0_bm;
     d12:	f7 01       	movw	r30, r14
     d14:	d5 82       	std	Z+5, r13	; 0x05
			transition_to(LED_OFF);
     d16:	64 e0       	ldi	r22, 0x04	; 4
     d18:	c8 01       	movw	r24, r16
     d1a:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <_ZN8frt_task13transition_toEh>
			break;
     d1e:	0b c0       	rjmp	.+22     	; 0xd36 <_ZN8task_LED3runEv+0xb6>
			
		case LED_OFF:
			if(++ctr==90)
     d20:	f8 01       	movw	r30, r16
     d22:	82 89       	ldd	r24, Z+18	; 0x12
     d24:	8f 5f       	subi	r24, 0xFF	; 255
     d26:	82 8b       	std	Z+18, r24	; 0x12
     d28:	8a 35       	cpi	r24, 0x5A	; 90
     d2a:	29 f4       	brne	.+10     	; 0xd36 <_ZN8task_LED3runEv+0xb6>
			{
				ctr = 0;
     d2c:	12 8a       	std	Z+18, r1	; 0x12
				transition_to(LED_SET);
     d2e:	6d 2d       	mov	r22, r13
     d30:	c8 01       	movw	r24, r16
     d32:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <_ZN8frt_task13transition_toEh>
			break;
		
		default:
			break;
		}
		runs++;
     d36:	f8 01       	movw	r30, r16
     d38:	86 85       	ldd	r24, Z+14	; 0x0e
     d3a:	97 85       	ldd	r25, Z+15	; 0x0f
     d3c:	a0 89       	ldd	r26, Z+16	; 0x10
     d3e:	b1 89       	ldd	r27, Z+17	; 0x11
     d40:	01 96       	adiw	r24, 0x01	; 1
     d42:	a1 1d       	adc	r26, r1
     d44:	b1 1d       	adc	r27, r1
     d46:	86 87       	std	Z+14, r24	; 0x0e
     d48:	97 87       	std	Z+15, r25	; 0x0f
     d4a:	a0 8b       	std	Z+16, r26	; 0x10
     d4c:	b1 8b       	std	Z+17, r27	; 0x11
		 *  @param milliseconds The duration of the delay interval in milliseconds
		 */
		void delay_from_to_ms (portTickType& from_ticks, portTickType milliseconds)
		{
			portTickType interval = configMS_TO_TICKS (milliseconds);
			vTaskDelayUntil (&from_ticks, interval);
     d4e:	4a e0       	ldi	r20, 0x0A	; 10
     d50:	50 e0       	ldi	r21, 0x00	; 0
     d52:	60 e0       	ldi	r22, 0x00	; 0
     d54:	70 e0       	ldi	r23, 0x00	; 0
     d56:	ce 01       	movw	r24, r28
     d58:	01 96       	adiw	r24, 0x01	; 1
     d5a:	0e 94 38 12 	call	0x2470	; 0x2470 <vTaskDelayUntil>
     d5e:	ab cf       	rjmp	.-170    	; 0xcb6 <_ZN8task_LED3runEv+0x36>

00000d60 <_ZN8task_LEDC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_LED::task_LED (const char* a_name, 
     d60:	0f 93       	push	r16
     d62:	1f 93       	push	r17
     d64:	cf 93       	push	r28
     d66:	df 93       	push	r29
     d68:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d6a:	0e 94 d5 14 	call	0x29aa	; 0x29aa <_ZN8frt_taskC1EPKchjP8emstream>
     d6e:	8a e1       	ldi	r24, 0x1A	; 26
     d70:	90 e2       	ldi	r25, 0x20	; 32
     d72:	88 83       	st	Y, r24
     d74:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	1f 91       	pop	r17
     d7c:	0f 91       	pop	r16
     d7e:	08 95       	ret

00000d80 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     d80:	0f 93       	push	r16
     d82:	1f 93       	push	r17
     d84:	cf 93       	push	r28
     d86:	df 93       	push	r29
     d88:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     d8a:	0e 94 d5 14 	call	0x29aa	; 0x29aa <_ZN8frt_taskC1EPKchjP8emstream>
     d8e:	82 e2       	ldi	r24, 0x22	; 34
     d90:	90 e2       	ldi	r25, 0x20	; 32
     d92:	88 83       	st	Y, r24
     d94:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     d96:	df 91       	pop	r29
     d98:	cf 91       	pop	r28
     d9a:	1f 91       	pop	r17
     d9c:	0f 91       	pop	r16
     d9e:	08 95       	ret

00000da0 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     da0:	0f 93       	push	r16
     da2:	1f 93       	push	r17
     da4:	cf 93       	push	r28
     da6:	df 93       	push	r29
     da8:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     daa:	6a e0       	ldi	r22, 0x0A	; 10
     dac:	8e 81       	ldd	r24, Y+6	; 0x06
     dae:	9f 81       	ldd	r25, Y+7	; 0x07
     db0:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     db4:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     db6:	65 ed       	ldi	r22, 0xD5	; 213
     db8:	73 e0       	ldi	r23, 0x03	; 3
     dba:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     dbe:	6a e0       	ldi	r22, 0x0A	; 10
     dc0:	c8 01       	movw	r24, r16
     dc2:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     dc6:	8c 01       	movw	r16, r24
     dc8:	6f ec       	ldi	r22, 0xCF	; 207
     dca:	73 e0       	ldi	r23, 0x03	; 3
     dcc:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     dd0:	67 e0       	ldi	r22, 0x07	; 7
     dd2:	c8 01       	movw	r24, r16
     dd4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     dd8:	6a e0       	ldi	r22, 0x0A	; 10
     dda:	8e 81       	ldd	r24, Y+6	; 0x06
     ddc:	9f 81       	ldd	r25, Y+7	; 0x07
     dde:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     de2:	8c 01       	movw	r16, r24
     de4:	64 eb       	ldi	r22, 0xB4	; 180
     de6:	73 e0       	ldi	r23, 0x03	; 3
     de8:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     dec:	6a e0       	ldi	r22, 0x0A	; 10
     dee:	c8 01       	movw	r24, r16
     df0:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     df4:	8c 01       	movw	r16, r24
     df6:	6e ea       	ldi	r22, 0xAE	; 174
     df8:	73 e0       	ldi	r23, 0x03	; 3
     dfa:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     dfe:	66 e0       	ldi	r22, 0x06	; 6
     e00:	c8 01       	movw	r24, r16
     e02:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     e06:	6a e0       	ldi	r22, 0x0A	; 10
     e08:	8e 81       	ldd	r24, Y+6	; 0x06
     e0a:	9f 81       	ldd	r25, Y+7	; 0x07
     e0c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     e10:	8c 01       	movw	r16, r24
     e12:	67 e9       	ldi	r22, 0x97	; 151
     e14:	73 e0       	ldi	r23, 0x03	; 3
     e16:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     e1a:	66 e0       	ldi	r22, 0x06	; 6
     e1c:	c8 01       	movw	r24, r16
     e1e:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     e22:	6a e0       	ldi	r22, 0x0A	; 10
     e24:	8e 81       	ldd	r24, Y+6	; 0x06
     e26:	9f 81       	ldd	r25, Y+7	; 0x07
     e28:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     e2c:	8c 01       	movw	r16, r24
     e2e:	6b e7       	ldi	r22, 0x7B	; 123
     e30:	73 e0       	ldi	r23, 0x03	; 3
     e32:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     e36:	66 e0       	ldi	r22, 0x06	; 6
     e38:	c8 01       	movw	r24, r16
     e3a:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     e3e:	6a e0       	ldi	r22, 0x0A	; 10
     e40:	8e 81       	ldd	r24, Y+6	; 0x06
     e42:	9f 81       	ldd	r25, Y+7	; 0x07
     e44:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     e48:	8c 01       	movw	r16, r24
     e4a:	63 e6       	ldi	r22, 0x63	; 99
     e4c:	73 e0       	ldi	r23, 0x03	; 3
     e4e:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     e52:	66 e0       	ldi	r22, 0x06	; 6
     e54:	c8 01       	movw	r24, r16
     e56:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     e5a:	6a e0       	ldi	r22, 0x0A	; 10
     e5c:	8e 81       	ldd	r24, Y+6	; 0x06
     e5e:	9f 81       	ldd	r25, Y+7	; 0x07
     e60:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     e64:	8c 01       	movw	r16, r24
     e66:	62 e4       	ldi	r22, 0x42	; 66
     e68:	73 e0       	ldi	r23, 0x03	; 3
     e6a:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     e6e:	66 e0       	ldi	r22, 0x06	; 6
     e70:	c8 01       	movw	r24, r16
     e72:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     e76:	6a e0       	ldi	r22, 0x0A	; 10
     e78:	8e 81       	ldd	r24, Y+6	; 0x06
     e7a:	9f 81       	ldd	r25, Y+7	; 0x07
     e7c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     e80:	8c 01       	movw	r16, r24
     e82:	6b e1       	ldi	r22, 0x1B	; 27
     e84:	73 e0       	ldi	r23, 0x03	; 3
     e86:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     e8a:	66 e0       	ldi	r22, 0x06	; 6
     e8c:	c8 01       	movw	r24, r16
     e8e:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     e92:	6a e0       	ldi	r22, 0x0A	; 10
     e94:	8e 81       	ldd	r24, Y+6	; 0x06
     e96:	9f 81       	ldd	r25, Y+7	; 0x07
     e98:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     e9c:	8c 01       	movw	r16, r24
     e9e:	6d ef       	ldi	r22, 0xFD	; 253
     ea0:	72 e0       	ldi	r23, 0x02	; 2
     ea2:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     ea6:	66 e0       	ldi	r22, 0x06	; 6
     ea8:	c8 01       	movw	r24, r16
     eaa:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     eae:	6a e0       	ldi	r22, 0x0A	; 10
     eb0:	8e 81       	ldd	r24, Y+6	; 0x06
     eb2:	9f 81       	ldd	r25, Y+7	; 0x07
     eb4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     eb8:	8c 01       	movw	r16, r24
     eba:	62 ee       	ldi	r22, 0xE2	; 226
     ebc:	72 e0       	ldi	r23, 0x02	; 2
     ebe:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     ec2:	66 e0       	ldi	r22, 0x06	; 6
     ec4:	c8 01       	movw	r24, r16
     ec6:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     eca:	6a e0       	ldi	r22, 0x0A	; 10
     ecc:	8e 81       	ldd	r24, Y+6	; 0x06
     ece:	9f 81       	ldd	r25, Y+7	; 0x07
     ed0:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     ed4:	ec 01       	movw	r28, r24
     ed6:	63 ed       	ldi	r22, 0xD3	; 211
     ed8:	72 e0       	ldi	r23, 0x02	; 2
     eda:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     ede:	66 e0       	ldi	r22, 0x06	; 6
     ee0:	ce 01       	movw	r24, r28
     ee2:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
}
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
     eea:	1f 91       	pop	r17
     eec:	0f 91       	pop	r16
     eee:	08 95       	ret

00000ef0 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     ef0:	af 92       	push	r10
     ef2:	bf 92       	push	r11
     ef4:	cf 92       	push	r12
     ef6:	df 92       	push	r13
     ef8:	ef 92       	push	r14
     efa:	ff 92       	push	r15
     efc:	0f 93       	push	r16
     efe:	1f 93       	push	r17
     f00:	cf 93       	push	r28
     f02:	df 93       	push	r29
     f04:	00 d0       	rcall	.+0      	; 0xf06 <_ZN9task_user11show_statusEv+0x16>
     f06:	00 d0       	rcall	.+0      	; 0xf08 <_ZN9task_user11show_statusEv+0x18>
     f08:	cd b7       	in	r28, 0x3d	; 61
     f0a:	de b7       	in	r29, 0x3e	; 62
     f0c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f0e:	19 82       	std	Y+1, r1	; 0x01
     f10:	1a 82       	std	Y+2, r1	; 0x02
     f12:	1b 82       	std	Y+3, r1	; 0x03
     f14:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f16:	1d 82       	std	Y+5, r1	; 0x05
     f18:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     f1a:	0e 94 45 0a 	call	0x148a	; 0x148a <xPortGetFreeHeapSize>
     f1e:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     f20:	ce 01       	movw	r24, r28
     f22:	01 96       	adiw	r24, 0x01	; 1
     f24:	0e 94 86 18 	call	0x310c	; 0x310c <_ZN10time_stamp10set_to_nowEv>
     f28:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     f2a:	66 e0       	ldi	r22, 0x06	; 6
     f2c:	f8 01       	movw	r30, r16
     f2e:	86 81       	ldd	r24, Z+6	; 0x06
     f30:	97 81       	ldd	r25, Z+7	; 0x07
     f32:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     f36:	6a e0       	ldi	r22, 0x0A	; 10
     f38:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     f3c:	7c 01       	movw	r14, r24
     f3e:	68 eb       	ldi	r22, 0xB8	; 184
     f40:	72 e0       	ldi	r23, 0x02	; 2
     f42:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     f46:	6a e0       	ldi	r22, 0x0A	; 10
     f48:	c7 01       	movw	r24, r14
     f4a:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     f4e:	7c 01       	movw	r14, r24
     f50:	6c ea       	ldi	r22, 0xAC	; 172
     f52:	72 e0       	ldi	r23, 0x02	; 2
     f54:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     f58:	66 e0       	ldi	r22, 0x06	; 6
     f5a:	c7 01       	movw	r24, r14
     f5c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     f60:	6a e0       	ldi	r22, 0x0A	; 10
     f62:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     f66:	7c 01       	movw	r14, r24
     f68:	65 ea       	ldi	r22, 0xA5	; 165
     f6a:	72 e0       	ldi	r23, 0x02	; 2
     f6c:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     f70:	b5 01       	movw	r22, r10
     f72:	c7 01       	movw	r24, r14
     f74:	0e 94 2a 18 	call	0x3054	; 0x3054 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     f78:	6a e0       	ldi	r22, 0x0A	; 10
     f7a:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     f7e:	7c 01       	movw	r14, r24
     f80:	67 e9       	ldi	r22, 0x97	; 151
     f82:	72 e0       	ldi	r23, 0x02	; 2
     f84:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     f88:	b6 01       	movw	r22, r12
     f8a:	c7 01       	movw	r24, r14
     f8c:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZN8emstreamlsEj>
     f90:	6a e0       	ldi	r22, 0x0A	; 10
     f92:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     f96:	7c 01       	movw	r14, r24
     f98:	65 e9       	ldi	r22, 0x95	; 149
     f9a:	72 e0       	ldi	r23, 0x02	; 2
     f9c:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     fa0:	4f ef       	ldi	r20, 0xFF	; 255
     fa2:	5f e0       	ldi	r21, 0x0F	; 15
     fa4:	60 e0       	ldi	r22, 0x00	; 0
     fa6:	70 e0       	ldi	r23, 0x00	; 0
     fa8:	c7 01       	movw	r24, r14
     faa:	0e 94 cf 1a 	call	0x359e	; 0x359e <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     fae:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     fb2:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     fb6:	6a e0       	ldi	r22, 0x0A	; 10
     fb8:	f8 01       	movw	r30, r16
     fba:	86 81       	ldd	r24, Z+6	; 0x06
     fbc:	97 81       	ldd	r25, Z+7	; 0x07
     fbe:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     fc2:	7c 01       	movw	r14, r24
     fc4:	6a e8       	ldi	r22, 0x8A	; 138
     fc6:	72 e0       	ldi	r23, 0x02	; 2
     fc8:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
     fcc:	b6 01       	movw	r22, r12
     fce:	c7 01       	movw	r24, r14
     fd0:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZN8emstreamlsEj>
     fd4:	66 e0       	ldi	r22, 0x06	; 6
     fd6:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
     fda:	66 e0       	ldi	r22, 0x06	; 6
     fdc:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     fe0:	f8 01       	movw	r30, r16
     fe2:	86 81       	ldd	r24, Z+6	; 0x06
     fe4:	97 81       	ldd	r25, Z+7	; 0x07
     fe6:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <_Z15print_task_listP8emstream>
}
     fea:	26 96       	adiw	r28, 0x06	; 6
     fec:	cd bf       	out	0x3d, r28	; 61
     fee:	de bf       	out	0x3e, r29	; 62
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	1f 91       	pop	r17
     ff6:	0f 91       	pop	r16
     ff8:	ff 90       	pop	r15
     ffa:	ef 90       	pop	r14
     ffc:	df 90       	pop	r13
     ffe:	cf 90       	pop	r12
    1000:	bf 90       	pop	r11
    1002:	af 90       	pop	r10
    1004:	08 95       	ret

00001006 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1006:	cf 93       	push	r28
    1008:	df 93       	push	r29
    100a:	00 d0       	rcall	.+0      	; 0x100c <_ZN9task_user3runEv+0x6>
    100c:	00 d0       	rcall	.+0      	; 0x100e <_ZN9task_user3runEv+0x8>
    100e:	cd b7       	in	r28, 0x3d	; 61
    1010:	de b7       	in	r29, 0x3e	; 62
    1012:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1014:	19 82       	std	Y+1, r1	; 0x01
    1016:	1a 82       	std	Y+2, r1	; 0x02
    1018:	1b 82       	std	Y+3, r1	; 0x03
    101a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    101c:	1d 82       	std	Y+5, r1	; 0x05
    101e:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1020:	6a e0       	ldi	r22, 0x0A	; 10
    1022:	dc 01       	movw	r26, r24
    1024:	16 96       	adiw	r26, 0x06	; 6
    1026:	8d 91       	ld	r24, X+
    1028:	9c 91       	ld	r25, X
    102a:	17 97       	sbiw	r26, 0x07	; 7
    102c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    1030:	7c 01       	movw	r14, r24
    1032:	6e e1       	ldi	r22, 0x1E	; 30
    1034:	74 e0       	ldi	r23, 0x04	; 4
    1036:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    103a:	66 e0       	ldi	r22, 0x06	; 6
    103c:	c7 01       	movw	r24, r14
    103e:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1042:	f8 01       	movw	r30, r16
    1044:	84 85       	ldd	r24, Z+12	; 0x0c
    1046:	88 23       	and	r24, r24
    1048:	21 f0       	breq	.+8      	; 0x1052 <_ZN9task_user3runEv+0x4c>
    104a:	81 30       	cpi	r24, 0x01	; 1
    104c:	09 f4       	brne	.+2      	; 0x1050 <_ZN9task_user3runEv+0x4a>
    104e:	5d c0       	rjmp	.+186    	; 0x110a <_ZN9task_user3runEv+0x104>
    1050:	d8 c0       	rjmp	.+432    	; 0x1202 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1052:	86 81       	ldd	r24, Z+6	; 0x06
    1054:	97 81       	ldd	r25, Z+7	; 0x07
    1056:	dc 01       	movw	r26, r24
    1058:	ed 91       	ld	r30, X+
    105a:	fc 91       	ld	r31, X
    105c:	04 80       	ldd	r0, Z+4	; 0x04
    105e:	f5 81       	ldd	r31, Z+5	; 0x05
    1060:	e0 2d       	mov	r30, r0
    1062:	19 95       	eicall
    1064:	88 23       	and	r24, r24
    1066:	a9 f1       	breq	.+106    	; 0x10d2 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1068:	f8 01       	movw	r30, r16
    106a:	86 81       	ldd	r24, Z+6	; 0x06
    106c:	97 81       	ldd	r25, Z+7	; 0x07
    106e:	dc 01       	movw	r26, r24
    1070:	ed 91       	ld	r30, X+
    1072:	fc 91       	ld	r31, X
    1074:	06 80       	ldd	r0, Z+6	; 0x06
    1076:	f7 81       	ldd	r31, Z+7	; 0x07
    1078:	e0 2d       	mov	r30, r0
    107a:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    107c:	99 27       	eor	r25, r25
    107e:	81 30       	cpi	r24, 0x01	; 1
    1080:	91 05       	cpc	r25, r1
    1082:	f9 f0       	breq	.+62     	; 0x10c2 <_ZN9task_user3runEv+0xbc>
    1084:	03 97       	sbiw	r24, 0x03	; 3
    1086:	09 f0       	breq	.+2      	; 0x108a <_ZN9task_user3runEv+0x84>
    1088:	d8 c0       	rjmp	.+432    	; 0x123a <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    108a:	6a e0       	ldi	r22, 0x0A	; 10
    108c:	f8 01       	movw	r30, r16
    108e:	86 81       	ldd	r24, Z+6	; 0x06
    1090:	97 81       	ldd	r25, Z+7	; 0x07
    1092:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    1096:	8c 01       	movw	r16, r24
    1098:	60 e1       	ldi	r22, 0x10	; 16
    109a:	74 e0       	ldi	r23, 0x04	; 4
    109c:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    10a0:	66 e0       	ldi	r22, 0x06	; 6
    10a2:	c8 01       	movw	r24, r16
    10a4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    10a8:	93 e0       	ldi	r25, 0x03	; 3
    10aa:	88 ed       	ldi	r24, 0xD8	; 216
    10ac:	08 b6       	in	r0, 0x38	; 56
    10ae:	18 be       	out	0x38, r1	; 56
    10b0:	84 bf       	out	0x34, r24	; 52
    10b2:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    10b6:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    10ba:	81 fd       	sbrc	r24, 1
    10bc:	fc cf       	rjmp	.-8      	; 0x10b6 <_ZN9task_user3runEv+0xb0>
    10be:	08 be       	out	0x38, r0	; 56
    10c0:	ff cf       	rjmp	.-2      	; 0x10c0 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    10c2:	c8 01       	movw	r24, r16
    10c4:	0e 94 d0 06 	call	0xda0	; 0xda0 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    10c8:	61 e0       	ldi	r22, 0x01	; 1
    10ca:	c8 01       	movw	r24, r16
    10cc:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <_ZN8frt_task13transition_toEh>
							break;
    10d0:	b4 c0       	rjmp	.+360    	; 0x123a <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    10d2:	8c e1       	ldi	r24, 0x1C	; 28
    10d4:	91 e3       	ldi	r25, 0x31	; 49
    10d6:	0e 94 92 17 	call	0x2f24	; 0x2f24 <_ZN14frt_text_queue14check_for_charEv>
    10da:	88 23       	and	r24, r24
    10dc:	09 f4       	brne	.+2      	; 0x10e0 <_ZN9task_user3runEv+0xda>
    10de:	ad c0       	rjmp	.+346    	; 0x123a <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    10e0:	d8 01       	movw	r26, r16
    10e2:	16 96       	adiw	r26, 0x06	; 6
    10e4:	ed 91       	ld	r30, X+
    10e6:	fc 91       	ld	r31, X
    10e8:	17 97       	sbiw	r26, 0x07	; 7
    10ea:	01 90       	ld	r0, Z+
    10ec:	f0 81       	ld	r31, Z
    10ee:	e0 2d       	mov	r30, r0
    10f0:	e2 80       	ldd	r14, Z+2	; 0x02
    10f2:	f3 80       	ldd	r15, Z+3	; 0x03
    10f4:	8c e1       	ldi	r24, 0x1C	; 28
    10f6:	91 e3       	ldi	r25, 0x31	; 49
    10f8:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <_ZN14frt_text_queue7getcharEv>
    10fc:	68 2f       	mov	r22, r24
    10fe:	f8 01       	movw	r30, r16
    1100:	86 81       	ldd	r24, Z+6	; 0x06
    1102:	97 81       	ldd	r25, Z+7	; 0x07
    1104:	f7 01       	movw	r30, r14
    1106:	19 95       	eicall
    1108:	98 c0       	rjmp	.+304    	; 0x123a <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    110a:	86 81       	ldd	r24, Z+6	; 0x06
    110c:	97 81       	ldd	r25, Z+7	; 0x07
    110e:	dc 01       	movw	r26, r24
    1110:	ed 91       	ld	r30, X+
    1112:	fc 91       	ld	r31, X
    1114:	04 80       	ldd	r0, Z+4	; 0x04
    1116:	f5 81       	ldd	r31, Z+5	; 0x05
    1118:	e0 2d       	mov	r30, r0
    111a:	19 95       	eicall
    111c:	88 23       	and	r24, r24
    111e:	09 f4       	brne	.+2      	; 0x1122 <_ZN9task_user3runEv+0x11c>
    1120:	8c c0       	rjmp	.+280    	; 0x123a <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1122:	f8 01       	movw	r30, r16
    1124:	86 81       	ldd	r24, Z+6	; 0x06
    1126:	97 81       	ldd	r25, Z+7	; 0x07
    1128:	dc 01       	movw	r26, r24
    112a:	ed 91       	ld	r30, X+
    112c:	fc 91       	ld	r31, X
    112e:	06 80       	ldd	r0, Z+6	; 0x06
    1130:	f7 81       	ldd	r31, Z+7	; 0x07
    1132:	e0 2d       	mov	r30, r0
    1134:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1136:	9c 01       	movw	r18, r24
    1138:	33 27       	eor	r19, r19
    113a:	28 36       	cpi	r18, 0x68	; 104
    113c:	31 05       	cpc	r19, r1
    113e:	59 f1       	breq	.+86     	; 0x1196 <_ZN9task_user3runEv+0x190>
    1140:	3c f4       	brge	.+14     	; 0x1150 <_ZN9task_user3runEv+0x14a>
    1142:	2b 31       	cpi	r18, 0x1B	; 27
    1144:	31 05       	cpc	r19, r1
    1146:	59 f1       	breq	.+86     	; 0x119e <_ZN9task_user3runEv+0x198>
    1148:	25 36       	cpi	r18, 0x65	; 101
    114a:	31 05       	cpc	r19, r1
    114c:	41 f1       	breq	.+80     	; 0x119e <_ZN9task_user3runEv+0x198>
    114e:	3b c0       	rjmp	.+118    	; 0x11c6 <_ZN9task_user3runEv+0x1c0>
    1150:	23 37       	cpi	r18, 0x73	; 115
    1152:	31 05       	cpc	r19, r1
    1154:	c1 f0       	breq	.+48     	; 0x1186 <_ZN9task_user3runEv+0x180>
    1156:	26 37       	cpi	r18, 0x76	; 118
    1158:	31 05       	cpc	r19, r1
    115a:	89 f0       	breq	.+34     	; 0x117e <_ZN9task_user3runEv+0x178>
    115c:	2e 36       	cpi	r18, 0x6E	; 110
    115e:	31 05       	cpc	r19, r1
    1160:	91 f5       	brne	.+100    	; 0x11c6 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1162:	ce 01       	movw	r24, r28
    1164:	01 96       	adiw	r24, 0x01	; 1
    1166:	0e 94 86 18 	call	0x310c	; 0x310c <_ZN10time_stamp10set_to_nowEv>
    116a:	bc 01       	movw	r22, r24
    116c:	f8 01       	movw	r30, r16
    116e:	86 81       	ldd	r24, Z+6	; 0x06
    1170:	97 81       	ldd	r25, Z+7	; 0x07
    1172:	0e 94 2a 18 	call	0x3054	; 0x3054 <_ZlsR8emstreamR10time_stamp>
    1176:	66 e0       	ldi	r22, 0x06	; 6
    1178:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
							break;
    117c:	5e c0       	rjmp	.+188    	; 0x123a <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    117e:	c8 01       	movw	r24, r16
    1180:	0e 94 78 07 	call	0xef0	; 0xef0 <_ZN9task_user11show_statusEv>
							break;
    1184:	5a c0       	rjmp	.+180    	; 0x123a <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1186:	d8 01       	movw	r26, r16
    1188:	16 96       	adiw	r26, 0x06	; 6
    118a:	8d 91       	ld	r24, X+
    118c:	9c 91       	ld	r25, X
    118e:	17 97       	sbiw	r26, 0x07	; 7
    1190:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <_Z17print_task_stacksP8emstream>
							break;
    1194:	52 c0       	rjmp	.+164    	; 0x123a <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1196:	c8 01       	movw	r24, r16
    1198:	0e 94 d0 06 	call	0xda0	; 0xda0 <_ZN9task_user18print_help_messageEv>
							break;
    119c:	4e c0       	rjmp	.+156    	; 0x123a <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    119e:	6a e0       	ldi	r22, 0x0A	; 10
    11a0:	f8 01       	movw	r30, r16
    11a2:	86 81       	ldd	r24, Z+6	; 0x06
    11a4:	97 81       	ldd	r25, Z+7	; 0x07
    11a6:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    11aa:	7c 01       	movw	r14, r24
    11ac:	6e ef       	ldi	r22, 0xFE	; 254
    11ae:	73 e0       	ldi	r23, 0x03	; 3
    11b0:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    11b4:	66 e0       	ldi	r22, 0x06	; 6
    11b6:	c7 01       	movw	r24, r14
    11b8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    11bc:	60 e0       	ldi	r22, 0x00	; 0
    11be:	c8 01       	movw	r24, r16
    11c0:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <_ZN8frt_task13transition_toEh>
							break;
    11c4:	3a c0       	rjmp	.+116    	; 0x123a <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    11c6:	f8 01       	movw	r30, r16
    11c8:	a6 81       	ldd	r26, Z+6	; 0x06
    11ca:	b7 81       	ldd	r27, Z+7	; 0x07
    11cc:	ed 91       	ld	r30, X+
    11ce:	fc 91       	ld	r31, X
    11d0:	11 97       	sbiw	r26, 0x01	; 1
    11d2:	02 80       	ldd	r0, Z+2	; 0x02
    11d4:	f3 81       	ldd	r31, Z+3	; 0x03
    11d6:	e0 2d       	mov	r30, r0
    11d8:	68 2f       	mov	r22, r24
    11da:	cd 01       	movw	r24, r26
    11dc:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    11de:	6a e0       	ldi	r22, 0x0A	; 10
    11e0:	d8 01       	movw	r26, r16
    11e2:	16 96       	adiw	r26, 0x06	; 6
    11e4:	8d 91       	ld	r24, X+
    11e6:	9c 91       	ld	r25, X
    11e8:	17 97       	sbiw	r26, 0x07	; 7
    11ea:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    11ee:	7c 01       	movw	r14, r24
    11f0:	68 ef       	ldi	r22, 0xF8	; 248
    11f2:	73 e0       	ldi	r23, 0x03	; 3
    11f4:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    11f8:	66 e0       	ldi	r22, 0x06	; 6
    11fa:	c7 01       	movw	r24, r14
    11fc:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1200:	1c c0       	rjmp	.+56     	; 0x123a <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1202:	6a e0       	ldi	r22, 0x0A	; 10
    1204:	f8 01       	movw	r30, r16
    1206:	86 81       	ldd	r24, Z+6	; 0x06
    1208:	97 81       	ldd	r25, Z+7	; 0x07
    120a:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    120e:	8c 01       	movw	r16, r24
    1210:	6b ed       	ldi	r22, 0xDB	; 219
    1212:	73 e0       	ldi	r23, 0x03	; 3
    1214:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    1218:	66 e0       	ldi	r22, 0x06	; 6
    121a:	c8 01       	movw	r24, r16
    121c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1220:	93 e0       	ldi	r25, 0x03	; 3
    1222:	88 ed       	ldi	r24, 0xD8	; 216
    1224:	08 b6       	in	r0, 0x38	; 56
    1226:	18 be       	out	0x38, r1	; 56
    1228:	84 bf       	out	0x34, r24	; 52
    122a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    122e:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1232:	81 fd       	sbrc	r24, 1
    1234:	fc cf       	rjmp	.-8      	; 0x122e <_ZN9task_user3runEv+0x228>
    1236:	08 be       	out	0x38, r0	; 56
    1238:	ff cf       	rjmp	.-2      	; 0x1238 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    123a:	f8 01       	movw	r30, r16
    123c:	86 85       	ldd	r24, Z+14	; 0x0e
    123e:	97 85       	ldd	r25, Z+15	; 0x0f
    1240:	a0 89       	ldd	r26, Z+16	; 0x10
    1242:	b1 89       	ldd	r27, Z+17	; 0x11
    1244:	01 96       	adiw	r24, 0x01	; 1
    1246:	a1 1d       	adc	r26, r1
    1248:	b1 1d       	adc	r27, r1
    124a:	86 87       	std	Z+14, r24	; 0x0e
    124c:	97 87       	std	Z+15, r25	; 0x0f
    124e:	a0 8b       	std	Z+16, r26	; 0x10
    1250:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1252:	61 e0       	ldi	r22, 0x01	; 1
    1254:	70 e0       	ldi	r23, 0x00	; 0
    1256:	80 e0       	ldi	r24, 0x00	; 0
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    125e:	f1 ce       	rjmp	.-542    	; 0x1042 <_ZN9task_user3runEv+0x3c>

00001260 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    1260:	0f 93       	push	r16
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
    1266:	1f 92       	push	r1
    1268:	cd b7       	in	r28, 0x3d	; 61
    126a:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    126c:	2f b7       	in	r18, 0x3f	; 63
    126e:	29 83       	std	Y+1, r18	; 0x01
	cli();
    1270:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    1272:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    1274:	fc 01       	movw	r30, r24
    1276:	08 ed       	ldi	r16, 0xD8	; 216
    1278:	04 bf       	out	0x34, r16	; 52
    127a:	60 83       	st	Z, r22

	SREG = saved_sreg;
    127c:	89 81       	ldd	r24, Y+1	; 0x01
    127e:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    1280:	0f 90       	pop	r0
    1282:	df 91       	pop	r29
    1284:	cf 91       	pop	r28
    1286:	0f 91       	pop	r16
    1288:	08 95       	ret

0000128a <_Z15config_SYSCLOCKv>:


// Configure the system clock
void config_SYSCLOCK()
{
    128a:	cf 93       	push	r28
    128c:	df 93       	push	r29
    128e:	1f 92       	push	r1
    1290:	cd b7       	in	r28, 0x3d	; 61
    1292:	de b7       	in	r29, 0x3e	; 62
	// this function is condensed AVR1003 example code that only enables a 16MHz external crystal -> 32Mhz clock or use of internal crystal.
	uint8_t volatile saved_sreg = SREG;
    1294:	8f b7       	in	r24, 0x3f	; 63
    1296:	89 83       	std	Y+1, r24	; 0x01
	cli();
    1298:	f8 94       	cli
	
	//below code is for enabling external 16MHz crystal to 32MHz clock on XMega MCU
	OSC.XOSCCTRL = OSC_FRQRANGE_12TO16_gc | OSC_XOSCSEL_XTAL_16KCLK_gc;				// Configure the external clock frequency and configure startup time
    129a:	e0 e5       	ldi	r30, 0x50	; 80
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	8b ec       	ldi	r24, 0xCB	; 203
    12a0:	82 83       	std	Z+2, r24	; 0x02
	OSC.CTRL |= OSC_XOSCEN_bm;														// Enable the external clock
    12a2:	80 81       	ld	r24, Z
    12a4:	88 60       	ori	r24, 0x08	; 8
    12a6:	80 83       	st	Z, r24
	do {} while((OSC.STATUS & (OSC_XOSCRDY_bm)) != (OSC_XOSCRDY_bm));					// Wait for a stable clock
    12a8:	81 81       	ldd	r24, Z+1	; 0x01
    12aa:	83 ff       	sbrs	r24, 3
    12ac:	fd cf       	rjmp	.-6      	; 0x12a8 <_Z15config_SYSCLOCKv+0x1e>
	OSC.PLLCTRL = OSC_PLLSRC_XOSC_gc | OSC_PLLFAC1_bm;								// Configure the PLL factor and divider and select external clock as source
    12ae:	e0 e5       	ldi	r30, 0x50	; 80
    12b0:	f0 e0       	ldi	r31, 0x00	; 0
    12b2:	82 ec       	ldi	r24, 0xC2	; 194
    12b4:	85 83       	std	Z+5, r24	; 0x05
	OSC.CTRL |= OSC_PLLEN_bm;															// Enable the PLL
    12b6:	80 81       	ld	r24, Z
    12b8:	80 61       	ori	r24, 0x10	; 16
    12ba:	80 83       	st	Z, r24
	do {} while((OSC.STATUS & (OSC_PLLRDY_bm)) != (OSC_PLLRDY_bm));					// Wait for a stable PLL clock
    12bc:	81 81       	ldd	r24, Z+1	; 0x01
    12be:	84 ff       	sbrs	r24, 4
    12c0:	fd cf       	rjmp	.-6      	; 0x12bc <_Z15config_SYSCLOCKv+0x32>
	
	//This code below is CLKSYS_Main_ClockSource_Select from AVR1003 ex code for 16MHz -> 32MHz clock PLL
	uint8_t CLK_CTRL_TEMP = (CLK.CTRL & ~CLK_SCLKSEL_gm) | (CLK_SCLKSEL_PLL_gc);
    12c2:	e0 e4       	ldi	r30, 0x40	; 64
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	60 81       	ld	r22, Z
    12c8:	68 7f       	andi	r22, 0xF8	; 248
    12ca:	64 60       	ori	r22, 0x04	; 4
	CLK.CTRL = CLK_CTRL_TEMP;
    12cc:	60 83       	st	Z, r22
	CCP = 0xD8;																		//this should be already contained in CCPWrite, so redundant I think
    12ce:	88 ed       	ldi	r24, 0xD8	; 216
    12d0:	84 bf       	out	0x34, r24	; 52
	CCPWrite(&(CLK.CTRL),CLK_CTRL_TEMP);
    12d2:	80 e4       	ldi	r24, 0x40	; 64
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	0e 94 30 09 	call	0x1260	; 0x1260 <_Z8CCPWritePVhh>
	OSC.CTRL &= ~(CLK_SCLKSEL_PLL_gc);
    12da:	e0 e5       	ldi	r30, 0x50	; 80
    12dc:	f0 e0       	ldi	r31, 0x00	; 0
    12de:	80 81       	ld	r24, Z
    12e0:	8b 7f       	andi	r24, 0xFB	; 251
    12e2:	80 83       	st	Z, r24
	SREG = saved_sreg;
    12e4:	89 81       	ldd	r24, Y+1	; 0x01
    12e6:	8f bf       	out	0x3f, r24	; 63
	//CLK.CTRL = CLK_CTRL_TEMP;
	//CCP = 0xD8;																		//this should be already contained in CCPWrite, so redundant I think
	//CCPWrite(&(CLK.CTRL),CLK_CTRL_TEMP);
	//OSC.CTRL &= ~(OSC_RC2MEN_bm);
	//SREG = saved_sreg;
    12e8:	0f 90       	pop	r0
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	08 95       	ret

000012f0 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    12f0:	0f 93       	push	r16
    12f2:	1f 93       	push	r17
    12f4:	cf 93       	push	r28
    12f6:	df 93       	push	r29
    12f8:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    12fa:	0e 94 94 10 	call	0x2128	; 0x2128 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    12fe:	80 91 b0 20 	lds	r24, 0x20B0	; 0x8020b0 <xHeapHasBeenInitialised.4150>
    1302:	81 11       	cpse	r24, r1
    1304:	1d c0       	rjmp	.+58     	; 0x1340 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1306:	a5 eb       	ldi	r26, 0xB5	; 181
    1308:	b0 e2       	ldi	r27, 0x20	; 32
    130a:	e9 eb       	ldi	r30, 0xB9	; 185
    130c:	f0 e2       	ldi	r31, 0x20	; 32
    130e:	ed 93       	st	X+, r30
    1310:	fc 93       	st	X, r31
    1312:	11 97       	sbiw	r26, 0x01	; 1
    1314:	12 96       	adiw	r26, 0x02	; 2
    1316:	1d 92       	st	X+, r1
    1318:	1c 92       	st	X, r1
    131a:	13 97       	sbiw	r26, 0x03	; 3
    131c:	a1 eb       	ldi	r26, 0xB1	; 177
    131e:	b0 e2       	ldi	r27, 0x20	; 32
    1320:	8f ef       	ldi	r24, 0xFF	; 255
    1322:	9f e0       	ldi	r25, 0x0F	; 15
    1324:	12 96       	adiw	r26, 0x02	; 2
    1326:	8d 93       	st	X+, r24
    1328:	9c 93       	st	X, r25
    132a:	13 97       	sbiw	r26, 0x03	; 3
    132c:	1d 92       	st	X+, r1
    132e:	1c 92       	st	X, r1
    1330:	11 97       	sbiw	r26, 0x01	; 1
    1332:	82 83       	std	Z+2, r24	; 0x02
    1334:	93 83       	std	Z+3, r25	; 0x03
    1336:	a0 83       	st	Z, r26
    1338:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    133a:	81 e0       	ldi	r24, 0x01	; 1
    133c:	80 93 b0 20 	sts	0x20B0, r24	; 0x8020b0 <xHeapHasBeenInitialised.4150>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1340:	20 97       	sbiw	r28, 0x00	; 0
    1342:	09 f4       	brne	.+2      	; 0x1346 <pvPortMalloc+0x56>
    1344:	5f c0       	rjmp	.+190    	; 0x1404 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1346:	9e 01       	movw	r18, r28
    1348:	2b 5f       	subi	r18, 0xFB	; 251
    134a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    134c:	24 96       	adiw	r28, 0x04	; 4
    134e:	ce 3f       	cpi	r28, 0xFE	; 254
    1350:	df 40       	sbci	r29, 0x0F	; 15
    1352:	08 f0       	brcs	.+2      	; 0x1356 <pvPortMalloc+0x66>
    1354:	5a c0       	rjmp	.+180    	; 0x140a <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1356:	e0 91 b5 20 	lds	r30, 0x20B5	; 0x8020b5 <xStart>
    135a:	f0 91 b6 20 	lds	r31, 0x20B6	; 0x8020b6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    135e:	a5 eb       	ldi	r26, 0xB5	; 181
    1360:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1362:	02 c0       	rjmp	.+4      	; 0x1368 <pvPortMalloc+0x78>
    1364:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1366:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1368:	82 81       	ldd	r24, Z+2	; 0x02
    136a:	93 81       	ldd	r25, Z+3	; 0x03
    136c:	82 17       	cp	r24, r18
    136e:	93 07       	cpc	r25, r19
    1370:	20 f4       	brcc	.+8      	; 0x137a <pvPortMalloc+0x8a>
    1372:	80 81       	ld	r24, Z
    1374:	91 81       	ldd	r25, Z+1	; 0x01
    1376:	00 97       	sbiw	r24, 0x00	; 0
    1378:	a9 f7       	brne	.-22     	; 0x1364 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    137a:	c0 e2       	ldi	r28, 0x20	; 32
    137c:	e1 3b       	cpi	r30, 0xB1	; 177
    137e:	fc 07       	cpc	r31, r28
    1380:	09 f4       	brne	.+2      	; 0x1384 <pvPortMalloc+0x94>
    1382:	46 c0       	rjmp	.+140    	; 0x1410 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1384:	cd 91       	ld	r28, X+
    1386:	dc 91       	ld	r29, X
    1388:	11 97       	sbiw	r26, 0x01	; 1
    138a:	8e 01       	movw	r16, r28
    138c:	0b 5f       	subi	r16, 0xFB	; 251
    138e:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1390:	80 81       	ld	r24, Z
    1392:	91 81       	ldd	r25, Z+1	; 0x01
    1394:	8d 93       	st	X+, r24
    1396:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1398:	82 81       	ldd	r24, Z+2	; 0x02
    139a:	93 81       	ldd	r25, Z+3	; 0x03
    139c:	82 1b       	sub	r24, r18
    139e:	93 0b       	sbc	r25, r19
    13a0:	8b 30       	cpi	r24, 0x0B	; 11
    13a2:	91 05       	cpc	r25, r1
    13a4:	10 f1       	brcs	.+68     	; 0x13ea <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    13a6:	bf 01       	movw	r22, r30
    13a8:	62 0f       	add	r22, r18
    13aa:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    13ac:	db 01       	movw	r26, r22
    13ae:	12 96       	adiw	r26, 0x02	; 2
    13b0:	8d 93       	st	X+, r24
    13b2:	9c 93       	st	X, r25
    13b4:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    13b6:	22 83       	std	Z+2, r18	; 0x02
    13b8:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    13ba:	12 96       	adiw	r26, 0x02	; 2
    13bc:	4d 91       	ld	r20, X+
    13be:	5c 91       	ld	r21, X
    13c0:	13 97       	sbiw	r26, 0x03	; 3
    13c2:	85 eb       	ldi	r24, 0xB5	; 181
    13c4:	90 e2       	ldi	r25, 0x20	; 32
    13c6:	01 c0       	rjmp	.+2      	; 0x13ca <pvPortMalloc+0xda>
    13c8:	cd 01       	movw	r24, r26
    13ca:	ec 01       	movw	r28, r24
    13cc:	a8 81       	ld	r26, Y
    13ce:	b9 81       	ldd	r27, Y+1	; 0x01
    13d0:	12 96       	adiw	r26, 0x02	; 2
    13d2:	2d 91       	ld	r18, X+
    13d4:	3c 91       	ld	r19, X
    13d6:	13 97       	sbiw	r26, 0x03	; 3
    13d8:	24 17       	cp	r18, r20
    13da:	35 07       	cpc	r19, r21
    13dc:	a8 f3       	brcs	.-22     	; 0x13c8 <pvPortMalloc+0xd8>
    13de:	eb 01       	movw	r28, r22
    13e0:	a8 83       	st	Y, r26
    13e2:	b9 83       	std	Y+1, r27	; 0x01
    13e4:	dc 01       	movw	r26, r24
    13e6:	6d 93       	st	X+, r22
    13e8:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    13ea:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    13ee:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    13f2:	22 81       	ldd	r18, Z+2	; 0x02
    13f4:	33 81       	ldd	r19, Z+3	; 0x03
    13f6:	82 1b       	sub	r24, r18
    13f8:	93 0b       	sbc	r25, r19
    13fa:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    13fe:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1402:	08 c0       	rjmp	.+16     	; 0x1414 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1404:	00 e0       	ldi	r16, 0x00	; 0
    1406:	10 e0       	ldi	r17, 0x00	; 0
    1408:	05 c0       	rjmp	.+10     	; 0x1414 <pvPortMalloc+0x124>
    140a:	00 e0       	ldi	r16, 0x00	; 0
    140c:	10 e0       	ldi	r17, 0x00	; 0
    140e:	02 c0       	rjmp	.+4      	; 0x1414 <pvPortMalloc+0x124>
    1410:	00 e0       	ldi	r16, 0x00	; 0
    1412:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1414:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1418:	c8 01       	movw	r24, r16
    141a:	df 91       	pop	r29
    141c:	cf 91       	pop	r28
    141e:	1f 91       	pop	r17
    1420:	0f 91       	pop	r16
    1422:	08 95       	ret

00001424 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1424:	0f 93       	push	r16
    1426:	1f 93       	push	r17
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    142c:	00 97       	sbiw	r24, 0x00	; 0
    142e:	41 f1       	breq	.+80     	; 0x1480 <vPortFree+0x5c>
    1430:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1432:	8c 01       	movw	r16, r24
    1434:	05 50       	subi	r16, 0x05	; 5
    1436:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1438:	0e 94 94 10 	call	0x2128	; 0x2128 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    143c:	f8 01       	movw	r30, r16
    143e:	42 81       	ldd	r20, Z+2	; 0x02
    1440:	53 81       	ldd	r21, Z+3	; 0x03
    1442:	a5 eb       	ldi	r26, 0xB5	; 181
    1444:	b0 e2       	ldi	r27, 0x20	; 32
    1446:	01 c0       	rjmp	.+2      	; 0x144a <vPortFree+0x26>
    1448:	df 01       	movw	r26, r30
    144a:	ed 91       	ld	r30, X+
    144c:	fc 91       	ld	r31, X
    144e:	11 97       	sbiw	r26, 0x01	; 1
    1450:	22 81       	ldd	r18, Z+2	; 0x02
    1452:	33 81       	ldd	r19, Z+3	; 0x03
    1454:	24 17       	cp	r18, r20
    1456:	35 07       	cpc	r19, r21
    1458:	b8 f3       	brcs	.-18     	; 0x1448 <vPortFree+0x24>
    145a:	25 97       	sbiw	r28, 0x05	; 5
    145c:	e8 83       	st	Y, r30
    145e:	f9 83       	std	Y+1, r31	; 0x01
    1460:	0d 93       	st	X+, r16
    1462:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1464:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1468:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    146c:	8a 81       	ldd	r24, Y+2	; 0x02
    146e:	9b 81       	ldd	r25, Y+3	; 0x03
    1470:	82 0f       	add	r24, r18
    1472:	93 1f       	adc	r25, r19
    1474:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1478:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    147c:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
	}
}
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	1f 91       	pop	r17
    1486:	0f 91       	pop	r16
    1488:	08 95       	ret

0000148a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    148a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    148e:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1492:	08 95       	ret

00001494 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1494:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1496:	03 96       	adiw	r24, 0x03	; 3
    1498:	81 83       	std	Z+1, r24	; 0x01
    149a:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    149c:	4f ef       	ldi	r20, 0xFF	; 255
    149e:	5f ef       	ldi	r21, 0xFF	; 255
    14a0:	ba 01       	movw	r22, r20
    14a2:	43 83       	std	Z+3, r20	; 0x03
    14a4:	54 83       	std	Z+4, r21	; 0x04
    14a6:	65 83       	std	Z+5, r22	; 0x05
    14a8:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    14aa:	87 83       	std	Z+7, r24	; 0x07
    14ac:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    14ae:	81 87       	std	Z+9, r24	; 0x09
    14b0:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    14b2:	10 82       	st	Z, r1
    14b4:	08 95       	ret

000014b6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    14b6:	fc 01       	movw	r30, r24
    14b8:	12 86       	std	Z+10, r1	; 0x0a
    14ba:	13 86       	std	Z+11, r1	; 0x0b
    14bc:	08 95       	ret

000014be <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    14be:	cf 93       	push	r28
    14c0:	df 93       	push	r29
    14c2:	fc 01       	movw	r30, r24
    14c4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    14c6:	21 81       	ldd	r18, Z+1	; 0x01
    14c8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    14ca:	e9 01       	movw	r28, r18
    14cc:	8c 81       	ldd	r24, Y+4	; 0x04
    14ce:	9d 81       	ldd	r25, Y+5	; 0x05
    14d0:	14 96       	adiw	r26, 0x04	; 4
    14d2:	8d 93       	st	X+, r24
    14d4:	9c 93       	st	X, r25
    14d6:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    14d8:	81 81       	ldd	r24, Z+1	; 0x01
    14da:	92 81       	ldd	r25, Z+2	; 0x02
    14dc:	16 96       	adiw	r26, 0x06	; 6
    14de:	8d 93       	st	X+, r24
    14e0:	9c 93       	st	X, r25
    14e2:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    14e4:	8c 81       	ldd	r24, Y+4	; 0x04
    14e6:	9d 81       	ldd	r25, Y+5	; 0x05
    14e8:	ec 01       	movw	r28, r24
    14ea:	6e 83       	std	Y+6, r22	; 0x06
    14ec:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    14ee:	e9 01       	movw	r28, r18
    14f0:	6c 83       	std	Y+4, r22	; 0x04
    14f2:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    14f4:	61 83       	std	Z+1, r22	; 0x01
    14f6:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14f8:	1a 96       	adiw	r26, 0x0a	; 10
    14fa:	ed 93       	st	X+, r30
    14fc:	fc 93       	st	X, r31
    14fe:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1500:	80 81       	ld	r24, Z
    1502:	8f 5f       	subi	r24, 0xFF	; 255
    1504:	80 83       	st	Z, r24
}
    1506:	df 91       	pop	r29
    1508:	cf 91       	pop	r28
    150a:	08 95       	ret

0000150c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    150c:	0f 93       	push	r16
    150e:	1f 93       	push	r17
    1510:	cf 93       	push	r28
    1512:	df 93       	push	r29
    1514:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1516:	08 81       	ld	r16, Y
    1518:	19 81       	ldd	r17, Y+1	; 0x01
    151a:	2a 81       	ldd	r18, Y+2	; 0x02
    151c:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    151e:	0f 3f       	cpi	r16, 0xFF	; 255
    1520:	4f ef       	ldi	r20, 0xFF	; 255
    1522:	14 07       	cpc	r17, r20
    1524:	24 07       	cpc	r18, r20
    1526:	34 07       	cpc	r19, r20
    1528:	31 f4       	brne	.+12     	; 0x1536 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    152a:	dc 01       	movw	r26, r24
    152c:	19 96       	adiw	r26, 0x09	; 9
    152e:	ed 91       	ld	r30, X+
    1530:	fc 91       	ld	r31, X
    1532:	1a 97       	sbiw	r26, 0x0a	; 10
    1534:	1f c0       	rjmp	.+62     	; 0x1574 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1536:	fc 01       	movw	r30, r24
    1538:	33 96       	adiw	r30, 0x03	; 3
    153a:	dc 01       	movw	r26, r24
    153c:	17 96       	adiw	r26, 0x07	; 7
    153e:	4d 91       	ld	r20, X+
    1540:	5c 91       	ld	r21, X
    1542:	18 97       	sbiw	r26, 0x08	; 8
    1544:	da 01       	movw	r26, r20
    1546:	4d 91       	ld	r20, X+
    1548:	5d 91       	ld	r21, X+
    154a:	6d 91       	ld	r22, X+
    154c:	7c 91       	ld	r23, X
    154e:	04 17       	cp	r16, r20
    1550:	15 07       	cpc	r17, r21
    1552:	26 07       	cpc	r18, r22
    1554:	37 07       	cpc	r19, r23
    1556:	70 f0       	brcs	.+28     	; 0x1574 <vListInsert+0x68>
    1558:	04 80       	ldd	r0, Z+4	; 0x04
    155a:	f5 81       	ldd	r31, Z+5	; 0x05
    155c:	e0 2d       	mov	r30, r0
    155e:	a4 81       	ldd	r26, Z+4	; 0x04
    1560:	b5 81       	ldd	r27, Z+5	; 0x05
    1562:	4d 91       	ld	r20, X+
    1564:	5d 91       	ld	r21, X+
    1566:	6d 91       	ld	r22, X+
    1568:	7c 91       	ld	r23, X
    156a:	04 17       	cp	r16, r20
    156c:	15 07       	cpc	r17, r21
    156e:	26 07       	cpc	r18, r22
    1570:	37 07       	cpc	r19, r23
    1572:	90 f7       	brcc	.-28     	; 0x1558 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1574:	a4 81       	ldd	r26, Z+4	; 0x04
    1576:	b5 81       	ldd	r27, Z+5	; 0x05
    1578:	ac 83       	std	Y+4, r26	; 0x04
    157a:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    157c:	16 96       	adiw	r26, 0x06	; 6
    157e:	cd 93       	st	X+, r28
    1580:	dc 93       	st	X, r29
    1582:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1584:	ee 83       	std	Y+6, r30	; 0x06
    1586:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1588:	c4 83       	std	Z+4, r28	; 0x04
    158a:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    158c:	8a 87       	std	Y+10, r24	; 0x0a
    158e:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1590:	fc 01       	movw	r30, r24
    1592:	20 81       	ld	r18, Z
    1594:	2f 5f       	subi	r18, 0xFF	; 255
    1596:	20 83       	st	Z, r18
}
    1598:	df 91       	pop	r29
    159a:	cf 91       	pop	r28
    159c:	1f 91       	pop	r17
    159e:	0f 91       	pop	r16
    15a0:	08 95       	ret

000015a2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    15a2:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    15a4:	a4 81       	ldd	r26, Z+4	; 0x04
    15a6:	b5 81       	ldd	r27, Z+5	; 0x05
    15a8:	86 81       	ldd	r24, Z+6	; 0x06
    15aa:	97 81       	ldd	r25, Z+7	; 0x07
    15ac:	16 96       	adiw	r26, 0x06	; 6
    15ae:	8d 93       	st	X+, r24
    15b0:	9c 93       	st	X, r25
    15b2:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    15b4:	a6 81       	ldd	r26, Z+6	; 0x06
    15b6:	b7 81       	ldd	r27, Z+7	; 0x07
    15b8:	84 81       	ldd	r24, Z+4	; 0x04
    15ba:	95 81       	ldd	r25, Z+5	; 0x05
    15bc:	14 96       	adiw	r26, 0x04	; 4
    15be:	8d 93       	st	X+, r24
    15c0:	9c 93       	st	X, r25
    15c2:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    15c4:	a2 85       	ldd	r26, Z+10	; 0x0a
    15c6:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    15c8:	11 96       	adiw	r26, 0x01	; 1
    15ca:	8d 91       	ld	r24, X+
    15cc:	9c 91       	ld	r25, X
    15ce:	12 97       	sbiw	r26, 0x02	; 2
    15d0:	e8 17       	cp	r30, r24
    15d2:	f9 07       	cpc	r31, r25
    15d4:	31 f4       	brne	.+12     	; 0x15e2 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    15d6:	86 81       	ldd	r24, Z+6	; 0x06
    15d8:	97 81       	ldd	r25, Z+7	; 0x07
    15da:	11 96       	adiw	r26, 0x01	; 1
    15dc:	8d 93       	st	X+, r24
    15de:	9c 93       	st	X, r25
    15e0:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    15e2:	12 86       	std	Z+10, r1	; 0x0a
    15e4:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    15e6:	8c 91       	ld	r24, X
    15e8:	81 50       	subi	r24, 0x01	; 1
    15ea:	8c 93       	st	X, r24
    15ec:	08 95       	ret

000015ee <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    15ee:	80 93 2c 31 	sts	0x312C, r24	; 0x80312c <portStackTopForTask>
    15f2:	90 93 2d 31 	sts	0x312D, r25	; 0x80312d <portStackTopForTask+0x1>
    15f6:	31 e1       	ldi	r19, 0x11	; 17
    15f8:	fc 01       	movw	r30, r24
    15fa:	30 83       	st	Z, r19
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	22 e2       	ldi	r18, 0x22	; 34
    1600:	20 83       	st	Z, r18
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	a3 e3       	ldi	r26, 0x33	; 51
    1606:	a0 83       	st	Z, r26
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	60 83       	st	Z, r22
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	70 83       	st	Z, r23
    1610:	31 97       	sbiw	r30, 0x01	; 1
    1612:	10 82       	st	Z, r1
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	10 82       	st	Z, r1
    1618:	31 97       	sbiw	r30, 0x01	; 1
    161a:	60 e8       	ldi	r22, 0x80	; 128
    161c:	60 83       	st	Z, r22
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	10 82       	st	Z, r1
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	10 82       	st	Z, r1
    1626:	31 97       	sbiw	r30, 0x01	; 1
    1628:	10 82       	st	Z, r1
    162a:	31 97       	sbiw	r30, 0x01	; 1
    162c:	62 e0       	ldi	r22, 0x02	; 2
    162e:	60 83       	st	Z, r22
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	63 e0       	ldi	r22, 0x03	; 3
    1634:	60 83       	st	Z, r22
    1636:	31 97       	sbiw	r30, 0x01	; 1
    1638:	64 e0       	ldi	r22, 0x04	; 4
    163a:	60 83       	st	Z, r22
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	65 e0       	ldi	r22, 0x05	; 5
    1640:	60 83       	st	Z, r22
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	66 e0       	ldi	r22, 0x06	; 6
    1646:	60 83       	st	Z, r22
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	67 e0       	ldi	r22, 0x07	; 7
    164c:	60 83       	st	Z, r22
    164e:	31 97       	sbiw	r30, 0x01	; 1
    1650:	68 e0       	ldi	r22, 0x08	; 8
    1652:	60 83       	st	Z, r22
    1654:	31 97       	sbiw	r30, 0x01	; 1
    1656:	69 e0       	ldi	r22, 0x09	; 9
    1658:	60 83       	st	Z, r22
    165a:	31 97       	sbiw	r30, 0x01	; 1
    165c:	60 e1       	ldi	r22, 0x10	; 16
    165e:	60 83       	st	Z, r22
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	30 83       	st	Z, r19
    1664:	31 97       	sbiw	r30, 0x01	; 1
    1666:	32 e1       	ldi	r19, 0x12	; 18
    1668:	30 83       	st	Z, r19
    166a:	31 97       	sbiw	r30, 0x01	; 1
    166c:	33 e1       	ldi	r19, 0x13	; 19
    166e:	30 83       	st	Z, r19
    1670:	31 97       	sbiw	r30, 0x01	; 1
    1672:	34 e1       	ldi	r19, 0x14	; 20
    1674:	30 83       	st	Z, r19
    1676:	31 97       	sbiw	r30, 0x01	; 1
    1678:	35 e1       	ldi	r19, 0x15	; 21
    167a:	30 83       	st	Z, r19
    167c:	31 97       	sbiw	r30, 0x01	; 1
    167e:	36 e1       	ldi	r19, 0x16	; 22
    1680:	30 83       	st	Z, r19
    1682:	31 97       	sbiw	r30, 0x01	; 1
    1684:	37 e1       	ldi	r19, 0x17	; 23
    1686:	30 83       	st	Z, r19
    1688:	31 97       	sbiw	r30, 0x01	; 1
    168a:	38 e1       	ldi	r19, 0x18	; 24
    168c:	30 83       	st	Z, r19
    168e:	31 97       	sbiw	r30, 0x01	; 1
    1690:	39 e1       	ldi	r19, 0x19	; 25
    1692:	30 83       	st	Z, r19
    1694:	31 97       	sbiw	r30, 0x01	; 1
    1696:	30 e2       	ldi	r19, 0x20	; 32
    1698:	30 83       	st	Z, r19
    169a:	31 97       	sbiw	r30, 0x01	; 1
    169c:	31 e2       	ldi	r19, 0x21	; 33
    169e:	30 83       	st	Z, r19
    16a0:	31 97       	sbiw	r30, 0x01	; 1
    16a2:	20 83       	st	Z, r18
    16a4:	31 97       	sbiw	r30, 0x01	; 1
    16a6:	23 e2       	ldi	r18, 0x23	; 35
    16a8:	20 83       	st	Z, r18
    16aa:	31 97       	sbiw	r30, 0x01	; 1
    16ac:	40 83       	st	Z, r20
    16ae:	31 97       	sbiw	r30, 0x01	; 1
    16b0:	50 83       	st	Z, r21
    16b2:	31 97       	sbiw	r30, 0x01	; 1
    16b4:	26 e2       	ldi	r18, 0x26	; 38
    16b6:	20 83       	st	Z, r18
    16b8:	31 97       	sbiw	r30, 0x01	; 1
    16ba:	27 e2       	ldi	r18, 0x27	; 39
    16bc:	20 83       	st	Z, r18
    16be:	31 97       	sbiw	r30, 0x01	; 1
    16c0:	28 e2       	ldi	r18, 0x28	; 40
    16c2:	20 83       	st	Z, r18
    16c4:	31 97       	sbiw	r30, 0x01	; 1
    16c6:	29 e2       	ldi	r18, 0x29	; 41
    16c8:	20 83       	st	Z, r18
    16ca:	31 97       	sbiw	r30, 0x01	; 1
    16cc:	20 e3       	ldi	r18, 0x30	; 48
    16ce:	20 83       	st	Z, r18
    16d0:	31 97       	sbiw	r30, 0x01	; 1
    16d2:	21 e3       	ldi	r18, 0x31	; 49
    16d4:	20 83       	st	Z, r18
    16d6:	89 97       	sbiw	r24, 0x29	; 41
    16d8:	08 95       	ret

000016da <xPortStartScheduler>:
    16da:	8c e7       	ldi	r24, 0x7C	; 124
    16dc:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
    16e0:	8f ef       	ldi	r24, 0xFF	; 255
    16e2:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
    16e6:	81 e0       	ldi	r24, 0x01	; 1
    16e8:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
    16ec:	90 e1       	ldi	r25, 0x10	; 16
    16ee:	90 93 41 0a 	sts	0x0A41, r25	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
    16f2:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
    16f6:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    16fa:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    16fe:	cd 91       	ld	r28, X+
    1700:	cd bf       	out	0x3d, r28	; 61
    1702:	dd 91       	ld	r29, X+
    1704:	de bf       	out	0x3e, r29	; 62
    1706:	ff 91       	pop	r31
    1708:	ef 91       	pop	r30
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	bf 91       	pop	r27
    1710:	af 91       	pop	r26
    1712:	9f 91       	pop	r25
    1714:	8f 91       	pop	r24
    1716:	7f 91       	pop	r23
    1718:	6f 91       	pop	r22
    171a:	5f 91       	pop	r21
    171c:	4f 91       	pop	r20
    171e:	3f 91       	pop	r19
    1720:	2f 91       	pop	r18
    1722:	1f 91       	pop	r17
    1724:	0f 91       	pop	r16
    1726:	ff 90       	pop	r15
    1728:	ef 90       	pop	r14
    172a:	df 90       	pop	r13
    172c:	cf 90       	pop	r12
    172e:	bf 90       	pop	r11
    1730:	af 90       	pop	r10
    1732:	9f 90       	pop	r9
    1734:	8f 90       	pop	r8
    1736:	7f 90       	pop	r7
    1738:	6f 90       	pop	r6
    173a:	5f 90       	pop	r5
    173c:	4f 90       	pop	r4
    173e:	3f 90       	pop	r3
    1740:	2f 90       	pop	r2
    1742:	1f 90       	pop	r1
    1744:	0f 90       	pop	r0
    1746:	0c be       	out	0x3c, r0	; 60
    1748:	0f 90       	pop	r0
    174a:	0b be       	out	0x3b, r0	; 59
    174c:	0f 90       	pop	r0
    174e:	0f be       	out	0x3f, r0	; 63
    1750:	0f 90       	pop	r0
    1752:	08 95       	ret
    1754:	08 95       	ret

00001756 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1756:	0f 92       	push	r0
    1758:	0f b6       	in	r0, 0x3f	; 63
    175a:	f8 94       	cli
    175c:	0f 92       	push	r0
    175e:	0b b6       	in	r0, 0x3b	; 59
    1760:	0f 92       	push	r0
    1762:	0c b6       	in	r0, 0x3c	; 60
    1764:	0f 92       	push	r0
    1766:	1f 92       	push	r1
    1768:	11 24       	eor	r1, r1
    176a:	2f 92       	push	r2
    176c:	3f 92       	push	r3
    176e:	4f 92       	push	r4
    1770:	5f 92       	push	r5
    1772:	6f 92       	push	r6
    1774:	7f 92       	push	r7
    1776:	8f 92       	push	r8
    1778:	9f 92       	push	r9
    177a:	af 92       	push	r10
    177c:	bf 92       	push	r11
    177e:	cf 92       	push	r12
    1780:	df 92       	push	r13
    1782:	ef 92       	push	r14
    1784:	ff 92       	push	r15
    1786:	0f 93       	push	r16
    1788:	1f 93       	push	r17
    178a:	2f 93       	push	r18
    178c:	3f 93       	push	r19
    178e:	4f 93       	push	r20
    1790:	5f 93       	push	r21
    1792:	6f 93       	push	r22
    1794:	7f 93       	push	r23
    1796:	8f 93       	push	r24
    1798:	9f 93       	push	r25
    179a:	af 93       	push	r26
    179c:	bf 93       	push	r27
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	ef 93       	push	r30
    17a4:	ff 93       	push	r31
    17a6:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    17aa:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    17ae:	0d b6       	in	r0, 0x3d	; 61
    17b0:	0d 92       	st	X+, r0
    17b2:	0e b6       	in	r0, 0x3e	; 62
    17b4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    17b6:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17ba:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    17be:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    17c2:	cd 91       	ld	r28, X+
    17c4:	cd bf       	out	0x3d, r28	; 61
    17c6:	dd 91       	ld	r29, X+
    17c8:	de bf       	out	0x3e, r29	; 62
    17ca:	ff 91       	pop	r31
    17cc:	ef 91       	pop	r30
    17ce:	df 91       	pop	r29
    17d0:	cf 91       	pop	r28
    17d2:	bf 91       	pop	r27
    17d4:	af 91       	pop	r26
    17d6:	9f 91       	pop	r25
    17d8:	8f 91       	pop	r24
    17da:	7f 91       	pop	r23
    17dc:	6f 91       	pop	r22
    17de:	5f 91       	pop	r21
    17e0:	4f 91       	pop	r20
    17e2:	3f 91       	pop	r19
    17e4:	2f 91       	pop	r18
    17e6:	1f 91       	pop	r17
    17e8:	0f 91       	pop	r16
    17ea:	ff 90       	pop	r15
    17ec:	ef 90       	pop	r14
    17ee:	df 90       	pop	r13
    17f0:	cf 90       	pop	r12
    17f2:	bf 90       	pop	r11
    17f4:	af 90       	pop	r10
    17f6:	9f 90       	pop	r9
    17f8:	8f 90       	pop	r8
    17fa:	7f 90       	pop	r7
    17fc:	6f 90       	pop	r6
    17fe:	5f 90       	pop	r5
    1800:	4f 90       	pop	r4
    1802:	3f 90       	pop	r3
    1804:	2f 90       	pop	r2
    1806:	1f 90       	pop	r1
    1808:	0f 90       	pop	r0
    180a:	0c be       	out	0x3c, r0	; 60
    180c:	0f 90       	pop	r0
    180e:	0b be       	out	0x3b, r0	; 59
    1810:	0f 90       	pop	r0
    1812:	0f be       	out	0x3f, r0	; 63
    1814:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1816:	08 95       	ret

00001818 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1818:	0f 92       	push	r0
    181a:	0f b6       	in	r0, 0x3f	; 63
    181c:	f8 94       	cli
    181e:	0f 92       	push	r0
    1820:	0b b6       	in	r0, 0x3b	; 59
    1822:	0f 92       	push	r0
    1824:	0c b6       	in	r0, 0x3c	; 60
    1826:	0f 92       	push	r0
    1828:	1f 92       	push	r1
    182a:	11 24       	eor	r1, r1
    182c:	2f 92       	push	r2
    182e:	3f 92       	push	r3
    1830:	4f 92       	push	r4
    1832:	5f 92       	push	r5
    1834:	6f 92       	push	r6
    1836:	7f 92       	push	r7
    1838:	8f 92       	push	r8
    183a:	9f 92       	push	r9
    183c:	af 92       	push	r10
    183e:	bf 92       	push	r11
    1840:	cf 92       	push	r12
    1842:	df 92       	push	r13
    1844:	ef 92       	push	r14
    1846:	ff 92       	push	r15
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	2f 93       	push	r18
    184e:	3f 93       	push	r19
    1850:	4f 93       	push	r20
    1852:	5f 93       	push	r21
    1854:	6f 93       	push	r22
    1856:	7f 93       	push	r23
    1858:	8f 93       	push	r24
    185a:	9f 93       	push	r25
    185c:	af 93       	push	r26
    185e:	bf 93       	push	r27
    1860:	cf 93       	push	r28
    1862:	df 93       	push	r29
    1864:	ef 93       	push	r30
    1866:	ff 93       	push	r31
    1868:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    186c:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1870:	0d b6       	in	r0, 0x3d	; 61
    1872:	0d 92       	st	X+, r0
    1874:	0e b6       	in	r0, 0x3e	; 62
    1876:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1878:	0e 94 b5 10 	call	0x216a	; 0x216a <vTaskIncrementTick>
	vTaskSwitchContext();
    187c:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1880:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    1884:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1888:	cd 91       	ld	r28, X+
    188a:	cd bf       	out	0x3d, r28	; 61
    188c:	dd 91       	ld	r29, X+
    188e:	de bf       	out	0x3e, r29	; 62
    1890:	ff 91       	pop	r31
    1892:	ef 91       	pop	r30
    1894:	df 91       	pop	r29
    1896:	cf 91       	pop	r28
    1898:	bf 91       	pop	r27
    189a:	af 91       	pop	r26
    189c:	9f 91       	pop	r25
    189e:	8f 91       	pop	r24
    18a0:	7f 91       	pop	r23
    18a2:	6f 91       	pop	r22
    18a4:	5f 91       	pop	r21
    18a6:	4f 91       	pop	r20
    18a8:	3f 91       	pop	r19
    18aa:	2f 91       	pop	r18
    18ac:	1f 91       	pop	r17
    18ae:	0f 91       	pop	r16
    18b0:	ff 90       	pop	r15
    18b2:	ef 90       	pop	r14
    18b4:	df 90       	pop	r13
    18b6:	cf 90       	pop	r12
    18b8:	bf 90       	pop	r11
    18ba:	af 90       	pop	r10
    18bc:	9f 90       	pop	r9
    18be:	8f 90       	pop	r8
    18c0:	7f 90       	pop	r7
    18c2:	6f 90       	pop	r6
    18c4:	5f 90       	pop	r5
    18c6:	4f 90       	pop	r4
    18c8:	3f 90       	pop	r3
    18ca:	2f 90       	pop	r2
    18cc:	1f 90       	pop	r1
    18ce:	0f 90       	pop	r0
    18d0:	0c be       	out	0x3c, r0	; 60
    18d2:	0f 90       	pop	r0
    18d4:	0b be       	out	0x3b, r0	; 59
    18d6:	0f 90       	pop	r0
    18d8:	0f be       	out	0x3f, r0	; 63
    18da:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18dc:	08 95       	ret

000018de <__vector_55>:
void RT_VECT (void)
{
	#if (RT_VECT == TCD0_CCA_vect)
		static uint16_t compare_interval = (uint16_t)(configCPU_CLOCK_HZ / (configTICK_RATE_HZ 
						 * portCLOCK_PRESCALER)) - 1;
		TCD0.CCA += compare_interval;
    18de:	e0 e0       	ldi	r30, 0x00	; 0
    18e0:	f9 e0       	ldi	r31, 0x09	; 9
    18e2:	80 a5       	ldd	r24, Z+40	; 0x28
    18e4:	91 a5       	ldd	r25, Z+41	; 0x29
    18e6:	81 50       	subi	r24, 0x01	; 1
    18e8:	93 48       	sbci	r25, 0x83	; 131
    18ea:	80 a7       	std	Z+40, r24	; 0x28
    18ec:	91 a7       	std	Z+41, r25	; 0x29
	#endif
	
	
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    18ee:	0e 94 0c 0c 	call	0x1818	; 0x1818 <vPortYieldFromTick>
		asm volatile ( "reti" );
    18f2:	18 95       	reti

000018f4 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	ec 01       	movw	r28, r24
    18fa:	88 a1       	ldd	r24, Y+32	; 0x20
    18fc:	81 11       	cpse	r24, r1
    18fe:	0b c0       	rjmp	.+22     	; 0x1916 <prvCopyDataToQueue+0x22>
    1900:	88 81       	ld	r24, Y
    1902:	99 81       	ldd	r25, Y+1	; 0x01
    1904:	89 2b       	or	r24, r25
    1906:	e1 f5       	brne	.+120    	; 0x1980 <prvCopyDataToQueue+0x8c>
    1908:	8a 81       	ldd	r24, Y+2	; 0x02
    190a:	9b 81       	ldd	r25, Y+3	; 0x03
    190c:	0e 94 8e 14 	call	0x291c	; 0x291c <vTaskPriorityDisinherit>
    1910:	1a 82       	std	Y+2, r1	; 0x02
    1912:	1b 82       	std	Y+3, r1	; 0x03
    1914:	35 c0       	rjmp	.+106    	; 0x1980 <prvCopyDataToQueue+0x8c>
    1916:	41 11       	cpse	r20, r1
    1918:	17 c0       	rjmp	.+46     	; 0x1948 <prvCopyDataToQueue+0x54>
    191a:	48 2f       	mov	r20, r24
    191c:	50 e0       	ldi	r21, 0x00	; 0
    191e:	8c 81       	ldd	r24, Y+4	; 0x04
    1920:	9d 81       	ldd	r25, Y+5	; 0x05
    1922:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <memcpy>
    1926:	28 a1       	ldd	r18, Y+32	; 0x20
    1928:	8c 81       	ldd	r24, Y+4	; 0x04
    192a:	9d 81       	ldd	r25, Y+5	; 0x05
    192c:	82 0f       	add	r24, r18
    192e:	91 1d       	adc	r25, r1
    1930:	8c 83       	std	Y+4, r24	; 0x04
    1932:	9d 83       	std	Y+5, r25	; 0x05
    1934:	2a 81       	ldd	r18, Y+2	; 0x02
    1936:	3b 81       	ldd	r19, Y+3	; 0x03
    1938:	82 17       	cp	r24, r18
    193a:	93 07       	cpc	r25, r19
    193c:	08 f1       	brcs	.+66     	; 0x1980 <prvCopyDataToQueue+0x8c>
    193e:	88 81       	ld	r24, Y
    1940:	99 81       	ldd	r25, Y+1	; 0x01
    1942:	8c 83       	std	Y+4, r24	; 0x04
    1944:	9d 83       	std	Y+5, r25	; 0x05
    1946:	1c c0       	rjmp	.+56     	; 0x1980 <prvCopyDataToQueue+0x8c>
    1948:	48 2f       	mov	r20, r24
    194a:	50 e0       	ldi	r21, 0x00	; 0
    194c:	8e 81       	ldd	r24, Y+6	; 0x06
    194e:	9f 81       	ldd	r25, Y+7	; 0x07
    1950:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <memcpy>
    1954:	88 a1       	ldd	r24, Y+32	; 0x20
    1956:	90 e0       	ldi	r25, 0x00	; 0
    1958:	91 95       	neg	r25
    195a:	81 95       	neg	r24
    195c:	91 09       	sbc	r25, r1
    195e:	2e 81       	ldd	r18, Y+6	; 0x06
    1960:	3f 81       	ldd	r19, Y+7	; 0x07
    1962:	28 0f       	add	r18, r24
    1964:	39 1f       	adc	r19, r25
    1966:	2e 83       	std	Y+6, r18	; 0x06
    1968:	3f 83       	std	Y+7, r19	; 0x07
    196a:	48 81       	ld	r20, Y
    196c:	59 81       	ldd	r21, Y+1	; 0x01
    196e:	24 17       	cp	r18, r20
    1970:	35 07       	cpc	r19, r21
    1972:	30 f4       	brcc	.+12     	; 0x1980 <prvCopyDataToQueue+0x8c>
    1974:	2a 81       	ldd	r18, Y+2	; 0x02
    1976:	3b 81       	ldd	r19, Y+3	; 0x03
    1978:	82 0f       	add	r24, r18
    197a:	93 1f       	adc	r25, r19
    197c:	8e 83       	std	Y+6, r24	; 0x06
    197e:	9f 83       	std	Y+7, r25	; 0x07
    1980:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1982:	8f 5f       	subi	r24, 0xFF	; 255
    1984:	8e 8f       	std	Y+30, r24	; 0x1e
    1986:	df 91       	pop	r29
    1988:	cf 91       	pop	r28
    198a:	08 95       	ret

0000198c <prvCopyDataFromQueue>:
    198c:	fc 01       	movw	r30, r24
    198e:	80 81       	ld	r24, Z
    1990:	91 81       	ldd	r25, Z+1	; 0x01
    1992:	00 97       	sbiw	r24, 0x00	; 0
    1994:	a1 f0       	breq	.+40     	; 0x19be <prvCopyDataFromQueue+0x32>
    1996:	40 a1       	ldd	r20, Z+32	; 0x20
    1998:	50 e0       	ldi	r21, 0x00	; 0
    199a:	26 81       	ldd	r18, Z+6	; 0x06
    199c:	37 81       	ldd	r19, Z+7	; 0x07
    199e:	24 0f       	add	r18, r20
    19a0:	35 1f       	adc	r19, r21
    19a2:	26 83       	std	Z+6, r18	; 0x06
    19a4:	37 83       	std	Z+7, r19	; 0x07
    19a6:	a2 81       	ldd	r26, Z+2	; 0x02
    19a8:	b3 81       	ldd	r27, Z+3	; 0x03
    19aa:	2a 17       	cp	r18, r26
    19ac:	3b 07       	cpc	r19, r27
    19ae:	10 f0       	brcs	.+4      	; 0x19b4 <prvCopyDataFromQueue+0x28>
    19b0:	86 83       	std	Z+6, r24	; 0x06
    19b2:	97 83       	std	Z+7, r25	; 0x07
    19b4:	cb 01       	movw	r24, r22
    19b6:	66 81       	ldd	r22, Z+6	; 0x06
    19b8:	77 81       	ldd	r23, Z+7	; 0x07
    19ba:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <memcpy>
    19be:	08 95       	ret

000019c0 <prvUnlockQueue>:
    19c0:	0f 93       	push	r16
    19c2:	1f 93       	push	r17
    19c4:	cf 93       	push	r28
    19c6:	df 93       	push	r29
    19c8:	ec 01       	movw	r28, r24
    19ca:	0f b6       	in	r0, 0x3f	; 63
    19cc:	f8 94       	cli
    19ce:	0f 92       	push	r0
    19d0:	8a a1       	ldd	r24, Y+34	; 0x22
    19d2:	18 16       	cp	r1, r24
    19d4:	b4 f4       	brge	.+44     	; 0x1a02 <prvUnlockQueue+0x42>
    19d6:	8b 89       	ldd	r24, Y+19	; 0x13
    19d8:	81 11       	cpse	r24, r1
    19da:	05 c0       	rjmp	.+10     	; 0x19e6 <prvUnlockQueue+0x26>
    19dc:	12 c0       	rjmp	.+36     	; 0x1a02 <prvUnlockQueue+0x42>
    19de:	8b 89       	ldd	r24, Y+19	; 0x13
    19e0:	81 11       	cpse	r24, r1
    19e2:	04 c0       	rjmp	.+8      	; 0x19ec <prvUnlockQueue+0x2c>
    19e4:	0e c0       	rjmp	.+28     	; 0x1a02 <prvUnlockQueue+0x42>
    19e6:	8e 01       	movw	r16, r28
    19e8:	0d 5e       	subi	r16, 0xED	; 237
    19ea:	1f 4f       	sbci	r17, 0xFF	; 255
    19ec:	c8 01       	movw	r24, r16
    19ee:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <xTaskRemoveFromEventList>
    19f2:	81 11       	cpse	r24, r1
    19f4:	0e 94 17 14 	call	0x282e	; 0x282e <vTaskMissedYield>
    19f8:	8a a1       	ldd	r24, Y+34	; 0x22
    19fa:	81 50       	subi	r24, 0x01	; 1
    19fc:	8a a3       	std	Y+34, r24	; 0x22
    19fe:	18 16       	cp	r1, r24
    1a00:	74 f3       	brlt	.-36     	; 0x19de <prvUnlockQueue+0x1e>
    1a02:	8f ef       	ldi	r24, 0xFF	; 255
    1a04:	8a a3       	std	Y+34, r24	; 0x22
    1a06:	0f 90       	pop	r0
    1a08:	0f be       	out	0x3f, r0	; 63
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	0f 92       	push	r0
    1a10:	89 a1       	ldd	r24, Y+33	; 0x21
    1a12:	18 16       	cp	r1, r24
    1a14:	b4 f4       	brge	.+44     	; 0x1a42 <prvUnlockQueue+0x82>
    1a16:	88 85       	ldd	r24, Y+8	; 0x08
    1a18:	81 11       	cpse	r24, r1
    1a1a:	05 c0       	rjmp	.+10     	; 0x1a26 <prvUnlockQueue+0x66>
    1a1c:	12 c0       	rjmp	.+36     	; 0x1a42 <prvUnlockQueue+0x82>
    1a1e:	88 85       	ldd	r24, Y+8	; 0x08
    1a20:	81 11       	cpse	r24, r1
    1a22:	04 c0       	rjmp	.+8      	; 0x1a2c <prvUnlockQueue+0x6c>
    1a24:	0e c0       	rjmp	.+28     	; 0x1a42 <prvUnlockQueue+0x82>
    1a26:	8e 01       	movw	r16, r28
    1a28:	08 5f       	subi	r16, 0xF8	; 248
    1a2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1a2c:	c8 01       	movw	r24, r16
    1a2e:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <xTaskRemoveFromEventList>
    1a32:	81 11       	cpse	r24, r1
    1a34:	0e 94 17 14 	call	0x282e	; 0x282e <vTaskMissedYield>
    1a38:	89 a1       	ldd	r24, Y+33	; 0x21
    1a3a:	81 50       	subi	r24, 0x01	; 1
    1a3c:	89 a3       	std	Y+33, r24	; 0x21
    1a3e:	18 16       	cp	r1, r24
    1a40:	74 f3       	brlt	.-36     	; 0x1a1e <prvUnlockQueue+0x5e>
    1a42:	8f ef       	ldi	r24, 0xFF	; 255
    1a44:	89 a3       	std	Y+33, r24	; 0x21
    1a46:	0f 90       	pop	r0
    1a48:	0f be       	out	0x3f, r0	; 63
    1a4a:	df 91       	pop	r29
    1a4c:	cf 91       	pop	r28
    1a4e:	1f 91       	pop	r17
    1a50:	0f 91       	pop	r16
    1a52:	08 95       	ret

00001a54 <xQueueGenericReset>:
    1a54:	1f 93       	push	r17
    1a56:	cf 93       	push	r28
    1a58:	df 93       	push	r29
    1a5a:	61 30       	cpi	r22, 0x01	; 1
    1a5c:	59 f0       	breq	.+22     	; 0x1a74 <xQueueGenericReset+0x20>
    1a5e:	fc 01       	movw	r30, r24
    1a60:	23 89       	ldd	r18, Z+19	; 0x13
    1a62:	30 85       	ldd	r19, Z+8	; 0x08
    1a64:	31 11       	cpse	r19, r1
    1a66:	2c c0       	rjmp	.+88     	; 0x1ac0 <xQueueGenericReset+0x6c>
    1a68:	11 e0       	ldi	r17, 0x01	; 1
    1a6a:	21 11       	cpse	r18, r1
    1a6c:	10 e0       	ldi	r17, 0x00	; 0
    1a6e:	21 11       	cpse	r18, r1
    1a70:	28 c0       	rjmp	.+80     	; 0x1ac2 <xQueueGenericReset+0x6e>
    1a72:	01 c0       	rjmp	.+2      	; 0x1a76 <xQueueGenericReset+0x22>
    1a74:	11 e0       	ldi	r17, 0x01	; 1
    1a76:	ec 01       	movw	r28, r24
    1a78:	48 81       	ld	r20, Y
    1a7a:	59 81       	ldd	r21, Y+1	; 0x01
    1a7c:	28 a1       	ldd	r18, Y+32	; 0x20
    1a7e:	30 e0       	ldi	r19, 0x00	; 0
    1a80:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a82:	62 9f       	mul	r22, r18
    1a84:	c0 01       	movw	r24, r0
    1a86:	63 9f       	mul	r22, r19
    1a88:	90 0d       	add	r25, r0
    1a8a:	11 24       	eor	r1, r1
    1a8c:	ba 01       	movw	r22, r20
    1a8e:	68 0f       	add	r22, r24
    1a90:	79 1f       	adc	r23, r25
    1a92:	6a 83       	std	Y+2, r22	; 0x02
    1a94:	7b 83       	std	Y+3, r23	; 0x03
    1a96:	1e 8e       	std	Y+30, r1	; 0x1e
    1a98:	4c 83       	std	Y+4, r20	; 0x04
    1a9a:	5d 83       	std	Y+5, r21	; 0x05
    1a9c:	82 1b       	sub	r24, r18
    1a9e:	93 0b       	sbc	r25, r19
    1aa0:	84 0f       	add	r24, r20
    1aa2:	95 1f       	adc	r25, r21
    1aa4:	8e 83       	std	Y+6, r24	; 0x06
    1aa6:	9f 83       	std	Y+7, r25	; 0x07
    1aa8:	8f ef       	ldi	r24, 0xFF	; 255
    1aaa:	89 a3       	std	Y+33, r24	; 0x21
    1aac:	8a a3       	std	Y+34, r24	; 0x22
    1aae:	ce 01       	movw	r24, r28
    1ab0:	08 96       	adiw	r24, 0x08	; 8
    1ab2:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1ab6:	ce 01       	movw	r24, r28
    1ab8:	43 96       	adiw	r24, 0x13	; 19
    1aba:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1abe:	01 c0       	rjmp	.+2      	; 0x1ac2 <xQueueGenericReset+0x6e>
    1ac0:	10 e0       	ldi	r17, 0x00	; 0
    1ac2:	81 2f       	mov	r24, r17
    1ac4:	df 91       	pop	r29
    1ac6:	cf 91       	pop	r28
    1ac8:	1f 91       	pop	r17
    1aca:	08 95       	ret

00001acc <xQueueGenericCreate>:
    1acc:	0f 93       	push	r16
    1ace:	1f 93       	push	r17
    1ad0:	cf 93       	push	r28
    1ad2:	df 93       	push	r29
    1ad4:	88 23       	and	r24, r24
    1ad6:	01 f1       	breq	.+64     	; 0x1b18 <xQueueGenericCreate+0x4c>
    1ad8:	06 2f       	mov	r16, r22
    1ada:	18 2f       	mov	r17, r24
    1adc:	83 e2       	ldi	r24, 0x23	; 35
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	0e 94 78 09 	call	0x12f0	; 0x12f0 <pvPortMalloc>
    1ae4:	ec 01       	movw	r28, r24
    1ae6:	89 2b       	or	r24, r25
    1ae8:	c9 f0       	breq	.+50     	; 0x1b1c <xQueueGenericCreate+0x50>
    1aea:	10 9f       	mul	r17, r16
    1aec:	c0 01       	movw	r24, r0
    1aee:	11 24       	eor	r1, r1
    1af0:	01 96       	adiw	r24, 0x01	; 1
    1af2:	0e 94 78 09 	call	0x12f0	; 0x12f0 <pvPortMalloc>
    1af6:	88 83       	st	Y, r24
    1af8:	99 83       	std	Y+1, r25	; 0x01
    1afa:	89 2b       	or	r24, r25
    1afc:	39 f0       	breq	.+14     	; 0x1b0c <xQueueGenericCreate+0x40>
    1afe:	1f 8f       	std	Y+31, r17	; 0x1f
    1b00:	08 a3       	std	Y+32, r16	; 0x20
    1b02:	61 e0       	ldi	r22, 0x01	; 1
    1b04:	ce 01       	movw	r24, r28
    1b06:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <xQueueGenericReset>
    1b0a:	08 c0       	rjmp	.+16     	; 0x1b1c <xQueueGenericCreate+0x50>
    1b0c:	ce 01       	movw	r24, r28
    1b0e:	0e 94 12 0a 	call	0x1424	; 0x1424 <vPortFree>
    1b12:	c0 e0       	ldi	r28, 0x00	; 0
    1b14:	d0 e0       	ldi	r29, 0x00	; 0
    1b16:	02 c0       	rjmp	.+4      	; 0x1b1c <xQueueGenericCreate+0x50>
    1b18:	c0 e0       	ldi	r28, 0x00	; 0
    1b1a:	d0 e0       	ldi	r29, 0x00	; 0
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	df 91       	pop	r29
    1b20:	cf 91       	pop	r28
    1b22:	1f 91       	pop	r17
    1b24:	0f 91       	pop	r16
    1b26:	08 95       	ret

00001b28 <xQueueGenericSend>:
    1b28:	af 92       	push	r10
    1b2a:	bf 92       	push	r11
    1b2c:	cf 92       	push	r12
    1b2e:	df 92       	push	r13
    1b30:	ef 92       	push	r14
    1b32:	ff 92       	push	r15
    1b34:	0f 93       	push	r16
    1b36:	1f 93       	push	r17
    1b38:	cf 93       	push	r28
    1b3a:	df 93       	push	r29
    1b3c:	cd b7       	in	r28, 0x3d	; 61
    1b3e:	de b7       	in	r29, 0x3e	; 62
    1b40:	29 97       	sbiw	r28, 0x09	; 9
    1b42:	cd bf       	out	0x3d, r28	; 61
    1b44:	de bf       	out	0x3e, r29	; 62
    1b46:	7c 01       	movw	r14, r24
    1b48:	5b 01       	movw	r10, r22
    1b4a:	2e 83       	std	Y+6, r18	; 0x06
    1b4c:	3f 83       	std	Y+7, r19	; 0x07
    1b4e:	48 87       	std	Y+8, r20	; 0x08
    1b50:	59 87       	std	Y+9, r21	; 0x09
    1b52:	10 e0       	ldi	r17, 0x00	; 0
    1b54:	6c 01       	movw	r12, r24
    1b56:	88 e0       	ldi	r24, 0x08	; 8
    1b58:	c8 0e       	add	r12, r24
    1b5a:	d1 1c       	adc	r13, r1
    1b5c:	0f b6       	in	r0, 0x3f	; 63
    1b5e:	f8 94       	cli
    1b60:	0f 92       	push	r0
    1b62:	f7 01       	movw	r30, r14
    1b64:	96 8d       	ldd	r25, Z+30	; 0x1e
    1b66:	87 8d       	ldd	r24, Z+31	; 0x1f
    1b68:	98 17       	cp	r25, r24
    1b6a:	a8 f4       	brcc	.+42     	; 0x1b96 <xQueueGenericSend+0x6e>
    1b6c:	40 2f       	mov	r20, r16
    1b6e:	b5 01       	movw	r22, r10
    1b70:	c7 01       	movw	r24, r14
    1b72:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <prvCopyDataToQueue>
    1b76:	f7 01       	movw	r30, r14
    1b78:	83 89       	ldd	r24, Z+19	; 0x13
    1b7a:	88 23       	and	r24, r24
    1b7c:	41 f0       	breq	.+16     	; 0x1b8e <xQueueGenericSend+0x66>
    1b7e:	c7 01       	movw	r24, r14
    1b80:	43 96       	adiw	r24, 0x13	; 19
    1b82:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <xTaskRemoveFromEventList>
    1b86:	81 30       	cpi	r24, 0x01	; 1
    1b88:	11 f4       	brne	.+4      	; 0x1b8e <xQueueGenericSend+0x66>
    1b8a:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
    1b8e:	0f 90       	pop	r0
    1b90:	0f be       	out	0x3f, r0	; 63
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	56 c0       	rjmp	.+172    	; 0x1c42 <xQueueGenericSend+0x11a>
    1b96:	8e 81       	ldd	r24, Y+6	; 0x06
    1b98:	9f 81       	ldd	r25, Y+7	; 0x07
    1b9a:	a8 85       	ldd	r26, Y+8	; 0x08
    1b9c:	b9 85       	ldd	r27, Y+9	; 0x09
    1b9e:	89 2b       	or	r24, r25
    1ba0:	8a 2b       	or	r24, r26
    1ba2:	8b 2b       	or	r24, r27
    1ba4:	21 f4       	brne	.+8      	; 0x1bae <xQueueGenericSend+0x86>
    1ba6:	0f 90       	pop	r0
    1ba8:	0f be       	out	0x3f, r0	; 63
    1baa:	80 e0       	ldi	r24, 0x00	; 0
    1bac:	4a c0       	rjmp	.+148    	; 0x1c42 <xQueueGenericSend+0x11a>
    1bae:	11 11       	cpse	r17, r1
    1bb0:	05 c0       	rjmp	.+10     	; 0x1bbc <xQueueGenericSend+0x94>
    1bb2:	ce 01       	movw	r24, r28
    1bb4:	01 96       	adiw	r24, 0x01	; 1
    1bb6:	0e 94 99 13 	call	0x2732	; 0x2732 <vTaskSetTimeOutState>
    1bba:	11 e0       	ldi	r17, 0x01	; 1
    1bbc:	0f 90       	pop	r0
    1bbe:	0f be       	out	0x3f, r0	; 63
    1bc0:	0e 94 94 10 	call	0x2128	; 0x2128 <vTaskSuspendAll>
    1bc4:	0f b6       	in	r0, 0x3f	; 63
    1bc6:	f8 94       	cli
    1bc8:	0f 92       	push	r0
    1bca:	f7 01       	movw	r30, r14
    1bcc:	81 a1       	ldd	r24, Z+33	; 0x21
    1bce:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd0:	09 f4       	brne	.+2      	; 0x1bd4 <xQueueGenericSend+0xac>
    1bd2:	11 a2       	std	Z+33, r1	; 0x21
    1bd4:	f7 01       	movw	r30, r14
    1bd6:	82 a1       	ldd	r24, Z+34	; 0x22
    1bd8:	8f 3f       	cpi	r24, 0xFF	; 255
    1bda:	09 f4       	brne	.+2      	; 0x1bde <xQueueGenericSend+0xb6>
    1bdc:	12 a2       	std	Z+34, r1	; 0x22
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63
    1be2:	be 01       	movw	r22, r28
    1be4:	6a 5f       	subi	r22, 0xFA	; 250
    1be6:	7f 4f       	sbci	r23, 0xFF	; 255
    1be8:	ce 01       	movw	r24, r28
    1bea:	01 96       	adiw	r24, 0x01	; 1
    1bec:	0e 94 aa 13 	call	0x2754	; 0x2754 <xTaskCheckForTimeOut>
    1bf0:	81 11       	cpse	r24, r1
    1bf2:	21 c0       	rjmp	.+66     	; 0x1c36 <xQueueGenericSend+0x10e>
    1bf4:	0f b6       	in	r0, 0x3f	; 63
    1bf6:	f8 94       	cli
    1bf8:	0f 92       	push	r0
    1bfa:	f7 01       	movw	r30, r14
    1bfc:	96 8d       	ldd	r25, Z+30	; 0x1e
    1bfe:	0f 90       	pop	r0
    1c00:	0f be       	out	0x3f, r0	; 63
    1c02:	87 8d       	ldd	r24, Z+31	; 0x1f
    1c04:	98 13       	cpse	r25, r24
    1c06:	11 c0       	rjmp	.+34     	; 0x1c2a <xQueueGenericSend+0x102>
    1c08:	4e 81       	ldd	r20, Y+6	; 0x06
    1c0a:	5f 81       	ldd	r21, Y+7	; 0x07
    1c0c:	68 85       	ldd	r22, Y+8	; 0x08
    1c0e:	79 85       	ldd	r23, Y+9	; 0x09
    1c10:	c6 01       	movw	r24, r12
    1c12:	0e 94 30 13 	call	0x2660	; 0x2660 <vTaskPlaceOnEventList>
    1c16:	c7 01       	movw	r24, r14
    1c18:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <prvUnlockQueue>
    1c1c:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
    1c20:	81 11       	cpse	r24, r1
    1c22:	9c cf       	rjmp	.-200    	; 0x1b5c <xQueueGenericSend+0x34>
    1c24:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
    1c28:	99 cf       	rjmp	.-206    	; 0x1b5c <xQueueGenericSend+0x34>
    1c2a:	c7 01       	movw	r24, r14
    1c2c:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <prvUnlockQueue>
    1c30:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
    1c34:	93 cf       	rjmp	.-218    	; 0x1b5c <xQueueGenericSend+0x34>
    1c36:	c7 01       	movw	r24, r14
    1c38:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <prvUnlockQueue>
    1c3c:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
    1c40:	80 e0       	ldi	r24, 0x00	; 0
    1c42:	29 96       	adiw	r28, 0x09	; 9
    1c44:	cd bf       	out	0x3d, r28	; 61
    1c46:	de bf       	out	0x3e, r29	; 62
    1c48:	df 91       	pop	r29
    1c4a:	cf 91       	pop	r28
    1c4c:	1f 91       	pop	r17
    1c4e:	0f 91       	pop	r16
    1c50:	ff 90       	pop	r15
    1c52:	ef 90       	pop	r14
    1c54:	df 90       	pop	r13
    1c56:	cf 90       	pop	r12
    1c58:	bf 90       	pop	r11
    1c5a:	af 90       	pop	r10
    1c5c:	08 95       	ret

00001c5e <xQueueGenericReceive>:
    1c5e:	af 92       	push	r10
    1c60:	bf 92       	push	r11
    1c62:	cf 92       	push	r12
    1c64:	df 92       	push	r13
    1c66:	ef 92       	push	r14
    1c68:	ff 92       	push	r15
    1c6a:	0f 93       	push	r16
    1c6c:	1f 93       	push	r17
    1c6e:	cf 93       	push	r28
    1c70:	df 93       	push	r29
    1c72:	cd b7       	in	r28, 0x3d	; 61
    1c74:	de b7       	in	r29, 0x3e	; 62
    1c76:	29 97       	sbiw	r28, 0x09	; 9
    1c78:	cd bf       	out	0x3d, r28	; 61
    1c7a:	de bf       	out	0x3e, r29	; 62
    1c7c:	7c 01       	movw	r14, r24
    1c7e:	5b 01       	movw	r10, r22
    1c80:	2e 83       	std	Y+6, r18	; 0x06
    1c82:	3f 83       	std	Y+7, r19	; 0x07
    1c84:	48 87       	std	Y+8, r20	; 0x08
    1c86:	59 87       	std	Y+9, r21	; 0x09
    1c88:	10 e0       	ldi	r17, 0x00	; 0
    1c8a:	6c 01       	movw	r12, r24
    1c8c:	83 e1       	ldi	r24, 0x13	; 19
    1c8e:	c8 0e       	add	r12, r24
    1c90:	d1 1c       	adc	r13, r1
    1c92:	0f b6       	in	r0, 0x3f	; 63
    1c94:	f8 94       	cli
    1c96:	0f 92       	push	r0
    1c98:	f7 01       	movw	r30, r14
    1c9a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c9c:	88 23       	and	r24, r24
    1c9e:	99 f1       	breq	.+102    	; 0x1d06 <xQueueGenericReceive+0xa8>
    1ca0:	c6 80       	ldd	r12, Z+6	; 0x06
    1ca2:	d7 80       	ldd	r13, Z+7	; 0x07
    1ca4:	b5 01       	movw	r22, r10
    1ca6:	c7 01       	movw	r24, r14
    1ca8:	0e 94 c6 0c 	call	0x198c	; 0x198c <prvCopyDataFromQueue>
    1cac:	01 11       	cpse	r16, r1
    1cae:	1a c0       	rjmp	.+52     	; 0x1ce4 <xQueueGenericReceive+0x86>
    1cb0:	f7 01       	movw	r30, r14
    1cb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cb4:	81 50       	subi	r24, 0x01	; 1
    1cb6:	86 8f       	std	Z+30, r24	; 0x1e
    1cb8:	80 81       	ld	r24, Z
    1cba:	91 81       	ldd	r25, Z+1	; 0x01
    1cbc:	89 2b       	or	r24, r25
    1cbe:	29 f4       	brne	.+10     	; 0x1cca <xQueueGenericReceive+0x6c>
    1cc0:	0e 94 34 14 	call	0x2868	; 0x2868 <xTaskGetCurrentTaskHandle>
    1cc4:	f7 01       	movw	r30, r14
    1cc6:	82 83       	std	Z+2, r24	; 0x02
    1cc8:	93 83       	std	Z+3, r25	; 0x03
    1cca:	f7 01       	movw	r30, r14
    1ccc:	80 85       	ldd	r24, Z+8	; 0x08
    1cce:	88 23       	and	r24, r24
    1cd0:	b1 f0       	breq	.+44     	; 0x1cfe <xQueueGenericReceive+0xa0>
    1cd2:	c7 01       	movw	r24, r14
    1cd4:	08 96       	adiw	r24, 0x08	; 8
    1cd6:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <xTaskRemoveFromEventList>
    1cda:	81 30       	cpi	r24, 0x01	; 1
    1cdc:	81 f4       	brne	.+32     	; 0x1cfe <xQueueGenericReceive+0xa0>
    1cde:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
    1ce2:	0d c0       	rjmp	.+26     	; 0x1cfe <xQueueGenericReceive+0xa0>
    1ce4:	f7 01       	movw	r30, r14
    1ce6:	c6 82       	std	Z+6, r12	; 0x06
    1ce8:	d7 82       	std	Z+7, r13	; 0x07
    1cea:	83 89       	ldd	r24, Z+19	; 0x13
    1cec:	88 23       	and	r24, r24
    1cee:	39 f0       	breq	.+14     	; 0x1cfe <xQueueGenericReceive+0xa0>
    1cf0:	c7 01       	movw	r24, r14
    1cf2:	43 96       	adiw	r24, 0x13	; 19
    1cf4:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <xTaskRemoveFromEventList>
    1cf8:	81 11       	cpse	r24, r1
    1cfa:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
    1cfe:	0f 90       	pop	r0
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	81 e0       	ldi	r24, 0x01	; 1
    1d04:	62 c0       	rjmp	.+196    	; 0x1dca <xQueueGenericReceive+0x16c>
    1d06:	8e 81       	ldd	r24, Y+6	; 0x06
    1d08:	9f 81       	ldd	r25, Y+7	; 0x07
    1d0a:	a8 85       	ldd	r26, Y+8	; 0x08
    1d0c:	b9 85       	ldd	r27, Y+9	; 0x09
    1d0e:	89 2b       	or	r24, r25
    1d10:	8a 2b       	or	r24, r26
    1d12:	8b 2b       	or	r24, r27
    1d14:	21 f4       	brne	.+8      	; 0x1d1e <xQueueGenericReceive+0xc0>
    1d16:	0f 90       	pop	r0
    1d18:	0f be       	out	0x3f, r0	; 63
    1d1a:	80 e0       	ldi	r24, 0x00	; 0
    1d1c:	56 c0       	rjmp	.+172    	; 0x1dca <xQueueGenericReceive+0x16c>
    1d1e:	11 11       	cpse	r17, r1
    1d20:	05 c0       	rjmp	.+10     	; 0x1d2c <xQueueGenericReceive+0xce>
    1d22:	ce 01       	movw	r24, r28
    1d24:	01 96       	adiw	r24, 0x01	; 1
    1d26:	0e 94 99 13 	call	0x2732	; 0x2732 <vTaskSetTimeOutState>
    1d2a:	11 e0       	ldi	r17, 0x01	; 1
    1d2c:	0f 90       	pop	r0
    1d2e:	0f be       	out	0x3f, r0	; 63
    1d30:	0e 94 94 10 	call	0x2128	; 0x2128 <vTaskSuspendAll>
    1d34:	0f b6       	in	r0, 0x3f	; 63
    1d36:	f8 94       	cli
    1d38:	0f 92       	push	r0
    1d3a:	f7 01       	movw	r30, r14
    1d3c:	81 a1       	ldd	r24, Z+33	; 0x21
    1d3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d40:	09 f4       	brne	.+2      	; 0x1d44 <xQueueGenericReceive+0xe6>
    1d42:	11 a2       	std	Z+33, r1	; 0x21
    1d44:	f7 01       	movw	r30, r14
    1d46:	82 a1       	ldd	r24, Z+34	; 0x22
    1d48:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4a:	09 f4       	brne	.+2      	; 0x1d4e <xQueueGenericReceive+0xf0>
    1d4c:	12 a2       	std	Z+34, r1	; 0x22
    1d4e:	0f 90       	pop	r0
    1d50:	0f be       	out	0x3f, r0	; 63
    1d52:	be 01       	movw	r22, r28
    1d54:	6a 5f       	subi	r22, 0xFA	; 250
    1d56:	7f 4f       	sbci	r23, 0xFF	; 255
    1d58:	ce 01       	movw	r24, r28
    1d5a:	01 96       	adiw	r24, 0x01	; 1
    1d5c:	0e 94 aa 13 	call	0x2754	; 0x2754 <xTaskCheckForTimeOut>
    1d60:	81 11       	cpse	r24, r1
    1d62:	2d c0       	rjmp	.+90     	; 0x1dbe <xQueueGenericReceive+0x160>
    1d64:	0f b6       	in	r0, 0x3f	; 63
    1d66:	f8 94       	cli
    1d68:	0f 92       	push	r0
    1d6a:	f7 01       	movw	r30, r14
    1d6c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d6e:	0f 90       	pop	r0
    1d70:	0f be       	out	0x3f, r0	; 63
    1d72:	81 11       	cpse	r24, r1
    1d74:	1e c0       	rjmp	.+60     	; 0x1db2 <xQueueGenericReceive+0x154>
    1d76:	80 81       	ld	r24, Z
    1d78:	91 81       	ldd	r25, Z+1	; 0x01
    1d7a:	89 2b       	or	r24, r25
    1d7c:	49 f4       	brne	.+18     	; 0x1d90 <xQueueGenericReceive+0x132>
    1d7e:	0f b6       	in	r0, 0x3f	; 63
    1d80:	f8 94       	cli
    1d82:	0f 92       	push	r0
    1d84:	82 81       	ldd	r24, Z+2	; 0x02
    1d86:	93 81       	ldd	r25, Z+3	; 0x03
    1d88:	0e 94 39 14 	call	0x2872	; 0x2872 <vTaskPriorityInherit>
    1d8c:	0f 90       	pop	r0
    1d8e:	0f be       	out	0x3f, r0	; 63
    1d90:	4e 81       	ldd	r20, Y+6	; 0x06
    1d92:	5f 81       	ldd	r21, Y+7	; 0x07
    1d94:	68 85       	ldd	r22, Y+8	; 0x08
    1d96:	79 85       	ldd	r23, Y+9	; 0x09
    1d98:	c6 01       	movw	r24, r12
    1d9a:	0e 94 30 13 	call	0x2660	; 0x2660 <vTaskPlaceOnEventList>
    1d9e:	c7 01       	movw	r24, r14
    1da0:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <prvUnlockQueue>
    1da4:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
    1da8:	81 11       	cpse	r24, r1
    1daa:	73 cf       	rjmp	.-282    	; 0x1c92 <xQueueGenericReceive+0x34>
    1dac:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
    1db0:	70 cf       	rjmp	.-288    	; 0x1c92 <xQueueGenericReceive+0x34>
    1db2:	c7 01       	movw	r24, r14
    1db4:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <prvUnlockQueue>
    1db8:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
    1dbc:	6a cf       	rjmp	.-300    	; 0x1c92 <xQueueGenericReceive+0x34>
    1dbe:	c7 01       	movw	r24, r14
    1dc0:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <prvUnlockQueue>
    1dc4:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
    1dc8:	80 e0       	ldi	r24, 0x00	; 0
    1dca:	29 96       	adiw	r28, 0x09	; 9
    1dcc:	cd bf       	out	0x3d, r28	; 61
    1dce:	de bf       	out	0x3e, r29	; 62
    1dd0:	df 91       	pop	r29
    1dd2:	cf 91       	pop	r28
    1dd4:	1f 91       	pop	r17
    1dd6:	0f 91       	pop	r16
    1dd8:	ff 90       	pop	r15
    1dda:	ef 90       	pop	r14
    1ddc:	df 90       	pop	r13
    1dde:	cf 90       	pop	r12
    1de0:	bf 90       	pop	r11
    1de2:	af 90       	pop	r10
    1de4:	08 95       	ret

00001de6 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1de6:	0f b6       	in	r0, 0x3f	; 63
    1de8:	f8 94       	cli
    1dea:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1dec:	fc 01       	movw	r30, r24
    1dee:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1df0:	0f 90       	pop	r0
    1df2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1df4:	08 95       	ret

00001df6 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    1df6:	cc ee       	ldi	r28, 0xEC	; 236
    1df8:	d0 e3       	ldi	r29, 0x30	; 48
    1dfa:	88 81       	ld	r24, Y
    1dfc:	82 30       	cpi	r24, 0x02	; 2
    1dfe:	e8 f3       	brcs	.-6      	; 0x1dfa <prvIdleTask+0x4>
    1e00:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
    1e04:	fa cf       	rjmp	.-12     	; 0x1dfa <prvIdleTask+0x4>

00001e06 <prvAddCurrentTaskToDelayedList>:
    1e06:	cf 92       	push	r12
    1e08:	df 92       	push	r13
    1e0a:	ef 92       	push	r14
    1e0c:	ff 92       	push	r15
    1e0e:	6b 01       	movw	r12, r22
    1e10:	7c 01       	movw	r14, r24
    1e12:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    1e16:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1e1a:	62 83       	std	Z+2, r22	; 0x02
    1e1c:	73 83       	std	Z+3, r23	; 0x03
    1e1e:	84 83       	std	Z+4, r24	; 0x04
    1e20:	95 83       	std	Z+5, r25	; 0x05
    1e22:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    1e26:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    1e2a:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    1e2e:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    1e32:	c8 16       	cp	r12, r24
    1e34:	d9 06       	cpc	r13, r25
    1e36:	ea 06       	cpc	r14, r26
    1e38:	fb 06       	cpc	r15, r27
    1e3a:	68 f4       	brcc	.+26     	; 0x1e56 <prvAddCurrentTaskToDelayedList+0x50>
    1e3c:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    1e40:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1e44:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    1e48:	90 91 d3 30 	lds	r25, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    1e4c:	6e 5f       	subi	r22, 0xFE	; 254
    1e4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e50:	0e 94 86 0a 	call	0x150c	; 0x150c <vListInsert>
    1e54:	21 c0       	rjmp	.+66     	; 0x1e98 <prvAddCurrentTaskToDelayedList+0x92>
    1e56:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    1e5a:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1e5e:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    1e62:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    1e66:	6e 5f       	subi	r22, 0xFE	; 254
    1e68:	7f 4f       	sbci	r23, 0xFF	; 255
    1e6a:	0e 94 86 0a 	call	0x150c	; 0x150c <vListInsert>
    1e6e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e72:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e76:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e7a:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e7e:	c8 16       	cp	r12, r24
    1e80:	d9 06       	cpc	r13, r25
    1e82:	ea 06       	cpc	r14, r26
    1e84:	fb 06       	cpc	r15, r27
    1e86:	40 f4       	brcc	.+16     	; 0x1e98 <prvAddCurrentTaskToDelayedList+0x92>
    1e88:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1e8c:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e90:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e94:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e98:	ff 90       	pop	r15
    1e9a:	ef 90       	pop	r14
    1e9c:	df 90       	pop	r13
    1e9e:	cf 90       	pop	r12
    1ea0:	08 95       	ret

00001ea2 <xTaskGenericCreate>:
    1ea2:	4f 92       	push	r4
    1ea4:	5f 92       	push	r5
    1ea6:	6f 92       	push	r6
    1ea8:	7f 92       	push	r7
    1eaa:	8f 92       	push	r8
    1eac:	9f 92       	push	r9
    1eae:	af 92       	push	r10
    1eb0:	bf 92       	push	r11
    1eb2:	cf 92       	push	r12
    1eb4:	df 92       	push	r13
    1eb6:	ef 92       	push	r14
    1eb8:	ff 92       	push	r15
    1eba:	0f 93       	push	r16
    1ebc:	1f 93       	push	r17
    1ebe:	cf 93       	push	r28
    1ec0:	df 93       	push	r29
    1ec2:	5c 01       	movw	r10, r24
    1ec4:	4b 01       	movw	r8, r22
    1ec6:	3a 01       	movw	r6, r20
    1ec8:	29 01       	movw	r4, r18
    1eca:	88 e2       	ldi	r24, 0x28	; 40
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	0e 94 78 09 	call	0x12f0	; 0x12f0 <pvPortMalloc>
    1ed2:	ec 01       	movw	r28, r24
    1ed4:	89 2b       	or	r24, r25
    1ed6:	09 f4       	brne	.+2      	; 0x1eda <xTaskGenericCreate+0x38>
    1ed8:	d4 c0       	rjmp	.+424    	; 0x2082 <xTaskGenericCreate+0x1e0>
    1eda:	c1 14       	cp	r12, r1
    1edc:	d1 04       	cpc	r13, r1
    1ede:	09 f0       	breq	.+2      	; 0x1ee2 <xTaskGenericCreate+0x40>
    1ee0:	cc c0       	rjmp	.+408    	; 0x207a <xTaskGenericCreate+0x1d8>
    1ee2:	c3 01       	movw	r24, r6
    1ee4:	0e 94 78 09 	call	0x12f0	; 0x12f0 <pvPortMalloc>
    1ee8:	8b 8f       	std	Y+27, r24	; 0x1b
    1eea:	9c 8f       	std	Y+28, r25	; 0x1c
    1eec:	00 97       	sbiw	r24, 0x00	; 0
    1eee:	21 f4       	brne	.+8      	; 0x1ef8 <xTaskGenericCreate+0x56>
    1ef0:	ce 01       	movw	r24, r28
    1ef2:	0e 94 12 0a 	call	0x1424	; 0x1424 <vPortFree>
    1ef6:	c5 c0       	rjmp	.+394    	; 0x2082 <xTaskGenericCreate+0x1e0>
    1ef8:	a3 01       	movw	r20, r6
    1efa:	61 e1       	ldi	r22, 0x11	; 17
    1efc:	70 e0       	ldi	r23, 0x00	; 0
    1efe:	0e 94 7c 1c 	call	0x38f8	; 0x38f8 <memset>
    1f02:	93 01       	movw	r18, r6
    1f04:	21 50       	subi	r18, 0x01	; 1
    1f06:	31 09       	sbc	r19, r1
    1f08:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f0a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f0c:	3c 01       	movw	r6, r24
    1f0e:	62 0e       	add	r6, r18
    1f10:	73 1e       	adc	r7, r19
    1f12:	4a e0       	ldi	r20, 0x0A	; 10
    1f14:	50 e0       	ldi	r21, 0x00	; 0
    1f16:	b4 01       	movw	r22, r8
    1f18:	ce 01       	movw	r24, r28
    1f1a:	4d 96       	adiw	r24, 0x1d	; 29
    1f1c:	0e 94 83 1c 	call	0x3906	; 0x3906 <strncpy>
    1f20:	1e a2       	std	Y+38, r1	; 0x26
    1f22:	10 2f       	mov	r17, r16
    1f24:	04 30       	cpi	r16, 0x04	; 4
    1f26:	08 f0       	brcs	.+2      	; 0x1f2a <xTaskGenericCreate+0x88>
    1f28:	13 e0       	ldi	r17, 0x03	; 3
    1f2a:	1a 8f       	std	Y+26, r17	; 0x1a
    1f2c:	1f a3       	std	Y+39, r17	; 0x27
    1f2e:	6e 01       	movw	r12, r28
    1f30:	22 e0       	ldi	r18, 0x02	; 2
    1f32:	c2 0e       	add	r12, r18
    1f34:	d1 1c       	adc	r13, r1
    1f36:	c6 01       	movw	r24, r12
    1f38:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialiseItem>
    1f3c:	ce 01       	movw	r24, r28
    1f3e:	0e 96       	adiw	r24, 0x0e	; 14
    1f40:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialiseItem>
    1f44:	ca 87       	std	Y+10, r28	; 0x0a
    1f46:	db 87       	std	Y+11, r29	; 0x0b
    1f48:	84 e0       	ldi	r24, 0x04	; 4
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	a0 e0       	ldi	r26, 0x00	; 0
    1f4e:	b0 e0       	ldi	r27, 0x00	; 0
    1f50:	81 1b       	sub	r24, r17
    1f52:	91 09       	sbc	r25, r1
    1f54:	a1 09       	sbc	r26, r1
    1f56:	b1 09       	sbc	r27, r1
    1f58:	8e 87       	std	Y+14, r24	; 0x0e
    1f5a:	9f 87       	std	Y+15, r25	; 0x0f
    1f5c:	a8 8b       	std	Y+16, r26	; 0x10
    1f5e:	b9 8b       	std	Y+17, r27	; 0x11
    1f60:	ce 8b       	std	Y+22, r28	; 0x16
    1f62:	df 8b       	std	Y+23, r29	; 0x17
    1f64:	a2 01       	movw	r20, r4
    1f66:	b5 01       	movw	r22, r10
    1f68:	c3 01       	movw	r24, r6
    1f6a:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <pxPortInitialiseStack>
    1f6e:	88 83       	st	Y, r24
    1f70:	99 83       	std	Y+1, r25	; 0x01
    1f72:	e1 14       	cp	r14, r1
    1f74:	f1 04       	cpc	r15, r1
    1f76:	19 f0       	breq	.+6      	; 0x1f7e <xTaskGenericCreate+0xdc>
    1f78:	f7 01       	movw	r30, r14
    1f7a:	c0 83       	st	Z, r28
    1f7c:	d1 83       	std	Z+1, r29	; 0x01
    1f7e:	0f b6       	in	r0, 0x3f	; 63
    1f80:	f8 94       	cli
    1f82:	0f 92       	push	r0
    1f84:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    1f88:	8f 5f       	subi	r24, 0xFF	; 255
    1f8a:	80 93 c4 30 	sts	0x30C4, r24	; 0x8030c4 <uxCurrentNumberOfTasks>
    1f8e:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    1f92:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    1f96:	89 2b       	or	r24, r25
    1f98:	89 f5       	brne	.+98     	; 0x1ffc <xTaskGenericCreate+0x15a>
    1f9a:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    1f9e:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    1fa2:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    1fa6:	81 30       	cpi	r24, 0x01	; 1
    1fa8:	c1 f5       	brne	.+112    	; 0x201a <xTaskGenericCreate+0x178>
    1faa:	8c ee       	ldi	r24, 0xEC	; 236
    1fac:	90 e3       	ldi	r25, 0x30	; 48
    1fae:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1fb2:	87 ef       	ldi	r24, 0xF7	; 247
    1fb4:	90 e3       	ldi	r25, 0x30	; 48
    1fb6:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1fba:	82 e0       	ldi	r24, 0x02	; 2
    1fbc:	91 e3       	ldi	r25, 0x31	; 49
    1fbe:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1fc2:	8d e0       	ldi	r24, 0x0D	; 13
    1fc4:	91 e3       	ldi	r25, 0x31	; 49
    1fc6:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1fca:	81 ee       	ldi	r24, 0xE1	; 225
    1fcc:	90 e3       	ldi	r25, 0x30	; 48
    1fce:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1fd2:	86 ed       	ldi	r24, 0xD6	; 214
    1fd4:	90 e3       	ldi	r25, 0x30	; 48
    1fd6:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1fda:	87 ec       	ldi	r24, 0xC7	; 199
    1fdc:	90 e3       	ldi	r25, 0x30	; 48
    1fde:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vListInitialise>
    1fe2:	81 ee       	ldi	r24, 0xE1	; 225
    1fe4:	90 e3       	ldi	r25, 0x30	; 48
    1fe6:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <pxDelayedTaskList>
    1fea:	90 93 d5 30 	sts	0x30D5, r25	; 0x8030d5 <pxDelayedTaskList+0x1>
    1fee:	86 ed       	ldi	r24, 0xD6	; 214
    1ff0:	90 e3       	ldi	r25, 0x30	; 48
    1ff2:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    1ff6:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    1ffa:	0f c0       	rjmp	.+30     	; 0x201a <xTaskGenericCreate+0x178>
    1ffc:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    2000:	81 11       	cpse	r24, r1
    2002:	0b c0       	rjmp	.+22     	; 0x201a <xTaskGenericCreate+0x178>
    2004:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2008:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    200c:	82 8d       	ldd	r24, Z+26	; 0x1a
    200e:	08 17       	cp	r16, r24
    2010:	20 f0       	brcs	.+8      	; 0x201a <xTaskGenericCreate+0x178>
    2012:	c0 93 18 31 	sts	0x3118, r28	; 0x803118 <pxCurrentTCB>
    2016:	d0 93 19 31 	sts	0x3119, r29	; 0x803119 <pxCurrentTCB+0x1>
    201a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    201c:	90 91 bf 30 	lds	r25, 0x30BF	; 0x8030bf <uxTopUsedPriority>
    2020:	98 17       	cp	r25, r24
    2022:	10 f4       	brcc	.+4      	; 0x2028 <xTaskGenericCreate+0x186>
    2024:	80 93 bf 30 	sts	0x30BF, r24	; 0x8030bf <uxTopUsedPriority>
    2028:	90 91 b8 30 	lds	r25, 0x30B8	; 0x8030b8 <uxTaskNumber>
    202c:	9f 5f       	subi	r25, 0xFF	; 255
    202e:	90 93 b8 30 	sts	0x30B8, r25	; 0x8030b8 <uxTaskNumber>
    2032:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2036:	98 17       	cp	r25, r24
    2038:	10 f4       	brcc	.+4      	; 0x203e <xTaskGenericCreate+0x19c>
    203a:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    203e:	fb e0       	ldi	r31, 0x0B	; 11
    2040:	8f 9f       	mul	r24, r31
    2042:	c0 01       	movw	r24, r0
    2044:	11 24       	eor	r1, r1
    2046:	b6 01       	movw	r22, r12
    2048:	84 51       	subi	r24, 0x14	; 20
    204a:	9f 4c       	sbci	r25, 0xCF	; 207
    204c:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsertEnd>
    2050:	0f 90       	pop	r0
    2052:	0f be       	out	0x3f, r0	; 63
    2054:	80 91 bd 30 	lds	r24, 0x30BD	; 0x8030bd <xSchedulerRunning>
    2058:	88 23       	and	r24, r24
    205a:	59 f0       	breq	.+22     	; 0x2072 <xTaskGenericCreate+0x1d0>
    205c:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2060:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2064:	82 8d       	ldd	r24, Z+26	; 0x1a
    2066:	80 17       	cp	r24, r16
    2068:	30 f4       	brcc	.+12     	; 0x2076 <xTaskGenericCreate+0x1d4>
    206a:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
    206e:	81 e0       	ldi	r24, 0x01	; 1
    2070:	09 c0       	rjmp	.+18     	; 0x2084 <xTaskGenericCreate+0x1e2>
    2072:	81 e0       	ldi	r24, 0x01	; 1
    2074:	07 c0       	rjmp	.+14     	; 0x2084 <xTaskGenericCreate+0x1e2>
    2076:	81 e0       	ldi	r24, 0x01	; 1
    2078:	05 c0       	rjmp	.+10     	; 0x2084 <xTaskGenericCreate+0x1e2>
    207a:	cb 8e       	std	Y+27, r12	; 0x1b
    207c:	dc 8e       	std	Y+28, r13	; 0x1c
    207e:	c6 01       	movw	r24, r12
    2080:	3b cf       	rjmp	.-394    	; 0x1ef8 <xTaskGenericCreate+0x56>
    2082:	8f ef       	ldi	r24, 0xFF	; 255
    2084:	df 91       	pop	r29
    2086:	cf 91       	pop	r28
    2088:	1f 91       	pop	r17
    208a:	0f 91       	pop	r16
    208c:	ff 90       	pop	r15
    208e:	ef 90       	pop	r14
    2090:	df 90       	pop	r13
    2092:	cf 90       	pop	r12
    2094:	bf 90       	pop	r11
    2096:	af 90       	pop	r10
    2098:	9f 90       	pop	r9
    209a:	8f 90       	pop	r8
    209c:	7f 90       	pop	r7
    209e:	6f 90       	pop	r6
    20a0:	5f 90       	pop	r5
    20a2:	4f 90       	pop	r4
    20a4:	08 95       	ret

000020a6 <uxTaskPriorityGet>:
    20a6:	0f b6       	in	r0, 0x3f	; 63
    20a8:	f8 94       	cli
    20aa:	0f 92       	push	r0
    20ac:	00 97       	sbiw	r24, 0x00	; 0
    20ae:	21 f4       	brne	.+8      	; 0x20b8 <uxTaskPriorityGet+0x12>
    20b0:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    20b4:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    20b8:	0f 90       	pop	r0
    20ba:	0f be       	out	0x3f, r0	; 63
    20bc:	fc 01       	movw	r30, r24
    20be:	82 8d       	ldd	r24, Z+26	; 0x1a
    20c0:	08 95       	ret

000020c2 <vTaskStartScheduler>:
    20c2:	af 92       	push	r10
    20c4:	bf 92       	push	r11
    20c6:	cf 92       	push	r12
    20c8:	df 92       	push	r13
    20ca:	ef 92       	push	r14
    20cc:	ff 92       	push	r15
    20ce:	0f 93       	push	r16
    20d0:	a1 2c       	mov	r10, r1
    20d2:	b1 2c       	mov	r11, r1
    20d4:	c1 2c       	mov	r12, r1
    20d6:	d1 2c       	mov	r13, r1
    20d8:	0f 2e       	mov	r0, r31
    20da:	f5 ec       	ldi	r31, 0xC5	; 197
    20dc:	ef 2e       	mov	r14, r31
    20de:	f0 e3       	ldi	r31, 0x30	; 48
    20e0:	ff 2e       	mov	r15, r31
    20e2:	f0 2d       	mov	r31, r0
    20e4:	00 e0       	ldi	r16, 0x00	; 0
    20e6:	20 e0       	ldi	r18, 0x00	; 0
    20e8:	30 e0       	ldi	r19, 0x00	; 0
    20ea:	44 e6       	ldi	r20, 0x64	; 100
    20ec:	50 e0       	ldi	r21, 0x00	; 0
    20ee:	66 e2       	ldi	r22, 0x26	; 38
    20f0:	70 e2       	ldi	r23, 0x20	; 32
    20f2:	8b ef       	ldi	r24, 0xFB	; 251
    20f4:	9e e0       	ldi	r25, 0x0E	; 14
    20f6:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <xTaskGenericCreate>
    20fa:	81 30       	cpi	r24, 0x01	; 1
    20fc:	69 f4       	brne	.+26     	; 0x2118 <vTaskStartScheduler+0x56>
    20fe:	f8 94       	cli
    2100:	80 93 bd 30 	sts	0x30BD, r24	; 0x8030bd <xSchedulerRunning>
    2104:	10 92 c0 30 	sts	0x30C0, r1	; 0x8030c0 <xTickCount>
    2108:	10 92 c1 30 	sts	0x30C1, r1	; 0x8030c1 <xTickCount+0x1>
    210c:	10 92 c2 30 	sts	0x30C2, r1	; 0x8030c2 <xTickCount+0x2>
    2110:	10 92 c3 30 	sts	0x30C3, r1	; 0x8030c3 <xTickCount+0x3>
    2114:	0e 94 6d 0b 	call	0x16da	; 0x16da <xPortStartScheduler>
    2118:	0f 91       	pop	r16
    211a:	ff 90       	pop	r15
    211c:	ef 90       	pop	r14
    211e:	df 90       	pop	r13
    2120:	cf 90       	pop	r12
    2122:	bf 90       	pop	r11
    2124:	af 90       	pop	r10
    2126:	08 95       	ret

00002128 <vTaskSuspendAll>:
    2128:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    212c:	8f 5f       	subi	r24, 0xFF	; 255
    212e:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>
    2132:	08 95       	ret

00002134 <xTaskGetTickCount>:
    2134:	0f b6       	in	r0, 0x3f	; 63
    2136:	f8 94       	cli
    2138:	0f 92       	push	r0
    213a:	60 91 c0 30 	lds	r22, 0x30C0	; 0x8030c0 <xTickCount>
    213e:	70 91 c1 30 	lds	r23, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2142:	80 91 c2 30 	lds	r24, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2146:	90 91 c3 30 	lds	r25, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    214a:	0f 90       	pop	r0
    214c:	0f be       	out	0x3f, r0	; 63
    214e:	08 95       	ret

00002150 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    2150:	00 97       	sbiw	r24, 0x00	; 0
    2152:	21 f4       	brne	.+8      	; 0x215c <pcTaskGetTaskName+0xc>
    2154:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2158:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    215c:	4d 96       	adiw	r24, 0x1d	; 29
    215e:	08 95       	ret

00002160 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    2160:	80 91 c5 30 	lds	r24, 0x30C5	; 0x8030c5 <xIdleTaskHandle>
    2164:	90 91 c6 30 	lds	r25, 0x30C6	; 0x8030c6 <xIdleTaskHandle+0x1>
    2168:	08 95       	ret

0000216a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    216a:	ff 92       	push	r15
    216c:	0f 93       	push	r16
    216e:	1f 93       	push	r17
    2170:	cf 93       	push	r28
    2172:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2174:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2178:	81 11       	cpse	r24, r1
    217a:	ed c0       	rjmp	.+474    	; 0x2356 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    217c:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2180:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2184:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2188:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    218c:	01 96       	adiw	r24, 0x01	; 1
    218e:	a1 1d       	adc	r26, r1
    2190:	b1 1d       	adc	r27, r1
    2192:	80 93 c0 30 	sts	0x30C0, r24	; 0x8030c0 <xTickCount>
    2196:	90 93 c1 30 	sts	0x30C1, r25	; 0x8030c1 <xTickCount+0x1>
    219a:	a0 93 c2 30 	sts	0x30C2, r26	; 0x8030c2 <xTickCount+0x2>
    219e:	b0 93 c3 30 	sts	0x30C3, r27	; 0x8030c3 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    21a2:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    21a6:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    21aa:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    21ae:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    21b2:	89 2b       	or	r24, r25
    21b4:	8a 2b       	or	r24, r26
    21b6:	8b 2b       	or	r24, r27
    21b8:	f1 f5       	brne	.+124    	; 0x2236 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    21ba:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    21be:	90 91 d5 30 	lds	r25, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    21c2:	20 91 d2 30 	lds	r18, 0x30D2	; 0x8030d2 <pxOverflowDelayedTaskList>
    21c6:	30 91 d3 30 	lds	r19, 0x30D3	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
    21ca:	20 93 d4 30 	sts	0x30D4, r18	; 0x8030d4 <pxDelayedTaskList>
    21ce:	30 93 d5 30 	sts	0x30D5, r19	; 0x8030d5 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    21d2:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <pxOverflowDelayedTaskList>
    21d6:	90 93 d3 30 	sts	0x30D3, r25	; 0x8030d3 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    21da:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    21de:	8f 5f       	subi	r24, 0xFF	; 255
    21e0:	80 93 b9 30 	sts	0x30B9, r24	; 0x8030b9 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    21e4:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    21e8:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    21ec:	80 81       	ld	r24, Z
    21ee:	81 11       	cpse	r24, r1
    21f0:	0c c0       	rjmp	.+24     	; 0x220a <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    21f2:	8f ef       	ldi	r24, 0xFF	; 255
    21f4:	9f ef       	ldi	r25, 0xFF	; 255
    21f6:	dc 01       	movw	r26, r24
    21f8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21fc:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2200:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2204:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2208:	16 c0       	rjmp	.+44     	; 0x2236 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    220a:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    220e:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2212:	07 80       	ldd	r0, Z+7	; 0x07
    2214:	f0 85       	ldd	r31, Z+8	; 0x08
    2216:	e0 2d       	mov	r30, r0
    2218:	00 84       	ldd	r0, Z+8	; 0x08
    221a:	f1 85       	ldd	r31, Z+9	; 0x09
    221c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    221e:	82 81       	ldd	r24, Z+2	; 0x02
    2220:	93 81       	ldd	r25, Z+3	; 0x03
    2222:	a4 81       	ldd	r26, Z+4	; 0x04
    2224:	b5 81       	ldd	r27, Z+5	; 0x05
    2226:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    222a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    222e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2232:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2236:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    223a:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    223e:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2242:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2246:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    224a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    224e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2252:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2256:	48 17       	cp	r20, r24
    2258:	59 07       	cpc	r21, r25
    225a:	6a 07       	cpc	r22, r26
    225c:	7b 07       	cpc	r23, r27
    225e:	08 f4       	brcc	.+2      	; 0x2262 <vTaskIncrementTick+0xf8>
    2260:	7f c0       	rjmp	.+254    	; 0x2360 <vTaskIncrementTick+0x1f6>
    2262:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2266:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    226a:	80 81       	ld	r24, Z
    226c:	88 23       	and	r24, r24
    226e:	f9 f0       	breq	.+62     	; 0x22ae <vTaskIncrementTick+0x144>
    2270:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    2274:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    2278:	07 80       	ldd	r0, Z+7	; 0x07
    227a:	f0 85       	ldd	r31, Z+8	; 0x08
    227c:	e0 2d       	mov	r30, r0
    227e:	c0 85       	ldd	r28, Z+8	; 0x08
    2280:	d1 85       	ldd	r29, Z+9	; 0x09
    2282:	8a 81       	ldd	r24, Y+2	; 0x02
    2284:	9b 81       	ldd	r25, Y+3	; 0x03
    2286:	ac 81       	ldd	r26, Y+4	; 0x04
    2288:	bd 81       	ldd	r27, Y+5	; 0x05
    228a:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    228e:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2292:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2296:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    229a:	48 17       	cp	r20, r24
    229c:	59 07       	cpc	r21, r25
    229e:	6a 07       	cpc	r22, r26
    22a0:	7b 07       	cpc	r23, r27
    22a2:	58 f1       	brcs	.+86     	; 0x22fa <vTaskIncrementTick+0x190>
    22a4:	0f 2e       	mov	r0, r31
    22a6:	fb e0       	ldi	r31, 0x0B	; 11
    22a8:	ff 2e       	mov	r15, r31
    22aa:	f0 2d       	mov	r31, r0
    22ac:	2f c0       	rjmp	.+94     	; 0x230c <vTaskIncrementTick+0x1a2>
    22ae:	8f ef       	ldi	r24, 0xFF	; 255
    22b0:	9f ef       	ldi	r25, 0xFF	; 255
    22b2:	dc 01       	movw	r26, r24
    22b4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22b8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    22bc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    22c0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    22c4:	4d c0       	rjmp	.+154    	; 0x2360 <vTaskIncrementTick+0x1f6>
    22c6:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    22ca:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    22ce:	07 80       	ldd	r0, Z+7	; 0x07
    22d0:	f0 85       	ldd	r31, Z+8	; 0x08
    22d2:	e0 2d       	mov	r30, r0
    22d4:	c0 85       	ldd	r28, Z+8	; 0x08
    22d6:	d1 85       	ldd	r29, Z+9	; 0x09
    22d8:	8a 81       	ldd	r24, Y+2	; 0x02
    22da:	9b 81       	ldd	r25, Y+3	; 0x03
    22dc:	ac 81       	ldd	r26, Y+4	; 0x04
    22de:	bd 81       	ldd	r27, Y+5	; 0x05
    22e0:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    22e4:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    22e8:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    22ec:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    22f0:	48 17       	cp	r20, r24
    22f2:	59 07       	cpc	r21, r25
    22f4:	6a 07       	cpc	r22, r26
    22f6:	7b 07       	cpc	r23, r27
    22f8:	48 f4       	brcc	.+18     	; 0x230c <vTaskIncrementTick+0x1a2>
    22fa:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    22fe:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2302:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2306:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    230a:	2a c0       	rjmp	.+84     	; 0x2360 <vTaskIncrementTick+0x1f6>
    230c:	8e 01       	movw	r16, r28
    230e:	0e 5f       	subi	r16, 0xFE	; 254
    2310:	1f 4f       	sbci	r17, 0xFF	; 255
    2312:	c8 01       	movw	r24, r16
    2314:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
    2318:	88 8d       	ldd	r24, Y+24	; 0x18
    231a:	99 8d       	ldd	r25, Y+25	; 0x19
    231c:	89 2b       	or	r24, r25
    231e:	21 f0       	breq	.+8      	; 0x2328 <vTaskIncrementTick+0x1be>
    2320:	ce 01       	movw	r24, r28
    2322:	0e 96       	adiw	r24, 0x0e	; 14
    2324:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
    2328:	8a 8d       	ldd	r24, Y+26	; 0x1a
    232a:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    232e:	98 17       	cp	r25, r24
    2330:	10 f4       	brcc	.+4      	; 0x2336 <vTaskIncrementTick+0x1cc>
    2332:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2336:	f8 9e       	mul	r15, r24
    2338:	c0 01       	movw	r24, r0
    233a:	11 24       	eor	r1, r1
    233c:	b8 01       	movw	r22, r16
    233e:	84 51       	subi	r24, 0x14	; 20
    2340:	9f 4c       	sbci	r25, 0xCF	; 207
    2342:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsertEnd>
    2346:	e0 91 d4 30 	lds	r30, 0x30D4	; 0x8030d4 <pxDelayedTaskList>
    234a:	f0 91 d5 30 	lds	r31, 0x30D5	; 0x8030d5 <pxDelayedTaskList+0x1>
    234e:	80 81       	ld	r24, Z
    2350:	81 11       	cpse	r24, r1
    2352:	b9 cf       	rjmp	.-142    	; 0x22c6 <vTaskIncrementTick+0x15c>
    2354:	ac cf       	rjmp	.-168    	; 0x22ae <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    2356:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    235a:	8f 5f       	subi	r24, 0xFF	; 255
    235c:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2360:	df 91       	pop	r29
    2362:	cf 91       	pop	r28
    2364:	1f 91       	pop	r17
    2366:	0f 91       	pop	r16
    2368:	ff 90       	pop	r15
    236a:	08 95       	ret

0000236c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    236c:	cf 92       	push	r12
    236e:	df 92       	push	r13
    2370:	ef 92       	push	r14
    2372:	ff 92       	push	r15
    2374:	0f 93       	push	r16
    2376:	1f 93       	push	r17
    2378:	cf 93       	push	r28
    237a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    237c:	0f b6       	in	r0, 0x3f	; 63
    237e:	f8 94       	cli
    2380:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2382:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2386:	81 50       	subi	r24, 0x01	; 1
    2388:	80 93 bc 30 	sts	0x30BC, r24	; 0x8030bc <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    238c:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    2390:	81 11       	cpse	r24, r1
    2392:	60 c0       	rjmp	.+192    	; 0x2454 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2394:	80 91 c4 30 	lds	r24, 0x30C4	; 0x8030c4 <uxCurrentNumberOfTasks>
    2398:	81 11       	cpse	r24, r1
    239a:	2c c0       	rjmp	.+88     	; 0x23f4 <xTaskResumeAll+0x88>
    239c:	5e c0       	rjmp	.+188    	; 0x245a <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    239e:	d7 01       	movw	r26, r14
    23a0:	17 96       	adiw	r26, 0x07	; 7
    23a2:	ed 91       	ld	r30, X+
    23a4:	fc 91       	ld	r31, X
    23a6:	18 97       	sbiw	r26, 0x08	; 8
    23a8:	c0 85       	ldd	r28, Z+8	; 0x08
    23aa:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    23ac:	ce 01       	movw	r24, r28
    23ae:	0e 96       	adiw	r24, 0x0e	; 14
    23b0:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    23b4:	8e 01       	movw	r16, r28
    23b6:	0e 5f       	subi	r16, 0xFE	; 254
    23b8:	1f 4f       	sbci	r17, 0xFF	; 255
    23ba:	c8 01       	movw	r24, r16
    23bc:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    23c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23c2:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    23c6:	98 17       	cp	r25, r24
    23c8:	10 f4       	brcc	.+4      	; 0x23ce <xTaskResumeAll+0x62>
    23ca:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    23ce:	d8 9e       	mul	r13, r24
    23d0:	c0 01       	movw	r24, r0
    23d2:	11 24       	eor	r1, r1
    23d4:	b8 01       	movw	r22, r16
    23d6:	84 51       	subi	r24, 0x14	; 20
    23d8:	9f 4c       	sbci	r25, 0xCF	; 207
    23da:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23de:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    23e2:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    23e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    23e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    23ea:	98 17       	cp	r25, r24
    23ec:	70 f0       	brcs	.+28     	; 0x240a <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    23ee:	cc 24       	eor	r12, r12
    23f0:	c3 94       	inc	r12
    23f2:	0b c0       	rjmp	.+22     	; 0x240a <xTaskResumeAll+0x9e>
    23f4:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    23f6:	0f 2e       	mov	r0, r31
    23f8:	f7 ec       	ldi	r31, 0xC7	; 199
    23fa:	ef 2e       	mov	r14, r31
    23fc:	f0 e3       	ldi	r31, 0x30	; 48
    23fe:	ff 2e       	mov	r15, r31
    2400:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    2402:	0f 2e       	mov	r0, r31
    2404:	fb e0       	ldi	r31, 0x0B	; 11
    2406:	df 2e       	mov	r13, r31
    2408:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    240a:	f7 01       	movw	r30, r14
    240c:	80 81       	ld	r24, Z
    240e:	81 11       	cpse	r24, r1
    2410:	c6 cf       	rjmp	.-116    	; 0x239e <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2412:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2416:	88 23       	and	r24, r24
    2418:	81 f0       	breq	.+32     	; 0x243a <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    241a:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    241e:	88 23       	and	r24, r24
    2420:	99 f0       	breq	.+38     	; 0x2448 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    2422:	0e 94 b5 10 	call	0x216a	; 0x216a <vTaskIncrementTick>
						--uxMissedTicks;
    2426:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    242a:	81 50       	subi	r24, 0x01	; 1
    242c:	80 93 bb 30 	sts	0x30BB, r24	; 0x8030bb <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2430:	80 91 bb 30 	lds	r24, 0x30BB	; 0x8030bb <uxMissedTicks>
    2434:	81 11       	cpse	r24, r1
    2436:	f5 cf       	rjmp	.-22     	; 0x2422 <xTaskResumeAll+0xb6>
    2438:	07 c0       	rjmp	.+14     	; 0x2448 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    243a:	f1 e0       	ldi	r31, 0x01	; 1
    243c:	cf 16       	cp	r12, r31
    243e:	21 f0       	breq	.+8      	; 0x2448 <xTaskResumeAll+0xdc>
    2440:	80 91 ba 30 	lds	r24, 0x30BA	; 0x8030ba <xMissedYield>
    2444:	81 30       	cpi	r24, 0x01	; 1
    2446:	41 f4       	brne	.+16     	; 0x2458 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2448:	10 92 ba 30 	sts	0x30BA, r1	; 0x8030ba <xMissedYield>
					portYIELD_WITHIN_API();
    244c:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    2450:	81 e0       	ldi	r24, 0x01	; 1
    2452:	03 c0       	rjmp	.+6      	; 0x245a <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2454:	80 e0       	ldi	r24, 0x00	; 0
    2456:	01 c0       	rjmp	.+2      	; 0x245a <xTaskResumeAll+0xee>
    2458:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    245a:	0f 90       	pop	r0
    245c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    245e:	df 91       	pop	r29
    2460:	cf 91       	pop	r28
    2462:	1f 91       	pop	r17
    2464:	0f 91       	pop	r16
    2466:	ff 90       	pop	r15
    2468:	ef 90       	pop	r14
    246a:	df 90       	pop	r13
    246c:	cf 90       	pop	r12
    246e:	08 95       	ret

00002470 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2470:	cf 92       	push	r12
    2472:	df 92       	push	r13
    2474:	ef 92       	push	r14
    2476:	ff 92       	push	r15
    2478:	cf 93       	push	r28
    247a:	df 93       	push	r29
    247c:	ec 01       	movw	r28, r24
    247e:	6a 01       	movw	r12, r20
    2480:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2482:	0e 94 94 10 	call	0x2128	; 0x2128 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2486:	88 81       	ld	r24, Y
    2488:	99 81       	ldd	r25, Y+1	; 0x01
    248a:	aa 81       	ldd	r26, Y+2	; 0x02
    248c:	bb 81       	ldd	r27, Y+3	; 0x03
    248e:	c8 0e       	add	r12, r24
    2490:	d9 1e       	adc	r13, r25
    2492:	ea 1e       	adc	r14, r26
    2494:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    2496:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    249a:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    249e:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    24a2:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    24a6:	48 17       	cp	r20, r24
    24a8:	59 07       	cpc	r21, r25
    24aa:	6a 07       	cpc	r22, r26
    24ac:	7b 07       	cpc	r23, r27
    24ae:	b8 f4       	brcc	.+46     	; 0x24de <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    24b0:	c8 16       	cp	r12, r24
    24b2:	d9 06       	cpc	r13, r25
    24b4:	ea 06       	cpc	r14, r26
    24b6:	fb 06       	cpc	r15, r27
    24b8:	e0 f5       	brcc	.+120    	; 0x2532 <vTaskDelayUntil+0xc2>
    24ba:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    24be:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    24c2:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    24c6:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    24ca:	c8 82       	st	Y, r12
    24cc:	d9 82       	std	Y+1, r13	; 0x01
    24ce:	ea 82       	std	Y+2, r14	; 0x02
    24d0:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    24d2:	8c 15       	cp	r24, r12
    24d4:	9d 05       	cpc	r25, r13
    24d6:	ae 05       	cpc	r26, r14
    24d8:	bf 05       	cpc	r27, r15
    24da:	f8 f4       	brcc	.+62     	; 0x251a <vTaskDelayUntil+0xaa>
    24dc:	13 c0       	rjmp	.+38     	; 0x2504 <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    24de:	c8 16       	cp	r12, r24
    24e0:	d9 06       	cpc	r13, r25
    24e2:	ea 06       	cpc	r14, r26
    24e4:	fb 06       	cpc	r15, r27
    24e6:	00 f1       	brcs	.+64     	; 0x2528 <vTaskDelayUntil+0xb8>
    24e8:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    24ec:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    24f0:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    24f4:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    24f8:	8c 15       	cp	r24, r12
    24fa:	9d 05       	cpc	r25, r13
    24fc:	ae 05       	cpc	r26, r14
    24fe:	bf 05       	cpc	r27, r15
    2500:	98 f0       	brcs	.+38     	; 0x2528 <vTaskDelayUntil+0xb8>
    2502:	17 c0       	rjmp	.+46     	; 0x2532 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2504:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2508:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    250c:	02 96       	adiw	r24, 0x02	; 2
    250e:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2512:	c7 01       	movw	r24, r14
    2514:	b6 01       	movw	r22, r12
    2516:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    251a:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    251e:	81 11       	cpse	r24, r1
    2520:	0d c0       	rjmp	.+26     	; 0x253c <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    2522:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
		}
	}
    2526:	0a c0       	rjmp	.+20     	; 0x253c <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2528:	c8 82       	st	Y, r12
    252a:	d9 82       	std	Y+1, r13	; 0x01
    252c:	ea 82       	std	Y+2, r14	; 0x02
    252e:	fb 82       	std	Y+3, r15	; 0x03
    2530:	e9 cf       	rjmp	.-46     	; 0x2504 <vTaskDelayUntil+0x94>
    2532:	c8 82       	st	Y, r12
    2534:	d9 82       	std	Y+1, r13	; 0x01
    2536:	ea 82       	std	Y+2, r14	; 0x02
    2538:	fb 82       	std	Y+3, r15	; 0x03
    253a:	ef cf       	rjmp	.-34     	; 0x251a <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    253c:	df 91       	pop	r29
    253e:	cf 91       	pop	r28
    2540:	ff 90       	pop	r15
    2542:	ef 90       	pop	r14
    2544:	df 90       	pop	r13
    2546:	cf 90       	pop	r12
    2548:	08 95       	ret

0000254a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    254a:	cf 92       	push	r12
    254c:	df 92       	push	r13
    254e:	ef 92       	push	r14
    2550:	ff 92       	push	r15
    2552:	6b 01       	movw	r12, r22
    2554:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2556:	67 2b       	or	r22, r23
    2558:	68 2b       	or	r22, r24
    255a:	69 2b       	or	r22, r25
    255c:	e9 f0       	breq	.+58     	; 0x2598 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    255e:	0e 94 94 10 	call	0x2128	; 0x2128 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2562:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2566:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    256a:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    256e:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    2572:	c8 0e       	add	r12, r24
    2574:	d9 1e       	adc	r13, r25
    2576:	ea 1e       	adc	r14, r26
    2578:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    257a:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    257e:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2582:	02 96       	adiw	r24, 0x02	; 2
    2584:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2588:	c7 01       	movw	r24, r14
    258a:	b6 01       	movw	r22, r12
    258c:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2590:	0e 94 b6 11 	call	0x236c	; 0x236c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2594:	81 11       	cpse	r24, r1
    2596:	02 c0       	rjmp	.+4      	; 0x259c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2598:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vPortYield>
		}
	}
    259c:	ff 90       	pop	r15
    259e:	ef 90       	pop	r14
    25a0:	df 90       	pop	r13
    25a2:	cf 90       	pop	r12
    25a4:	08 95       	ret

000025a6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    25a6:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    25aa:	81 11       	cpse	r24, r1
    25ac:	0c c0       	rjmp	.+24     	; 0x25c6 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25ae:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    25b2:	4b e0       	ldi	r20, 0x0B	; 11
    25b4:	e4 9f       	mul	r30, r20
    25b6:	f0 01       	movw	r30, r0
    25b8:	11 24       	eor	r1, r1
    25ba:	e4 51       	subi	r30, 0x14	; 20
    25bc:	ff 4c       	sbci	r31, 0xCF	; 207
    25be:	80 81       	ld	r24, Z
    25c0:	88 23       	and	r24, r24
    25c2:	29 f0       	breq	.+10     	; 0x25ce <vTaskSwitchContext+0x28>
    25c4:	14 c0       	rjmp	.+40     	; 0x25ee <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    25cc:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25ce:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    25d0:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    25d4:	81 50       	subi	r24, 0x01	; 1
    25d6:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25da:	e0 91 be 30 	lds	r30, 0x30BE	; 0x8030be <uxTopReadyPriority>
    25de:	9e 9f       	mul	r25, r30
    25e0:	f0 01       	movw	r30, r0
    25e2:	11 24       	eor	r1, r1
    25e4:	e4 51       	subi	r30, 0x14	; 20
    25e6:	ff 4c       	sbci	r31, 0xCF	; 207
    25e8:	80 81       	ld	r24, Z
    25ea:	88 23       	and	r24, r24
    25ec:	89 f3       	breq	.-30     	; 0x25d0 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    25ee:	80 91 be 30 	lds	r24, 0x30BE	; 0x8030be <uxTopReadyPriority>
    25f2:	28 2f       	mov	r18, r24
    25f4:	30 e0       	ldi	r19, 0x00	; 0
    25f6:	4b e0       	ldi	r20, 0x0B	; 11
    25f8:	84 9f       	mul	r24, r20
    25fa:	c0 01       	movw	r24, r0
    25fc:	11 24       	eor	r1, r1
    25fe:	dc 01       	movw	r26, r24
    2600:	a4 51       	subi	r26, 0x14	; 20
    2602:	bf 4c       	sbci	r27, 0xCF	; 207
    2604:	11 96       	adiw	r26, 0x01	; 1
    2606:	ed 91       	ld	r30, X+
    2608:	fc 91       	ld	r31, X
    260a:	12 97       	sbiw	r26, 0x02	; 2
    260c:	04 80       	ldd	r0, Z+4	; 0x04
    260e:	f5 81       	ldd	r31, Z+5	; 0x05
    2610:	e0 2d       	mov	r30, r0
    2612:	11 96       	adiw	r26, 0x01	; 1
    2614:	ed 93       	st	X+, r30
    2616:	fc 93       	st	X, r31
    2618:	12 97       	sbiw	r26, 0x02	; 2
    261a:	81 51       	subi	r24, 0x11	; 17
    261c:	9f 4c       	sbci	r25, 0xCF	; 207
    261e:	e8 17       	cp	r30, r24
    2620:	f9 07       	cpc	r31, r25
    2622:	61 f4       	brne	.+24     	; 0x263c <vTaskSwitchContext+0x96>
    2624:	84 81       	ldd	r24, Z+4	; 0x04
    2626:	95 81       	ldd	r25, Z+5	; 0x05
    2628:	4b e0       	ldi	r20, 0x0B	; 11
    262a:	42 9f       	mul	r20, r18
    262c:	f0 01       	movw	r30, r0
    262e:	43 9f       	mul	r20, r19
    2630:	f0 0d       	add	r31, r0
    2632:	11 24       	eor	r1, r1
    2634:	e4 51       	subi	r30, 0x14	; 20
    2636:	ff 4c       	sbci	r31, 0xCF	; 207
    2638:	81 83       	std	Z+1, r24	; 0x01
    263a:	92 83       	std	Z+2, r25	; 0x02
    263c:	8b e0       	ldi	r24, 0x0B	; 11
    263e:	82 9f       	mul	r24, r18
    2640:	f0 01       	movw	r30, r0
    2642:	83 9f       	mul	r24, r19
    2644:	f0 0d       	add	r31, r0
    2646:	11 24       	eor	r1, r1
    2648:	e4 51       	subi	r30, 0x14	; 20
    264a:	ff 4c       	sbci	r31, 0xCF	; 207
    264c:	01 80       	ldd	r0, Z+1	; 0x01
    264e:	f2 81       	ldd	r31, Z+2	; 0x02
    2650:	e0 2d       	mov	r30, r0
    2652:	80 85       	ldd	r24, Z+8	; 0x08
    2654:	91 85       	ldd	r25, Z+9	; 0x09
    2656:	80 93 18 31 	sts	0x3118, r24	; 0x803118 <pxCurrentTCB>
    265a:	90 93 19 31 	sts	0x3119, r25	; 0x803119 <pxCurrentTCB+0x1>
    265e:	08 95       	ret

00002660 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2660:	cf 92       	push	r12
    2662:	df 92       	push	r13
    2664:	ef 92       	push	r14
    2666:	ff 92       	push	r15
    2668:	6a 01       	movw	r12, r20
    266a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    266c:	60 91 18 31 	lds	r22, 0x3118	; 0x803118 <pxCurrentTCB>
    2670:	70 91 19 31 	lds	r23, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2674:	62 5f       	subi	r22, 0xF2	; 242
    2676:	7f 4f       	sbci	r23, 0xFF	; 255
    2678:	0e 94 86 0a 	call	0x150c	; 0x150c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    267c:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    2680:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2684:	02 96       	adiw	r24, 0x02	; 2
    2686:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    268a:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    268e:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2692:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2696:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    269a:	bc 01       	movw	r22, r24
    269c:	cd 01       	movw	r24, r26
    269e:	6c 0d       	add	r22, r12
    26a0:	7d 1d       	adc	r23, r13
    26a2:	8e 1d       	adc	r24, r14
    26a4:	9f 1d       	adc	r25, r15
    26a6:	0e 94 03 0f 	call	0x1e06	; 0x1e06 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    26aa:	ff 90       	pop	r15
    26ac:	ef 90       	pop	r14
    26ae:	df 90       	pop	r13
    26b0:	cf 90       	pop	r12
    26b2:	08 95       	ret

000026b4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    26b4:	0f 93       	push	r16
    26b6:	1f 93       	push	r17
    26b8:	cf 93       	push	r28
    26ba:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    26bc:	dc 01       	movw	r26, r24
    26be:	17 96       	adiw	r26, 0x07	; 7
    26c0:	ed 91       	ld	r30, X+
    26c2:	fc 91       	ld	r31, X
    26c4:	18 97       	sbiw	r26, 0x08	; 8
    26c6:	c0 85       	ldd	r28, Z+8	; 0x08
    26c8:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    26ca:	8e 01       	movw	r16, r28
    26cc:	02 5f       	subi	r16, 0xF2	; 242
    26ce:	1f 4f       	sbci	r17, 0xFF	; 255
    26d0:	c8 01       	movw	r24, r16
    26d2:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    26d6:	80 91 bc 30 	lds	r24, 0x30BC	; 0x8030bc <uxSchedulerSuspended>
    26da:	81 11       	cpse	r24, r1
    26dc:	16 c0       	rjmp	.+44     	; 0x270a <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    26de:	0c 50       	subi	r16, 0x0C	; 12
    26e0:	11 09       	sbc	r17, r1
    26e2:	c8 01       	movw	r24, r16
    26e4:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    26e8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    26ea:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    26ee:	98 17       	cp	r25, r24
    26f0:	10 f4       	brcc	.+4      	; 0x26f6 <xTaskRemoveFromEventList+0x42>
    26f2:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    26f6:	bb e0       	ldi	r27, 0x0B	; 11
    26f8:	8b 9f       	mul	r24, r27
    26fa:	c0 01       	movw	r24, r0
    26fc:	11 24       	eor	r1, r1
    26fe:	b8 01       	movw	r22, r16
    2700:	84 51       	subi	r24, 0x14	; 20
    2702:	9f 4c       	sbci	r25, 0xCF	; 207
    2704:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsertEnd>
    2708:	05 c0       	rjmp	.+10     	; 0x2714 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    270a:	b8 01       	movw	r22, r16
    270c:	87 ec       	ldi	r24, 0xC7	; 199
    270e:	90 e3       	ldi	r25, 0x30	; 48
    2710:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2714:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    2718:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    271c:	81 e0       	ldi	r24, 0x01	; 1
    271e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2720:	92 8d       	ldd	r25, Z+26	; 0x1a
    2722:	29 17       	cp	r18, r25
    2724:	08 f4       	brcc	.+2      	; 0x2728 <xTaskRemoveFromEventList+0x74>
    2726:	80 e0       	ldi	r24, 0x00	; 0
}
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	1f 91       	pop	r17
    272e:	0f 91       	pop	r16
    2730:	08 95       	ret

00002732 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2732:	20 91 b9 30 	lds	r18, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2736:	fc 01       	movw	r30, r24
    2738:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    273a:	40 91 c0 30 	lds	r20, 0x30C0	; 0x8030c0 <xTickCount>
    273e:	50 91 c1 30 	lds	r21, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2742:	60 91 c2 30 	lds	r22, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    2746:	70 91 c3 30 	lds	r23, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    274a:	41 83       	std	Z+1, r20	; 0x01
    274c:	52 83       	std	Z+2, r21	; 0x02
    274e:	63 83       	std	Z+3, r22	; 0x03
    2750:	74 83       	std	Z+4, r23	; 0x04
    2752:	08 95       	ret

00002754 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2754:	8f 92       	push	r8
    2756:	9f 92       	push	r9
    2758:	af 92       	push	r10
    275a:	bf 92       	push	r11
    275c:	cf 92       	push	r12
    275e:	df 92       	push	r13
    2760:	ef 92       	push	r14
    2762:	ff 92       	push	r15
    2764:	0f 93       	push	r16
    2766:	1f 93       	push	r17
    2768:	cf 93       	push	r28
    276a:	df 93       	push	r29
    276c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    276e:	0f b6       	in	r0, 0x3f	; 63
    2770:	f8 94       	cli
    2772:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2774:	80 91 b9 30 	lds	r24, 0x30B9	; 0x8030b9 <xNumOfOverflows>
    2778:	90 81       	ld	r25, Z
    277a:	98 17       	cp	r25, r24
    277c:	89 f0       	breq	.+34     	; 0x27a0 <xTaskCheckForTimeOut+0x4c>
    277e:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    2782:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    2786:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    278a:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    278e:	01 81       	ldd	r16, Z+1	; 0x01
    2790:	12 81       	ldd	r17, Z+2	; 0x02
    2792:	23 81       	ldd	r18, Z+3	; 0x03
    2794:	34 81       	ldd	r19, Z+4	; 0x04
    2796:	80 17       	cp	r24, r16
    2798:	91 07       	cpc	r25, r17
    279a:	a2 07       	cpc	r26, r18
    279c:	b3 07       	cpc	r27, r19
    279e:	a8 f5       	brcc	.+106    	; 0x280a <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    27a0:	80 91 c0 30 	lds	r24, 0x30C0	; 0x8030c0 <xTickCount>
    27a4:	90 91 c1 30 	lds	r25, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    27a8:	a0 91 c2 30 	lds	r26, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    27ac:	b0 91 c3 30 	lds	r27, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    27b0:	c1 80       	ldd	r12, Z+1	; 0x01
    27b2:	d2 80       	ldd	r13, Z+2	; 0x02
    27b4:	e3 80       	ldd	r14, Z+3	; 0x03
    27b6:	f4 80       	ldd	r15, Z+4	; 0x04
    27b8:	eb 01       	movw	r28, r22
    27ba:	08 81       	ld	r16, Y
    27bc:	19 81       	ldd	r17, Y+1	; 0x01
    27be:	2a 81       	ldd	r18, Y+2	; 0x02
    27c0:	3b 81       	ldd	r19, Y+3	; 0x03
    27c2:	8c 19       	sub	r24, r12
    27c4:	9d 09       	sbc	r25, r13
    27c6:	ae 09       	sbc	r26, r14
    27c8:	bf 09       	sbc	r27, r15
    27ca:	80 17       	cp	r24, r16
    27cc:	91 07       	cpc	r25, r17
    27ce:	a2 07       	cpc	r26, r18
    27d0:	b3 07       	cpc	r27, r19
    27d2:	e8 f4       	brcc	.+58     	; 0x280e <xTaskCheckForTimeOut+0xba>
    27d4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    27d6:	80 90 c0 30 	lds	r8, 0x30C0	; 0x8030c0 <xTickCount>
    27da:	90 90 c1 30 	lds	r9, 0x30C1	; 0x8030c1 <xTickCount+0x1>
    27de:	a0 90 c2 30 	lds	r10, 0x30C2	; 0x8030c2 <xTickCount+0x2>
    27e2:	b0 90 c3 30 	lds	r11, 0x30C3	; 0x8030c3 <xTickCount+0x3>
    27e6:	b5 01       	movw	r22, r10
    27e8:	a4 01       	movw	r20, r8
    27ea:	4c 19       	sub	r20, r12
    27ec:	5d 09       	sbc	r21, r13
    27ee:	6e 09       	sbc	r22, r14
    27f0:	7f 09       	sbc	r23, r15
    27f2:	04 1b       	sub	r16, r20
    27f4:	15 0b       	sbc	r17, r21
    27f6:	26 0b       	sbc	r18, r22
    27f8:	37 0b       	sbc	r19, r23
    27fa:	08 83       	st	Y, r16
    27fc:	19 83       	std	Y+1, r17	; 0x01
    27fe:	2a 83       	std	Y+2, r18	; 0x02
    2800:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2802:	0e 94 99 13 	call	0x2732	; 0x2732 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2806:	80 e0       	ldi	r24, 0x00	; 0
    2808:	03 c0       	rjmp	.+6      	; 0x2810 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    280a:	81 e0       	ldi	r24, 0x01	; 1
    280c:	01 c0       	rjmp	.+2      	; 0x2810 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    280e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2810:	0f 90       	pop	r0
    2812:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2814:	df 91       	pop	r29
    2816:	cf 91       	pop	r28
    2818:	1f 91       	pop	r17
    281a:	0f 91       	pop	r16
    281c:	ff 90       	pop	r15
    281e:	ef 90       	pop	r14
    2820:	df 90       	pop	r13
    2822:	cf 90       	pop	r12
    2824:	bf 90       	pop	r11
    2826:	af 90       	pop	r10
    2828:	9f 90       	pop	r9
    282a:	8f 90       	pop	r8
    282c:	08 95       	ret

0000282e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    282e:	81 e0       	ldi	r24, 0x01	; 1
    2830:	80 93 ba 30 	sts	0x30BA, r24	; 0x8030ba <xMissedYield>
    2834:	08 95       	ret

00002836 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2836:	00 97       	sbiw	r24, 0x00	; 0
    2838:	21 f4       	brne	.+8      	; 0x2842 <uxTaskGetStackHighWaterMark+0xc>
    283a:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    283e:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2842:	dc 01       	movw	r26, r24
    2844:	5b 96       	adiw	r26, 0x1b	; 27
    2846:	ed 91       	ld	r30, X+
    2848:	fc 91       	ld	r31, X
    284a:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    284c:	80 81       	ld	r24, Z
    284e:	81 31       	cpi	r24, 0x11	; 17
    2850:	41 f4       	brne	.+16     	; 0x2862 <uxTaskGetStackHighWaterMark+0x2c>
    2852:	31 96       	adiw	r30, 0x01	; 1
    2854:	80 e0       	ldi	r24, 0x00	; 0
    2856:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2858:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    285a:	21 91       	ld	r18, Z+
    285c:	21 31       	cpi	r18, 0x11	; 17
    285e:	e1 f3       	breq	.-8      	; 0x2858 <uxTaskGetStackHighWaterMark+0x22>
    2860:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2862:	80 e0       	ldi	r24, 0x00	; 0
    2864:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2866:	08 95       	ret

00002868 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2868:	80 91 18 31 	lds	r24, 0x3118	; 0x803118 <pxCurrentTCB>
    286c:	90 91 19 31 	lds	r25, 0x3119	; 0x803119 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2870:	08 95       	ret

00002872 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2872:	0f 93       	push	r16
    2874:	1f 93       	push	r17
    2876:	cf 93       	push	r28
    2878:	df 93       	push	r29
    287a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    287c:	22 8d       	ldd	r18, Z+26	; 0x1a
    287e:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2882:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2886:	5a 96       	adiw	r26, 0x1a	; 26
    2888:	8c 91       	ld	r24, X
    288a:	28 17       	cp	r18, r24
    288c:	08 f0       	brcs	.+2      	; 0x2890 <vTaskPriorityInherit+0x1e>
    288e:	41 c0       	rjmp	.+130    	; 0x2912 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2890:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2894:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    2898:	5a 96       	adiw	r26, 0x1a	; 26
    289a:	3c 91       	ld	r19, X
    289c:	84 e0       	ldi	r24, 0x04	; 4
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	a0 e0       	ldi	r26, 0x00	; 0
    28a2:	b0 e0       	ldi	r27, 0x00	; 0
    28a4:	83 1b       	sub	r24, r19
    28a6:	91 09       	sbc	r25, r1
    28a8:	a1 09       	sbc	r26, r1
    28aa:	b1 09       	sbc	r27, r1
    28ac:	86 87       	std	Z+14, r24	; 0x0e
    28ae:	97 87       	std	Z+15, r25	; 0x0f
    28b0:	a0 8b       	std	Z+16, r26	; 0x10
    28b2:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    28b4:	8b e0       	ldi	r24, 0x0B	; 11
    28b6:	28 9f       	mul	r18, r24
    28b8:	90 01       	movw	r18, r0
    28ba:	11 24       	eor	r1, r1
    28bc:	24 51       	subi	r18, 0x14	; 20
    28be:	3f 4c       	sbci	r19, 0xCF	; 207
    28c0:	84 85       	ldd	r24, Z+12	; 0x0c
    28c2:	95 85       	ldd	r25, Z+13	; 0x0d
    28c4:	82 17       	cp	r24, r18
    28c6:	93 07       	cpc	r25, r19
    28c8:	e9 f4       	brne	.+58     	; 0x2904 <vTaskPriorityInherit+0x92>
    28ca:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    28cc:	ef 01       	movw	r28, r30
    28ce:	22 96       	adiw	r28, 0x02	; 2
    28d0:	ce 01       	movw	r24, r28
    28d2:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    28d6:	e0 91 18 31 	lds	r30, 0x3118	; 0x803118 <pxCurrentTCB>
    28da:	f0 91 19 31 	lds	r31, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    28de:	82 8d       	ldd	r24, Z+26	; 0x1a
    28e0:	f8 01       	movw	r30, r16
    28e2:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    28e4:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    28e8:	98 17       	cp	r25, r24
    28ea:	10 f4       	brcc	.+4      	; 0x28f0 <vTaskPriorityInherit+0x7e>
    28ec:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    28f0:	fb e0       	ldi	r31, 0x0B	; 11
    28f2:	8f 9f       	mul	r24, r31
    28f4:	c0 01       	movw	r24, r0
    28f6:	11 24       	eor	r1, r1
    28f8:	be 01       	movw	r22, r28
    28fa:	84 51       	subi	r24, 0x14	; 20
    28fc:	9f 4c       	sbci	r25, 0xCF	; 207
    28fe:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsertEnd>
    2902:	07 c0       	rjmp	.+14     	; 0x2912 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2904:	a0 91 18 31 	lds	r26, 0x3118	; 0x803118 <pxCurrentTCB>
    2908:	b0 91 19 31 	lds	r27, 0x3119	; 0x803119 <pxCurrentTCB+0x1>
    290c:	5a 96       	adiw	r26, 0x1a	; 26
    290e:	8c 91       	ld	r24, X
    2910:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2912:	df 91       	pop	r29
    2914:	cf 91       	pop	r28
    2916:	1f 91       	pop	r17
    2918:	0f 91       	pop	r16
    291a:	08 95       	ret

0000291c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    291c:	0f 93       	push	r16
    291e:	1f 93       	push	r17
    2920:	cf 93       	push	r28
    2922:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2924:	00 97       	sbiw	r24, 0x00	; 0
    2926:	49 f1       	breq	.+82     	; 0x297a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2928:	fc 01       	movw	r30, r24
    292a:	32 8d       	ldd	r19, Z+26	; 0x1a
    292c:	27 a1       	ldd	r18, Z+39	; 0x27
    292e:	32 17       	cp	r19, r18
    2930:	21 f1       	breq	.+72     	; 0x297a <vTaskPriorityDisinherit+0x5e>
    2932:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2934:	8c 01       	movw	r16, r24
    2936:	0e 5f       	subi	r16, 0xFE	; 254
    2938:	1f 4f       	sbci	r17, 0xFF	; 255
    293a:	c8 01       	movw	r24, r16
    293c:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2940:	8f a1       	ldd	r24, Y+39	; 0x27
    2942:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2944:	44 e0       	ldi	r20, 0x04	; 4
    2946:	50 e0       	ldi	r21, 0x00	; 0
    2948:	60 e0       	ldi	r22, 0x00	; 0
    294a:	70 e0       	ldi	r23, 0x00	; 0
    294c:	48 1b       	sub	r20, r24
    294e:	51 09       	sbc	r21, r1
    2950:	61 09       	sbc	r22, r1
    2952:	71 09       	sbc	r23, r1
    2954:	4e 87       	std	Y+14, r20	; 0x0e
    2956:	5f 87       	std	Y+15, r21	; 0x0f
    2958:	68 8b       	std	Y+16, r22	; 0x10
    295a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    295c:	90 91 be 30 	lds	r25, 0x30BE	; 0x8030be <uxTopReadyPriority>
    2960:	98 17       	cp	r25, r24
    2962:	10 f4       	brcc	.+4      	; 0x2968 <vTaskPriorityDisinherit+0x4c>
    2964:	80 93 be 30 	sts	0x30BE, r24	; 0x8030be <uxTopReadyPriority>
    2968:	fb e0       	ldi	r31, 0x0B	; 11
    296a:	8f 9f       	mul	r24, r31
    296c:	c0 01       	movw	r24, r0
    296e:	11 24       	eor	r1, r1
    2970:	b8 01       	movw	r22, r16
    2972:	84 51       	subi	r24, 0x14	; 20
    2974:	9f 4c       	sbci	r25, 0xCF	; 207
    2976:	0e 94 5f 0a 	call	0x14be	; 0x14be <vListInsertEnd>
			}
		}
	}
    297a:	df 91       	pop	r29
    297c:	cf 91       	pop	r28
    297e:	1f 91       	pop	r17
    2980:	0f 91       	pop	r16
    2982:	08 95       	ret

00002984 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2984:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2986:	e8 81       	ld	r30, Y
    2988:	f9 81       	ldd	r31, Y+1	; 0x01
    298a:	01 90       	ld	r0, Z+
    298c:	f0 81       	ld	r31, Z
    298e:	e0 2d       	mov	r30, r0
    2990:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2992:	1a 82       	std	Y+2, r1	; 0x02
    2994:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2996:	6f ef       	ldi	r22, 0xFF	; 255
    2998:	7f ef       	ldi	r23, 0xFF	; 255
    299a:	cb 01       	movw	r24, r22
    299c:	0e 94 a5 12 	call	0x254a	; 0x254a <vTaskDelay>
    29a0:	fa cf       	rjmp	.-12     	; 0x2996 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000029a2 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    29a2:	fc 01       	movw	r30, r24
    29a4:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    29a6:	65 87       	std	Z+13, r22	; 0x0d
    29a8:	08 95       	ret

000029aa <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    29aa:	4f 92       	push	r4
    29ac:	5f 92       	push	r5
    29ae:	6f 92       	push	r6
    29b0:	7f 92       	push	r7
    29b2:	8f 92       	push	r8
    29b4:	9f 92       	push	r9
    29b6:	af 92       	push	r10
    29b8:	bf 92       	push	r11
    29ba:	cf 92       	push	r12
    29bc:	df 92       	push	r13
    29be:	ef 92       	push	r14
    29c0:	ff 92       	push	r15
    29c2:	0f 93       	push	r16
    29c4:	1f 93       	push	r17
    29c6:	cf 93       	push	r28
    29c8:	df 93       	push	r29
    29ca:	cd b7       	in	r28, 0x3d	; 61
    29cc:	de b7       	in	r29, 0x3e	; 62
    29ce:	2a 97       	sbiw	r28, 0x0a	; 10
    29d0:	cd bf       	out	0x3d, r28	; 61
    29d2:	de bf       	out	0x3e, r29	; 62
    29d4:	4c 01       	movw	r8, r24
    29d6:	29 01       	movw	r4, r18
    29d8:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    29da:	8f e2       	ldi	r24, 0x2F	; 47
    29dc:	90 e2       	ldi	r25, 0x20	; 32
    29de:	f4 01       	movw	r30, r8
    29e0:	80 83       	st	Z, r24
    29e2:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    29e4:	fb 01       	movw	r30, r22
    29e6:	80 81       	ld	r24, Z
    29e8:	88 23       	and	r24, r24
    29ea:	69 f0       	breq	.+26     	; 0x2a06 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    29ec:	de 01       	movw	r26, r28
    29ee:	11 96       	adiw	r26, 0x01	; 1
    29f0:	31 96       	adiw	r30, 0x01	; 1
    29f2:	90 e0       	ldi	r25, 0x00	; 0
    29f4:	02 c0       	rjmp	.+4      	; 0x29fa <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    29f6:	99 30       	cpi	r25, 0x09	; 9
    29f8:	39 f0       	breq	.+14     	; 0x2a08 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    29fa:	9f 5f       	subi	r25, 0xFF	; 255
    29fc:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    29fe:	81 91       	ld	r24, Z+
    2a00:	81 11       	cpse	r24, r1
    2a02:	f9 cf       	rjmp	.-14     	; 0x29f6 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2a04:	01 c0       	rjmp	.+2      	; 0x2a08 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2a06:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2a08:	e1 e0       	ldi	r30, 0x01	; 1
    2a0a:	f0 e0       	ldi	r31, 0x00	; 0
    2a0c:	ec 0f       	add	r30, r28
    2a0e:	fd 1f       	adc	r31, r29
    2a10:	e9 0f       	add	r30, r25
    2a12:	f1 1d       	adc	r31, r1
    2a14:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2a16:	74 01       	movw	r14, r8
    2a18:	f2 e0       	ldi	r31, 0x02	; 2
    2a1a:	ef 0e       	add	r14, r31
    2a1c:	f1 1c       	adc	r15, r1
    2a1e:	a1 2c       	mov	r10, r1
    2a20:	b1 2c       	mov	r11, r1
    2a22:	c1 2c       	mov	r12, r1
    2a24:	d1 2c       	mov	r13, r1
    2a26:	04 2f       	mov	r16, r20
    2a28:	94 01       	movw	r18, r8
    2a2a:	a2 01       	movw	r20, r4
    2a2c:	be 01       	movw	r22, r28
    2a2e:	6f 5f       	subi	r22, 0xFF	; 255
    2a30:	7f 4f       	sbci	r23, 0xFF	; 255
    2a32:	8a e9       	ldi	r24, 0x9A	; 154
    2a34:	92 e0       	ldi	r25, 0x02	; 2
    2a36:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2a3a:	f4 01       	movw	r30, r8
    2a3c:	66 82       	std	Z+6, r6	; 0x06
    2a3e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2a40:	40 86       	std	Z+8, r4	; 0x08
    2a42:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2a44:	20 91 1a 31 	lds	r18, 0x311A	; 0x80311a <last_created_task_pointer>
    2a48:	30 91 1b 31 	lds	r19, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2a4c:	24 83       	std	Z+4, r18	; 0x04
    2a4e:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2a50:	80 92 1a 31 	sts	0x311A, r8	; 0x80311a <last_created_task_pointer>
    2a54:	90 92 1b 31 	sts	0x311B, r9	; 0x80311b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2a58:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2a5a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2a5c:	40 90 2c 31 	lds	r4, 0x312C	; 0x80312c <portStackTopForTask>
    2a60:	50 90 2d 31 	lds	r5, 0x312D	; 0x80312d <portStackTopForTask+0x1>
    2a64:	ff ef       	ldi	r31, 0xFF	; 255
    2a66:	4f 1a       	sub	r4, r31
    2a68:	5f 0a       	sbc	r5, r31
    2a6a:	40 92 2c 31 	sts	0x312C, r4	; 0x80312c <portStackTopForTask>
    2a6e:	50 92 2d 31 	sts	0x312D, r5	; 0x80312d <portStackTopForTask+0x1>
    2a72:	f4 01       	movw	r30, r8
    2a74:	42 86       	std	Z+10, r4	; 0x0a
    2a76:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2a78:	16 86       	std	Z+14, r1	; 0x0e
    2a7a:	17 86       	std	Z+15, r1	; 0x0f
    2a7c:	10 8a       	std	Z+16, r1	; 0x10
    2a7e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2a80:	61 14       	cp	r6, r1
    2a82:	71 04       	cpc	r7, r1
    2a84:	09 f4       	brne	.+2      	; 0x2a88 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2a86:	44 c0       	rjmp	.+136    	; 0x2b10 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2a88:	81 30       	cpi	r24, 0x01	; 1
    2a8a:	79 f5       	brne	.+94     	; 0x2aea <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2a8c:	6a e0       	ldi	r22, 0x0A	; 10
    2a8e:	c3 01       	movw	r24, r6
    2a90:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2a94:	7c 01       	movw	r14, r24
    2a96:	61 e8       	ldi	r22, 0x81	; 129
    2a98:	74 e0       	ldi	r23, 0x04	; 4
    2a9a:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2a9e:	be 01       	movw	r22, r28
    2aa0:	6f 5f       	subi	r22, 0xFF	; 255
    2aa2:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa4:	c7 01       	movw	r24, r14
    2aa6:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2aaa:	6a e0       	ldi	r22, 0x0A	; 10
    2aac:	c7 01       	movw	r24, r14
    2aae:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2ab2:	7c 01       	movw	r14, r24
    2ab4:	68 e7       	ldi	r22, 0x78	; 120
    2ab6:	74 e0       	ldi	r23, 0x04	; 4
    2ab8:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2abc:	6a e0       	ldi	r22, 0x0A	; 10
    2abe:	c7 01       	movw	r24, r14
    2ac0:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2ac4:	7c 01       	movw	r14, r24
    2ac6:	6a e6       	ldi	r22, 0x6A	; 106
    2ac8:	74 e0       	ldi	r23, 0x04	; 4
    2aca:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2ace:	63 e0       	ldi	r22, 0x03	; 3
    2ad0:	c7 01       	movw	r24, r14
    2ad2:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2ad6:	b2 01       	movw	r22, r4
    2ad8:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZN8emstreamlsEj>
    2adc:	62 e0       	ldi	r22, 0x02	; 2
    2ade:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2ae2:	66 e0       	ldi	r22, 0x06	; 6
    2ae4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2ae8:	13 c0       	rjmp	.+38     	; 0x2b10 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2aea:	6a e0       	ldi	r22, 0x0A	; 10
    2aec:	c3 01       	movw	r24, r6
    2aee:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2af2:	4c 01       	movw	r8, r24
    2af4:	65 e5       	ldi	r22, 0x55	; 85
    2af6:	74 e0       	ldi	r23, 0x04	; 4
    2af8:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2afc:	be 01       	movw	r22, r28
    2afe:	6f 5f       	subi	r22, 0xFF	; 255
    2b00:	7f 4f       	sbci	r23, 0xFF	; 255
    2b02:	c4 01       	movw	r24, r8
    2b04:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2b08:	66 e0       	ldi	r22, 0x06	; 6
    2b0a:	c4 01       	movw	r24, r8
    2b0c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2b10:	2a 96       	adiw	r28, 0x0a	; 10
    2b12:	cd bf       	out	0x3d, r28	; 61
    2b14:	de bf       	out	0x3e, r29	; 62
    2b16:	df 91       	pop	r29
    2b18:	cf 91       	pop	r28
    2b1a:	1f 91       	pop	r17
    2b1c:	0f 91       	pop	r16
    2b1e:	ff 90       	pop	r15
    2b20:	ef 90       	pop	r14
    2b22:	df 90       	pop	r13
    2b24:	cf 90       	pop	r12
    2b26:	bf 90       	pop	r11
    2b28:	af 90       	pop	r10
    2b2a:	9f 90       	pop	r9
    2b2c:	8f 90       	pop	r8
    2b2e:	7f 90       	pop	r7
    2b30:	6f 90       	pop	r6
    2b32:	5f 90       	pop	r5
    2b34:	4f 90       	pop	r4
    2b36:	08 95       	ret

00002b38 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2b38:	cf 92       	push	r12
    2b3a:	df 92       	push	r13
    2b3c:	ef 92       	push	r14
    2b3e:	ff 92       	push	r15
    2b40:	0f 93       	push	r16
    2b42:	1f 93       	push	r17
    2b44:	cf 93       	push	r28
    2b46:	df 93       	push	r29
    2b48:	ec 01       	movw	r28, r24
    2b4a:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b50:	0e 94 a8 10 	call	0x2150	; 0x2150 <pcTaskGetTaskName>
    2b54:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2b56:	6a e0       	ldi	r22, 0x0A	; 10
    2b58:	c7 01       	movw	r24, r14
    2b5a:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2b5e:	8c 01       	movw	r16, r24
    2b60:	64 e9       	ldi	r22, 0x94	; 148
    2b62:	74 e0       	ldi	r23, 0x04	; 4
    2b64:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2b68:	6a e0       	ldi	r22, 0x0A	; 10
    2b6a:	c8 01       	movw	r24, r16
    2b6c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2b70:	8c 01       	movw	r16, r24
    2b72:	6d e8       	ldi	r22, 0x8D	; 141
    2b74:	74 e0       	ldi	r23, 0x04	; 4
    2b76:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2b7a:	b6 01       	movw	r22, r12
    2b7c:	c8 01       	movw	r24, r16
    2b7e:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2b82:	6a e0       	ldi	r22, 0x0A	; 10
    2b84:	c8 01       	movw	r24, r16
    2b86:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2b8a:	8c 01       	movw	r16, r24
    2b8c:	67 e8       	ldi	r22, 0x87	; 135
    2b8e:	74 e0       	ldi	r23, 0x04	; 4
    2b90:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2b94:	66 e0       	ldi	r22, 0x06	; 6
    2b96:	c8 01       	movw	r24, r16
    2b98:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2b9c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b9e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2ba0:	e8 85       	ldd	r30, Y+8	; 0x08
    2ba2:	f9 85       	ldd	r31, Y+9	; 0x09
    2ba4:	01 e1       	ldi	r16, 0x11	; 17
    2ba6:	21 e0       	ldi	r18, 0x01	; 1
    2ba8:	a7 01       	movw	r20, r14
    2baa:	bc 01       	movw	r22, r24
    2bac:	8e 1b       	sub	r24, r30
    2bae:	9f 0b       	sbc	r25, r31
    2bb0:	0e 94 9e 18 	call	0x313c	; 0x313c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2bb4:	8c 81       	ldd	r24, Y+4	; 0x04
    2bb6:	9d 81       	ldd	r25, Y+5	; 0x05
    2bb8:	00 97       	sbiw	r24, 0x00	; 0
    2bba:	19 f0       	breq	.+6      	; 0x2bc2 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2bbc:	b7 01       	movw	r22, r14
    2bbe:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2bc2:	df 91       	pop	r29
    2bc4:	cf 91       	pop	r28
    2bc6:	1f 91       	pop	r17
    2bc8:	0f 91       	pop	r16
    2bca:	ff 90       	pop	r15
    2bcc:	ef 90       	pop	r14
    2bce:	df 90       	pop	r13
    2bd0:	cf 90       	pop	r12
    2bd2:	08 95       	ret

00002bd4 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2bd4:	0f 93       	push	r16
    2bd6:	1f 93       	push	r17
    2bd8:	cf 93       	push	r28
    2bda:	df 93       	push	r29
    2bdc:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2bde:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    2be2:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2be6:	00 97       	sbiw	r24, 0x00	; 0
    2be8:	19 f0       	breq	.+6      	; 0x2bf0 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2bea:	be 01       	movw	r22, r28
    2bec:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2bf0:	6a e0       	ldi	r22, 0x0A	; 10
    2bf2:	ce 01       	movw	r24, r28
    2bf4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2bf8:	8c 01       	movw	r16, r24
    2bfa:	6a ea       	ldi	r22, 0xAA	; 170
    2bfc:	74 e0       	ldi	r23, 0x04	; 4
    2bfe:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2c02:	6a e0       	ldi	r22, 0x0A	; 10
    2c04:	c8 01       	movw	r24, r16
    2c06:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2c0a:	8c 01       	movw	r16, r24
    2c0c:	6f e9       	ldi	r22, 0x9F	; 159
    2c0e:	74 e0       	ldi	r23, 0x04	; 4
    2c10:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2c14:	6a e0       	ldi	r22, 0x0A	; 10
    2c16:	c8 01       	movw	r24, r16
    2c18:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2c1c:	8c 01       	movw	r16, r24
    2c1e:	69 e9       	ldi	r22, 0x99	; 153
    2c20:	74 e0       	ldi	r23, 0x04	; 4
    2c22:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2c26:	66 e0       	ldi	r22, 0x06	; 6
    2c28:	c8 01       	movw	r24, r16
    2c2a:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2c2e:	80 91 2c 31 	lds	r24, 0x312C	; 0x80312c <portStackTopForTask>
    2c32:	90 91 2d 31 	lds	r25, 0x312D	; 0x80312d <portStackTopForTask+0x1>
    2c36:	bc 01       	movw	r22, r24
    2c38:	6f 5f       	subi	r22, 0xFF	; 255
    2c3a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c3c:	01 e1       	ldi	r16, 0x11	; 17
    2c3e:	21 e0       	ldi	r18, 0x01	; 1
    2c40:	ae 01       	movw	r20, r28
    2c42:	83 56       	subi	r24, 0x63	; 99
    2c44:	91 09       	sbc	r25, r1
    2c46:	0e 94 9e 18 	call	0x313c	; 0x313c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2c4a:	df 91       	pop	r29
    2c4c:	cf 91       	pop	r28
    2c4e:	1f 91       	pop	r17
    2c50:	0f 91       	pop	r16
    2c52:	08 95       	ret

00002c54 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2c54:	8f 92       	push	r8
    2c56:	9f 92       	push	r9
    2c58:	af 92       	push	r10
    2c5a:	bf 92       	push	r11
    2c5c:	cf 92       	push	r12
    2c5e:	df 92       	push	r13
    2c60:	ef 92       	push	r14
    2c62:	ff 92       	push	r15
    2c64:	0f 93       	push	r16
    2c66:	1f 93       	push	r17
    2c68:	cf 93       	push	r28
    2c6a:	df 93       	push	r29
    2c6c:	ec 01       	movw	r28, r24
    2c6e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2c70:	8a 81       	ldd	r24, Y+2	; 0x02
    2c72:	9b 81       	ldd	r25, Y+3	; 0x03
    2c74:	0e 94 a8 10 	call	0x2150	; 0x2150 <pcTaskGetTaskName>
    2c78:	bc 01       	movw	r22, r24
    2c7a:	c8 01       	movw	r24, r16
    2c7c:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2c80:	d8 01       	movw	r26, r16
    2c82:	ed 91       	ld	r30, X+
    2c84:	fc 91       	ld	r31, X
    2c86:	02 80       	ldd	r0, Z+2	; 0x02
    2c88:	f3 81       	ldd	r31, Z+3	; 0x03
    2c8a:	e0 2d       	mov	r30, r0
    2c8c:	69 e0       	ldi	r22, 0x09	; 9
    2c8e:	c8 01       	movw	r24, r16
    2c90:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2c92:	8a 81       	ldd	r24, Y+2	; 0x02
    2c94:	9b 81       	ldd	r25, Y+3	; 0x03
    2c96:	0e 94 a8 10 	call	0x2150	; 0x2150 <pcTaskGetTaskName>
    2c9a:	fc 01       	movw	r30, r24
    2c9c:	01 90       	ld	r0, Z+
    2c9e:	00 20       	and	r0, r0
    2ca0:	e9 f7       	brne	.-6      	; 0x2c9c <_ZN8frt_task12print_statusER8emstream+0x48>
    2ca2:	31 97       	sbiw	r30, 0x01	; 1
    2ca4:	e8 1b       	sub	r30, r24
    2ca6:	f9 0b       	sbc	r31, r25
    2ca8:	38 97       	sbiw	r30, 0x08	; 8
    2caa:	48 f4       	brcc	.+18     	; 0x2cbe <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2cac:	d8 01       	movw	r26, r16
    2cae:	ed 91       	ld	r30, X+
    2cb0:	fc 91       	ld	r31, X
    2cb2:	02 80       	ldd	r0, Z+2	; 0x02
    2cb4:	f3 81       	ldd	r31, Z+3	; 0x03
    2cb6:	e0 2d       	mov	r30, r0
    2cb8:	69 e0       	ldi	r22, 0x09	; 9
    2cba:	c8 01       	movw	r24, r16
    2cbc:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2cbe:	ce 84       	ldd	r12, Y+14	; 0x0e
    2cc0:	df 84       	ldd	r13, Y+15	; 0x0f
    2cc2:	e8 88       	ldd	r14, Y+16	; 0x10
    2cc4:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2cc6:	a8 84       	ldd	r10, Y+8	; 0x08
    2cc8:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2cca:	8a 81       	ldd	r24, Y+2	; 0x02
    2ccc:	9b 81       	ldd	r25, Y+3	; 0x03
    2cce:	0e 94 1b 14 	call	0x2836	; 0x2836 <uxTaskGetStackHighWaterMark>
    2cd2:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2cd4:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2cd6:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd8:	9b 81       	ldd	r25, Y+3	; 0x03
    2cda:	0e 94 53 10 	call	0x20a6	; 0x20a6 <uxTaskPriorityGet>
    2cde:	68 2f       	mov	r22, r24
    2ce0:	c8 01       	movw	r24, r16
    2ce2:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    2ce6:	6a e0       	ldi	r22, 0x0A	; 10
    2ce8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2cec:	ec 01       	movw	r28, r24
    2cee:	6f e1       	ldi	r22, 0x1F	; 31
    2cf0:	75 e0       	ldi	r23, 0x05	; 5
    2cf2:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
			<< get_state ()
    2cf6:	68 2d       	mov	r22, r8
    2cf8:	ce 01       	movw	r24, r28
    2cfa:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2cfe:	6a e0       	ldi	r22, 0x0A	; 10
    2d00:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2d04:	ec 01       	movw	r28, r24
    2d06:	6d e1       	ldi	r22, 0x1D	; 29
    2d08:	75 e0       	ldi	r23, 0x05	; 5
    2d0a:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2d0e:	69 2d       	mov	r22, r9
    2d10:	ce 01       	movw	r24, r28
    2d12:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    2d16:	6a e0       	ldi	r22, 0x0A	; 10
    2d18:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2d1c:	ec 01       	movw	r28, r24
    2d1e:	6b e1       	ldi	r22, 0x1B	; 27
    2d20:	75 e0       	ldi	r23, 0x05	; 5
    2d22:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2d26:	b5 01       	movw	r22, r10
    2d28:	ce 01       	movw	r24, r28
    2d2a:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZN8emstreamlsEj>
    2d2e:	6a e0       	ldi	r22, 0x0A	; 10
    2d30:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2d34:	ec 01       	movw	r28, r24
    2d36:	69 e1       	ldi	r22, 0x19	; 25
    2d38:	75 e0       	ldi	r23, 0x05	; 5
    2d3a:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2d3e:	6a e0       	ldi	r22, 0x0A	; 10
    2d40:	ce 01       	movw	r24, r28
    2d42:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2d46:	ec 01       	movw	r28, r24
    2d48:	67 e1       	ldi	r22, 0x17	; 23
    2d4a:	75 e0       	ldi	r23, 0x05	; 5
    2d4c:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2d50:	b7 01       	movw	r22, r14
    2d52:	a6 01       	movw	r20, r12
    2d54:	ce 01       	movw	r24, r28
    2d56:	0e 94 cf 1a 	call	0x359e	; 0x359e <_ZN8emstreamlsEm>
}
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	1f 91       	pop	r17
    2d60:	0f 91       	pop	r16
    2d62:	ff 90       	pop	r15
    2d64:	ef 90       	pop	r14
    2d66:	df 90       	pop	r13
    2d68:	cf 90       	pop	r12
    2d6a:	bf 90       	pop	r11
    2d6c:	af 90       	pop	r10
    2d6e:	9f 90       	pop	r9
    2d70:	8f 90       	pop	r8
    2d72:	08 95       	ret

00002d74 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2d74:	cf 93       	push	r28
    2d76:	df 93       	push	r29
    2d78:	ec 01       	movw	r28, r24
    2d7a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2d7c:	db 01       	movw	r26, r22
    2d7e:	ed 91       	ld	r30, X+
    2d80:	fc 91       	ld	r31, X
    2d82:	02 80       	ldd	r0, Z+2	; 0x02
    2d84:	f3 81       	ldd	r31, Z+3	; 0x03
    2d86:	e0 2d       	mov	r30, r0
    2d88:	be 01       	movw	r22, r28
    2d8a:	19 95       	eicall
	return (ser_dev);
}
    2d8c:	ce 01       	movw	r24, r28
    2d8e:	df 91       	pop	r29
    2d90:	cf 91       	pop	r28
    2d92:	08 95       	ret

00002d94 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2d94:	0f 93       	push	r16
    2d96:	1f 93       	push	r17
    2d98:	cf 93       	push	r28
    2d9a:	df 93       	push	r29
    2d9c:	ec 01       	movw	r28, r24
    2d9e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2da0:	bc 01       	movw	r22, r24
    2da2:	c8 01       	movw	r24, r16
    2da4:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_ZlsR8emstreamR8frt_task>
    2da8:	66 e0       	ldi	r22, 0x06	; 6
    2daa:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2dae:	8c 81       	ldd	r24, Y+4	; 0x04
    2db0:	9d 81       	ldd	r25, Y+5	; 0x05
    2db2:	00 97       	sbiw	r24, 0x00	; 0
    2db4:	19 f0       	breq	.+6      	; 0x2dbc <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2db6:	b8 01       	movw	r22, r16
    2db8:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2dbc:	df 91       	pop	r29
    2dbe:	cf 91       	pop	r28
    2dc0:	1f 91       	pop	r17
    2dc2:	0f 91       	pop	r16
    2dc4:	08 95       	ret

00002dc6 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2dc6:	0f 93       	push	r16
    2dc8:	1f 93       	push	r17
    2dca:	cf 93       	push	r28
    2dcc:	df 93       	push	r29
    2dce:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2dd0:	6a e0       	ldi	r22, 0x0A	; 10
    2dd2:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2dd6:	8c 01       	movw	r16, r24
    2dd8:	6c e0       	ldi	r22, 0x0C	; 12
    2dda:	75 e0       	ldi	r23, 0x05	; 5
    2ddc:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2de0:	6a e0       	ldi	r22, 0x0A	; 10
    2de2:	c8 01       	movw	r24, r16
    2de4:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2de8:	8c 01       	movw	r16, r24
    2dea:	65 e0       	ldi	r22, 0x05	; 5
    2dec:	75 e0       	ldi	r23, 0x05	; 5
    2dee:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2df2:	66 e0       	ldi	r22, 0x06	; 6
    2df4:	c8 01       	movw	r24, r16
    2df6:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2dfa:	6a e0       	ldi	r22, 0x0A	; 10
    2dfc:	ce 01       	movw	r24, r28
    2dfe:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2e02:	8c 01       	movw	r16, r24
    2e04:	64 ef       	ldi	r22, 0xF4	; 244
    2e06:	74 e0       	ldi	r23, 0x04	; 4
    2e08:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2e0c:	6a e0       	ldi	r22, 0x0A	; 10
    2e0e:	c8 01       	movw	r24, r16
    2e10:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2e14:	8c 01       	movw	r16, r24
    2e16:	68 ee       	ldi	r22, 0xE8	; 232
    2e18:	74 e0       	ldi	r23, 0x04	; 4
    2e1a:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2e1e:	6a e0       	ldi	r22, 0x0A	; 10
    2e20:	c8 01       	movw	r24, r16
    2e22:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2e26:	8c 01       	movw	r16, r24
    2e28:	62 ee       	ldi	r22, 0xE2	; 226
    2e2a:	74 e0       	ldi	r23, 0x04	; 4
    2e2c:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2e30:	66 e0       	ldi	r22, 0x06	; 6
    2e32:	c8 01       	movw	r24, r16
    2e34:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2e38:	6a e0       	ldi	r22, 0x0A	; 10
    2e3a:	ce 01       	movw	r24, r28
    2e3c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2e40:	8c 01       	movw	r16, r24
    2e42:	61 ed       	ldi	r22, 0xD1	; 209
    2e44:	74 e0       	ldi	r23, 0x04	; 4
    2e46:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2e4a:	6a e0       	ldi	r22, 0x0A	; 10
    2e4c:	c8 01       	movw	r24, r16
    2e4e:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2e52:	8c 01       	movw	r16, r24
    2e54:	65 ec       	ldi	r22, 0xC5	; 197
    2e56:	74 e0       	ldi	r23, 0x04	; 4
    2e58:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2e5c:	6a e0       	ldi	r22, 0x0A	; 10
    2e5e:	c8 01       	movw	r24, r16
    2e60:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2e64:	8c 01       	movw	r16, r24
    2e66:	6f eb       	ldi	r22, 0xBF	; 191
    2e68:	74 e0       	ldi	r23, 0x04	; 4
    2e6a:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2e6e:	66 e0       	ldi	r22, 0x06	; 6
    2e70:	c8 01       	movw	r24, r16
    2e72:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2e76:	80 91 1a 31 	lds	r24, 0x311A	; 0x80311a <last_created_task_pointer>
    2e7a:	90 91 1b 31 	lds	r25, 0x311B	; 0x80311b <last_created_task_pointer+0x1>
    2e7e:	00 97       	sbiw	r24, 0x00	; 0
    2e80:	19 f0       	breq	.+6      	; 0x2e88 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2e82:	be 01       	movw	r22, r28
    2e84:	0e 94 ca 16 	call	0x2d94	; 0x2d94 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2e88:	0e 94 b0 10 	call	0x2160	; 0x2160 <xTaskGetIdleTaskHandle>
    2e8c:	0e 94 1b 14 	call	0x2836	; 0x2836 <uxTaskGetStackHighWaterMark>
    2e90:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2e92:	6a e0       	ldi	r22, 0x0A	; 10
    2e94:	ce 01       	movw	r24, r28
    2e96:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2e9a:	ec 01       	movw	r28, r24
    2e9c:	64 eb       	ldi	r22, 0xB4	; 180
    2e9e:	74 e0       	ldi	r23, 0x04	; 4
    2ea0:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2ea4:	61 2f       	mov	r22, r17
    2ea6:	ce 01       	movw	r24, r28
    2ea8:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2eac:	6a e0       	ldi	r22, 0x0A	; 10
    2eae:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2eb2:	ec 01       	movw	r28, r24
    2eb4:	62 eb       	ldi	r22, 0xB2	; 178
    2eb6:	74 e0       	ldi	r23, 0x04	; 4
    2eb8:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    2ebc:	64 e6       	ldi	r22, 0x64	; 100
    2ebe:	70 e0       	ldi	r23, 0x00	; 0
    2ec0:	ce 01       	movw	r24, r28
    2ec2:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZN8emstreamlsEj>
    2ec6:	6a e0       	ldi	r22, 0x0A	; 10
    2ec8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    2ecc:	ec 01       	movw	r28, r24
    2ece:	6f ea       	ldi	r22, 0xAF	; 175
    2ed0:	74 e0       	ldi	r23, 0x04	; 4
    2ed2:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2ed6:	66 e0       	ldi	r22, 0x06	; 6
    2ed8:	ce 01       	movw	r24, r28
    2eda:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
}
    2ede:	df 91       	pop	r29
    2ee0:	cf 91       	pop	r28
    2ee2:	1f 91       	pop	r17
    2ee4:	0f 91       	pop	r16
    2ee6:	08 95       	ret

00002ee8 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2ee8:	0f 93       	push	r16
    2eea:	cf 93       	push	r28
    2eec:	df 93       	push	r29
    2eee:	1f 92       	push	r1
    2ef0:	cd b7       	in	r28, 0x3d	; 61
    2ef2:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2ef4:	00 e0       	ldi	r16, 0x00	; 0
    2ef6:	2f ef       	ldi	r18, 0xFF	; 255
    2ef8:	3f ef       	ldi	r19, 0xFF	; 255
    2efa:	a9 01       	movw	r20, r18
    2efc:	be 01       	movw	r22, r28
    2efe:	6f 5f       	subi	r22, 0xFF	; 255
    2f00:	7f 4f       	sbci	r23, 0xFF	; 255
    2f02:	fc 01       	movw	r30, r24
    2f04:	80 85       	ldd	r24, Z+8	; 0x08
    2f06:	91 85       	ldd	r25, Z+9	; 0x09
    2f08:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <xQueueGenericReceive>
    2f0c:	81 30       	cpi	r24, 0x01	; 1
    2f0e:	19 f4       	brne	.+6      	; 0x2f16 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2f10:	89 81       	ldd	r24, Y+1	; 0x01
    2f12:	90 e0       	ldi	r25, 0x00	; 0
    2f14:	02 c0       	rjmp	.+4      	; 0x2f1a <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2f16:	8f ef       	ldi	r24, 0xFF	; 255
    2f18:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2f1a:	0f 90       	pop	r0
    2f1c:	df 91       	pop	r29
    2f1e:	cf 91       	pop	r28
    2f20:	0f 91       	pop	r16
    2f22:	08 95       	ret

00002f24 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2f24:	fc 01       	movw	r30, r24
    2f26:	80 85       	ldd	r24, Z+8	; 0x08
    2f28:	91 85       	ldd	r25, Z+9	; 0x09
    2f2a:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <uxQueueMessagesWaiting>
    2f2e:	91 e0       	ldi	r25, 0x01	; 1
    2f30:	81 11       	cpse	r24, r1
    2f32:	01 c0       	rjmp	.+2      	; 0x2f36 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2f34:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2f36:	89 2f       	mov	r24, r25
    2f38:	08 95       	ret

00002f3a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2f3a:	0f 93       	push	r16
    2f3c:	cf 93       	push	r28
    2f3e:	df 93       	push	r29
    2f40:	1f 92       	push	r1
    2f42:	cd b7       	in	r28, 0x3d	; 61
    2f44:	de b7       	in	r29, 0x3e	; 62
    2f46:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2f48:	fc 01       	movw	r30, r24
    2f4a:	22 85       	ldd	r18, Z+10	; 0x0a
    2f4c:	33 85       	ldd	r19, Z+11	; 0x0b
    2f4e:	44 85       	ldd	r20, Z+12	; 0x0c
    2f50:	55 85       	ldd	r21, Z+13	; 0x0d
    2f52:	00 e0       	ldi	r16, 0x00	; 0
    2f54:	be 01       	movw	r22, r28
    2f56:	6f 5f       	subi	r22, 0xFF	; 255
    2f58:	7f 4f       	sbci	r23, 0xFF	; 255
    2f5a:	80 85       	ldd	r24, Z+8	; 0x08
    2f5c:	91 85       	ldd	r25, Z+9	; 0x09
    2f5e:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <xQueueGenericSend>
    2f62:	91 e0       	ldi	r25, 0x01	; 1
    2f64:	81 11       	cpse	r24, r1
    2f66:	01 c0       	rjmp	.+2      	; 0x2f6a <_ZN14frt_text_queue7putcharEc+0x30>
    2f68:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2f6a:	89 2f       	mov	r24, r25
    2f6c:	0f 90       	pop	r0
    2f6e:	df 91       	pop	r29
    2f70:	cf 91       	pop	r28
    2f72:	0f 91       	pop	r16
    2f74:	08 95       	ret

00002f76 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2f76:	8f 92       	push	r8
    2f78:	9f 92       	push	r9
    2f7a:	bf 92       	push	r11
    2f7c:	cf 92       	push	r12
    2f7e:	df 92       	push	r13
    2f80:	ef 92       	push	r14
    2f82:	ff 92       	push	r15
    2f84:	0f 93       	push	r16
    2f86:	1f 93       	push	r17
    2f88:	cf 93       	push	r28
    2f8a:	df 93       	push	r29
    2f8c:	ec 01       	movw	r28, r24
    2f8e:	b6 2e       	mov	r11, r22
    2f90:	4a 01       	movw	r8, r20
    2f92:	68 01       	movw	r12, r16
    2f94:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2f96:	0e 94 0f 1a 	call	0x341e	; 0x341e <_ZN8emstreamC1Ev>
    2f9a:	87 e3       	ldi	r24, 0x37	; 55
    2f9c:	90 e2       	ldi	r25, 0x20	; 32
    2f9e:	88 83       	st	Y, r24
    2fa0:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2fa2:	8e 86       	std	Y+14, r8	; 0x0e
    2fa4:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2fa6:	40 e0       	ldi	r20, 0x00	; 0
    2fa8:	61 e0       	ldi	r22, 0x01	; 1
    2faa:	8b 2d       	mov	r24, r11
    2fac:	0e 94 66 0d 	call	0x1acc	; 0x1acc <xQueueGenericCreate>
    2fb0:	88 87       	std	Y+8, r24	; 0x08
    2fb2:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2fb4:	ca 86       	std	Y+10, r12	; 0x0a
    2fb6:	db 86       	std	Y+11, r13	; 0x0b
    2fb8:	ec 86       	std	Y+12, r14	; 0x0c
    2fba:	fd 86       	std	Y+13, r15	; 0x0d
}
    2fbc:	df 91       	pop	r29
    2fbe:	cf 91       	pop	r28
    2fc0:	1f 91       	pop	r17
    2fc2:	0f 91       	pop	r16
    2fc4:	ff 90       	pop	r15
    2fc6:	ef 90       	pop	r14
    2fc8:	df 90       	pop	r13
    2fca:	cf 90       	pop	r12
    2fcc:	bf 90       	pop	r11
    2fce:	9f 90       	pop	r9
    2fd0:	8f 90       	pop	r8
    2fd2:	08 95       	ret

00002fd4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2fd4:	cf 92       	push	r12
    2fd6:	df 92       	push	r13
    2fd8:	ef 92       	push	r14
    2fda:	ff 92       	push	r15
    2fdc:	cf 93       	push	r28
    2fde:	df 93       	push	r29
    2fe0:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2fe2:	68 81       	ld	r22, Y
    2fe4:	79 81       	ldd	r23, Y+1	; 0x01
    2fe6:	8a 81       	ldd	r24, Y+2	; 0x02
    2fe8:	9b 81       	ldd	r25, Y+3	; 0x03
    2fea:	0f 2e       	mov	r0, r31
    2fec:	f8 ee       	ldi	r31, 0xE8	; 232
    2fee:	cf 2e       	mov	r12, r31
    2ff0:	f3 e0       	ldi	r31, 0x03	; 3
    2ff2:	df 2e       	mov	r13, r31
    2ff4:	e1 2c       	mov	r14, r1
    2ff6:	f1 2c       	mov	r15, r1
    2ff8:	f0 2d       	mov	r31, r0
    2ffa:	a7 01       	movw	r20, r14
    2ffc:	96 01       	movw	r18, r12
    2ffe:	0e 94 10 1c 	call	0x3820	; 0x3820 <__udivmodsi4>
    3002:	9b 01       	movw	r18, r22
    3004:	ac 01       	movw	r20, r24
    3006:	60 e4       	ldi	r22, 0x40	; 64
    3008:	72 e4       	ldi	r23, 0x42	; 66
    300a:	8f e0       	ldi	r24, 0x0F	; 15
    300c:	90 e0       	ldi	r25, 0x00	; 0
    300e:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsi3>
    3012:	a7 01       	movw	r20, r14
    3014:	96 01       	movw	r18, r12
    3016:	0e 94 10 1c 	call	0x3820	; 0x3820 <__udivmodsi4>
    301a:	69 01       	movw	r12, r18
    301c:	7a 01       	movw	r14, r20
    301e:	ac 81       	ldd	r26, Y+4	; 0x04
    3020:	bd 81       	ldd	r27, Y+5	; 0x05
    3022:	20 e4       	ldi	r18, 0x40	; 64
    3024:	32 e4       	ldi	r19, 0x42	; 66
    3026:	4f e0       	ldi	r20, 0x0F	; 15
    3028:	50 e0       	ldi	r21, 0x00	; 0
    302a:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <__muluhisi3>
    302e:	20 e0       	ldi	r18, 0x00	; 0
    3030:	38 e4       	ldi	r19, 0x48	; 72
    3032:	48 ee       	ldi	r20, 0xE8	; 232
    3034:	51 e0       	ldi	r21, 0x01	; 1
    3036:	0e 94 10 1c 	call	0x3820	; 0x3820 <__udivmodsi4>
    303a:	c7 01       	movw	r24, r14
    303c:	b6 01       	movw	r22, r12
    303e:	62 0f       	add	r22, r18
    3040:	73 1f       	adc	r23, r19
    3042:	84 1f       	adc	r24, r20
    3044:	95 1f       	adc	r25, r21
}
    3046:	df 91       	pop	r29
    3048:	cf 91       	pop	r28
    304a:	ff 90       	pop	r15
    304c:	ef 90       	pop	r14
    304e:	df 90       	pop	r13
    3050:	cf 90       	pop	r12
    3052:	08 95       	ret

00003054 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3054:	cf 92       	push	r12
    3056:	df 92       	push	r13
    3058:	ef 92       	push	r14
    305a:	ff 92       	push	r15
    305c:	0f 93       	push	r16
    305e:	1f 93       	push	r17
    3060:	cf 93       	push	r28
    3062:	df 93       	push	r29
    3064:	cd b7       	in	r28, 0x3d	; 61
    3066:	de b7       	in	r29, 0x3e	; 62
    3068:	2f 97       	sbiw	r28, 0x0f	; 15
    306a:	cd bf       	out	0x3d, r28	; 61
    306c:	de bf       	out	0x3e, r29	; 62
    306e:	6c 01       	movw	r12, r24
    3070:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3072:	db 01       	movw	r26, r22
    3074:	6d 91       	ld	r22, X+
    3076:	7d 91       	ld	r23, X+
    3078:	8d 91       	ld	r24, X+
    307a:	9c 91       	ld	r25, X
    307c:	28 ee       	ldi	r18, 0xE8	; 232
    307e:	33 e0       	ldi	r19, 0x03	; 3
    3080:	40 e0       	ldi	r20, 0x00	; 0
    3082:	50 e0       	ldi	r21, 0x00	; 0
    3084:	0e 94 10 1c 	call	0x3820	; 0x3820 <__udivmodsi4>
    3088:	ba 01       	movw	r22, r20
    308a:	a9 01       	movw	r20, r18
    308c:	c6 01       	movw	r24, r12
    308e:	0e 94 cf 1a 	call	0x359e	; 0x359e <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3092:	d6 01       	movw	r26, r12
    3094:	ed 91       	ld	r30, X+
    3096:	fc 91       	ld	r31, X
    3098:	02 80       	ldd	r0, Z+2	; 0x02
    309a:	f3 81       	ldd	r31, Z+3	; 0x03
    309c:	e0 2d       	mov	r30, r0
    309e:	6e e2       	ldi	r22, 0x2E	; 46
    30a0:	c6 01       	movw	r24, r12
    30a2:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    30a4:	c8 01       	movw	r24, r16
    30a6:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZN10time_stamp12get_microsecEv>
    30aa:	8e 01       	movw	r16, r28
    30ac:	09 5f       	subi	r16, 0xF9	; 249
    30ae:	1f 4f       	sbci	r17, 0xFF	; 255
    30b0:	fe 01       	movw	r30, r28
    30b2:	31 96       	adiw	r30, 0x01	; 1
    30b4:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    30b6:	2a e0       	ldi	r18, 0x0A	; 10
    30b8:	30 e0       	ldi	r19, 0x00	; 0
    30ba:	40 e0       	ldi	r20, 0x00	; 0
    30bc:	50 e0       	ldi	r21, 0x00	; 0
    30be:	0e 94 32 1c 	call	0x3864	; 0x3864 <__divmodsi4>
    30c2:	e6 2f       	mov	r30, r22
    30c4:	28 87       	std	Y+8, r18	; 0x08
    30c6:	39 87       	std	Y+9, r19	; 0x09
    30c8:	4a 87       	std	Y+10, r20	; 0x0a
    30ca:	5b 87       	std	Y+11, r21	; 0x0b
    30cc:	68 85       	ldd	r22, Y+8	; 0x08
    30ce:	79 85       	ldd	r23, Y+9	; 0x09
    30d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    30d2:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    30d4:	20 e3       	ldi	r18, 0x30	; 48
    30d6:	2e 0f       	add	r18, r30
    30d8:	d8 01       	movw	r26, r16
    30da:	2e 93       	st	-X, r18
    30dc:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    30de:	ae 15       	cp	r26, r14
    30e0:	bf 05       	cpc	r27, r15
    30e2:	49 f7       	brne	.-46     	; 0x30b6 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    30e4:	1f 82       	std	Y+7, r1	; 0x07
    30e6:	be 01       	movw	r22, r28
    30e8:	6f 5f       	subi	r22, 0xFF	; 255
    30ea:	7f 4f       	sbci	r23, 0xFF	; 255
    30ec:	c6 01       	movw	r24, r12
    30ee:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    30f2:	c6 01       	movw	r24, r12
    30f4:	2f 96       	adiw	r28, 0x0f	; 15
    30f6:	cd bf       	out	0x3d, r28	; 61
    30f8:	de bf       	out	0x3e, r29	; 62
    30fa:	df 91       	pop	r29
    30fc:	cf 91       	pop	r28
    30fe:	1f 91       	pop	r17
    3100:	0f 91       	pop	r16
    3102:	ff 90       	pop	r15
    3104:	ef 90       	pop	r14
    3106:	df 90       	pop	r13
    3108:	cf 90       	pop	r12
    310a:	08 95       	ret

0000310c <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    310c:	cf 93       	push	r28
    310e:	df 93       	push	r29
    3110:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3112:	0f b6       	in	r0, 0x3f	; 63
    3114:	f8 94       	cli
    3116:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3118:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    311c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3120:	8c 83       	std	Y+4, r24	; 0x04
    3122:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3124:	0e 94 9a 10 	call	0x2134	; 0x2134 <xTaskGetTickCount>
    3128:	68 83       	st	Y, r22
    312a:	79 83       	std	Y+1, r23	; 0x01
    312c:	8a 83       	std	Y+2, r24	; 0x02
    312e:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3130:	0f 90       	pop	r0
    3132:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3134:	ce 01       	movw	r24, r28
    3136:	df 91       	pop	r29
    3138:	cf 91       	pop	r28
    313a:	08 95       	ret

0000313c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    313c:	5f 92       	push	r5
    313e:	6f 92       	push	r6
    3140:	7f 92       	push	r7
    3142:	8f 92       	push	r8
    3144:	9f 92       	push	r9
    3146:	af 92       	push	r10
    3148:	bf 92       	push	r11
    314a:	cf 92       	push	r12
    314c:	df 92       	push	r13
    314e:	ef 92       	push	r14
    3150:	ff 92       	push	r15
    3152:	0f 93       	push	r16
    3154:	1f 93       	push	r17
    3156:	cf 93       	push	r28
    3158:	df 93       	push	r29
    315a:	5c 01       	movw	r10, r24
    315c:	4b 01       	movw	r8, r22
    315e:	7a 01       	movw	r14, r20
    3160:	12 2f       	mov	r17, r18
    3162:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3164:	63 e0       	ldi	r22, 0x03	; 3
    3166:	ca 01       	movw	r24, r20
    3168:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    316c:	a8 14       	cp	r10, r8
    316e:	b9 04       	cpc	r11, r9
    3170:	08 f0       	brcs	.+2      	; 0x3174 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3172:	7d c0       	rjmp	.+250    	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3174:	65 01       	movw	r12, r10
    3176:	84 e1       	ldi	r24, 0x14	; 20
    3178:	c8 0e       	add	r12, r24
    317a:	d1 1c       	adc	r13, r1
    317c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    317e:	6a 2c       	mov	r6, r10
    3180:	5b 2c       	mov	r5, r11
    3182:	b5 01       	movw	r22, r10
    3184:	c7 01       	movw	r24, r14
    3186:	0e 94 9b 1a 	call	0x3536	; 0x3536 <_ZN8emstreamlsEj>
    318a:	6a e0       	ldi	r22, 0x0A	; 10
    318c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    3190:	61 e3       	ldi	r22, 0x31	; 49
    3192:	75 e0       	ldi	r23, 0x05	; 5
    3194:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3198:	11 23       	and	r17, r17
    319a:	09 f4       	brne	.+2      	; 0x319e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    319c:	6d c0       	rjmp	.+218    	; 0x3278 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    319e:	00 23       	and	r16, r16
    31a0:	09 f4       	brne	.+2      	; 0x31a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    31a2:	6a c0       	rjmp	.+212    	; 0x3278 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    31a4:	6a e0       	ldi	r22, 0x0A	; 10
    31a6:	c7 01       	movw	r24, r14
    31a8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    31ac:	6c e2       	ldi	r22, 0x2C	; 44
    31ae:	75 e0       	ldi	r23, 0x05	; 5
    31b0:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    31b4:	61 c0       	rjmp	.+194    	; 0x3278 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    31b6:	11 23       	and	r17, r17
    31b8:	71 f0       	breq	.+28     	; 0x31d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    31ba:	01 11       	cpse	r16, r1
    31bc:	0c c0       	rjmp	.+24     	; 0x31d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    31be:	88 81       	ld	r24, Y
    31c0:	87 15       	cp	r24, r7
    31c2:	49 f0       	breq	.+18     	; 0x31d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    31c4:	6a e0       	ldi	r22, 0x0A	; 10
    31c6:	c7 01       	movw	r24, r14
    31c8:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    31cc:	67 e2       	ldi	r22, 0x27	; 39
    31ce:	75 e0       	ldi	r23, 0x05	; 5
    31d0:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    31d4:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    31d6:	69 91       	ld	r22, Y+
    31d8:	c7 01       	movw	r24, r14
    31da:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    31de:	dc 01       	movw	r26, r24
    31e0:	ed 91       	ld	r30, X+
    31e2:	fc 91       	ld	r31, X
    31e4:	02 80       	ldd	r0, Z+2	; 0x02
    31e6:	f3 81       	ldd	r31, Z+3	; 0x03
    31e8:	e0 2d       	mov	r30, r0
    31ea:	60 e2       	ldi	r22, 0x20	; 32
    31ec:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    31ee:	cc 16       	cp	r12, r28
    31f0:	dd 06       	cpc	r13, r29
    31f2:	09 f7       	brne	.-62     	; 0x31b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    31f4:	11 23       	and	r17, r17
    31f6:	89 f0       	breq	.+34     	; 0x321a <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    31f8:	6a e0       	ldi	r22, 0x0A	; 10
    31fa:	c7 01       	movw	r24, r14
    31fc:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    3200:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3202:	61 e2       	ldi	r22, 0x21	; 33
    3204:	75 e0       	ldi	r23, 0x05	; 5
    3206:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    320a:	e8 81       	ld	r30, Y
    320c:	f9 81       	ldd	r31, Y+1	; 0x01
    320e:	02 80       	ldd	r0, Z+2	; 0x02
    3210:	f3 81       	ldd	r31, Z+3	; 0x03
    3212:	e0 2d       	mov	r30, r0
    3214:	60 e2       	ldi	r22, 0x20	; 32
    3216:	ce 01       	movw	r24, r28
    3218:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    321a:	c6 2d       	mov	r28, r6
    321c:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    321e:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3220:	80 ee       	ldi	r24, 0xE0	; 224
    3222:	86 0f       	add	r24, r22
    3224:	8f 35       	cpi	r24, 0x5F	; 95
    3226:	48 f4       	brcc	.+18     	; 0x323a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3228:	d7 01       	movw	r26, r14
    322a:	ed 91       	ld	r30, X+
    322c:	fc 91       	ld	r31, X
    322e:	02 80       	ldd	r0, Z+2	; 0x02
    3230:	f3 81       	ldd	r31, Z+3	; 0x03
    3232:	e0 2d       	mov	r30, r0
    3234:	c7 01       	movw	r24, r14
    3236:	19 95       	eicall
    3238:	09 c0       	rjmp	.+18     	; 0x324c <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    323a:	d7 01       	movw	r26, r14
    323c:	ed 91       	ld	r30, X+
    323e:	fc 91       	ld	r31, X
    3240:	02 80       	ldd	r0, Z+2	; 0x02
    3242:	f3 81       	ldd	r31, Z+3	; 0x03
    3244:	e0 2d       	mov	r30, r0
    3246:	6e e2       	ldi	r22, 0x2E	; 46
    3248:	c7 01       	movw	r24, r14
    324a:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    324c:	cc 16       	cp	r12, r28
    324e:	dd 06       	cpc	r13, r29
    3250:	31 f7       	brne	.-52     	; 0x321e <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3252:	b4 e1       	ldi	r27, 0x14	; 20
    3254:	ab 0e       	add	r10, r27
    3256:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3258:	66 e0       	ldi	r22, 0x06	; 6
    325a:	c7 01       	movw	r24, r14
    325c:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    3260:	84 e1       	ldi	r24, 0x14	; 20
    3262:	c8 0e       	add	r12, r24
    3264:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3266:	a8 14       	cp	r10, r8
    3268:	b9 04       	cpc	r11, r9
    326a:	08 f4       	brcc	.+2      	; 0x326e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    326c:	88 cf       	rjmp	.-240    	; 0x317e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    326e:	62 e0       	ldi	r22, 0x02	; 2
    3270:	c7 01       	movw	r24, r14
    3272:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
}
    3276:	03 c0       	rjmp	.+6      	; 0x327e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3278:	c6 2d       	mov	r28, r6
    327a:	d5 2d       	mov	r29, r5
    327c:	9c cf       	rjmp	.-200    	; 0x31b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    327e:	df 91       	pop	r29
    3280:	cf 91       	pop	r28
    3282:	1f 91       	pop	r17
    3284:	0f 91       	pop	r16
    3286:	ff 90       	pop	r15
    3288:	ef 90       	pop	r14
    328a:	df 90       	pop	r13
    328c:	cf 90       	pop	r12
    328e:	bf 90       	pop	r11
    3290:	af 90       	pop	r10
    3292:	9f 90       	pop	r9
    3294:	8f 90       	pop	r8
    3296:	7f 90       	pop	r7
    3298:	6f 90       	pop	r6
    329a:	5f 90       	pop	r5
    329c:	08 95       	ret

0000329e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    329e:	0e 94 78 09 	call	0x12f0	; 0x12f0 <pvPortMalloc>
    32a2:	08 95       	ret

000032a4 <_Znaj>:
    32a4:	0e 94 78 09 	call	0x12f0	; 0x12f0 <pvPortMalloc>
    32a8:	08 95       	ret

000032aa <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    32aa:	08 95       	ret

000032ac <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    32ac:	cf 93       	push	r28
    32ae:	df 93       	push	r29
    32b0:	fc 01       	movw	r30, r24
    32b2:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    32b4:	40 3a       	cpi	r20, 0xA0	; 160
    32b6:	68 e0       	ldi	r22, 0x08	; 8
    32b8:	56 07       	cpc	r21, r22
    32ba:	49 f4       	brne	.+18     	; 0x32ce <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    32bc:	80 e4       	ldi	r24, 0x40	; 64
    32be:	96 e0       	ldi	r25, 0x06	; 6
    32c0:	82 83       	std	Z+2, r24	; 0x02
    32c2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32c4:	82 e0       	ldi	r24, 0x02	; 2
    32c6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32c8:	83 e0       	ldi	r24, 0x03	; 3
    32ca:	85 83       	std	Z+5, r24	; 0x05
    32cc:	4c c0       	rjmp	.+152    	; 0x3366 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    32ce:	40 3b       	cpi	r20, 0xB0	; 176
    32d0:	78 e0       	ldi	r23, 0x08	; 8
    32d2:	57 07       	cpc	r21, r23
    32d4:	49 f4       	brne	.+18     	; 0x32e8 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    32d6:	80 e4       	ldi	r24, 0x40	; 64
    32d8:	96 e0       	ldi	r25, 0x06	; 6
    32da:	82 83       	std	Z+2, r24	; 0x02
    32dc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    32de:	86 e0       	ldi	r24, 0x06	; 6
    32e0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    32e2:	87 e0       	ldi	r24, 0x07	; 7
    32e4:	85 83       	std	Z+5, r24	; 0x05
    32e6:	3f c0       	rjmp	.+126    	; 0x3366 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    32e8:	40 3a       	cpi	r20, 0xA0	; 160
    32ea:	89 e0       	ldi	r24, 0x09	; 9
    32ec:	58 07       	cpc	r21, r24
    32ee:	49 f4       	brne	.+18     	; 0x3302 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    32f0:	80 e6       	ldi	r24, 0x60	; 96
    32f2:	96 e0       	ldi	r25, 0x06	; 6
    32f4:	82 83       	std	Z+2, r24	; 0x02
    32f6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    32f8:	82 e0       	ldi	r24, 0x02	; 2
    32fa:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    32fc:	83 e0       	ldi	r24, 0x03	; 3
    32fe:	85 83       	std	Z+5, r24	; 0x05
    3300:	32 c0       	rjmp	.+100    	; 0x3366 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3302:	40 3b       	cpi	r20, 0xB0	; 176
    3304:	69 e0       	ldi	r22, 0x09	; 9
    3306:	56 07       	cpc	r21, r22
    3308:	49 f4       	brne	.+18     	; 0x331c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    330a:	80 e6       	ldi	r24, 0x60	; 96
    330c:	96 e0       	ldi	r25, 0x06	; 6
    330e:	82 83       	std	Z+2, r24	; 0x02
    3310:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3312:	86 e0       	ldi	r24, 0x06	; 6
    3314:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3316:	87 e0       	ldi	r24, 0x07	; 7
    3318:	85 83       	std	Z+5, r24	; 0x05
    331a:	25 c0       	rjmp	.+74     	; 0x3366 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    331c:	40 3a       	cpi	r20, 0xA0	; 160
    331e:	7a e0       	ldi	r23, 0x0A	; 10
    3320:	57 07       	cpc	r21, r23
    3322:	49 f4       	brne	.+18     	; 0x3336 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    3324:	80 e8       	ldi	r24, 0x80	; 128
    3326:	96 e0       	ldi	r25, 0x06	; 6
    3328:	82 83       	std	Z+2, r24	; 0x02
    332a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    332c:	82 e0       	ldi	r24, 0x02	; 2
    332e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3330:	83 e0       	ldi	r24, 0x03	; 3
    3332:	85 83       	std	Z+5, r24	; 0x05
    3334:	18 c0       	rjmp	.+48     	; 0x3366 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTE1 
	else if(p_usart == &USARTE1)
    3336:	40 3b       	cpi	r20, 0xB0	; 176
    3338:	8a e0       	ldi	r24, 0x0A	; 10
    333a:	58 07       	cpc	r21, r24
    333c:	49 f4       	brne	.+18     	; 0x3350 <_ZN7base232C1EjP12USART_struct+0xa4>
	{
		p_port = &PORTE;
    333e:	80 e8       	ldi	r24, 0x80	; 128
    3340:	96 e0       	ldi	r25, 0x06	; 6
    3342:	82 83       	std	Z+2, r24	; 0x02
    3344:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3346:	86 e0       	ldi	r24, 0x06	; 6
    3348:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    334a:	87 e0       	ldi	r24, 0x07	; 7
    334c:	85 83       	std	Z+5, r24	; 0x05
    334e:	0b c0       	rjmp	.+22     	; 0x3366 <_ZN7base232C1EjP12USART_struct+0xba>
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    3350:	40 3a       	cpi	r20, 0xA0	; 160
    3352:	5b 40       	sbci	r21, 0x0B	; 11
    3354:	41 f4       	brne	.+16     	; 0x3366 <_ZN7base232C1EjP12USART_struct+0xba>
	{
		p_port = &PORTF;
    3356:	80 ea       	ldi	r24, 0xA0	; 160
    3358:	96 e0       	ldi	r25, 0x06	; 6
    335a:	82 83       	std	Z+2, r24	; 0x02
    335c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    335e:	82 e0       	ldi	r24, 0x02	; 2
    3360:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3362:	83 e0       	ldi	r24, 0x03	; 3
    3364:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3366:	a6 83       	std	Z+6, r26	; 0x06
    3368:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    336a:	cd 01       	movw	r24, r26
    336c:	01 96       	adiw	r24, 0x01	; 1
    336e:	80 87       	std	Z+8, r24	; 0x08
    3370:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3372:	03 96       	adiw	r24, 0x03	; 3
    3374:	82 87       	std	Z+10, r24	; 0x0a
    3376:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3378:	25 81       	ldd	r18, Z+5	; 0x05
    337a:	c2 81       	ldd	r28, Z+2	; 0x02
    337c:	d3 81       	ldd	r29, Z+3	; 0x03
    337e:	4c 81       	ldd	r20, Y+4	; 0x04
    3380:	81 e0       	ldi	r24, 0x01	; 1
    3382:	90 e0       	ldi	r25, 0x00	; 0
    3384:	bc 01       	movw	r22, r24
    3386:	02 c0       	rjmp	.+4      	; 0x338c <_ZN7base232C1EjP12USART_struct+0xe0>
    3388:	66 0f       	add	r22, r22
    338a:	77 1f       	adc	r23, r23
    338c:	2a 95       	dec	r18
    338e:	e2 f7       	brpl	.-8      	; 0x3388 <_ZN7base232C1EjP12USART_struct+0xdc>
    3390:	9b 01       	movw	r18, r22
    3392:	24 2b       	or	r18, r20
    3394:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3396:	25 81       	ldd	r18, Z+5	; 0x05
    3398:	c2 81       	ldd	r28, Z+2	; 0x02
    339a:	d3 81       	ldd	r29, Z+3	; 0x03
    339c:	48 81       	ld	r20, Y
    339e:	bc 01       	movw	r22, r24
    33a0:	02 c0       	rjmp	.+4      	; 0x33a6 <_ZN7base232C1EjP12USART_struct+0xfa>
    33a2:	66 0f       	add	r22, r22
    33a4:	77 1f       	adc	r23, r23
    33a6:	2a 95       	dec	r18
    33a8:	e2 f7       	brpl	.-8      	; 0x33a2 <_ZN7base232C1EjP12USART_struct+0xf6>
    33aa:	9b 01       	movw	r18, r22
    33ac:	24 2b       	or	r18, r20
    33ae:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    33b0:	34 81       	ldd	r19, Z+4	; 0x04
    33b2:	c2 81       	ldd	r28, Z+2	; 0x02
    33b4:	d3 81       	ldd	r29, Z+3	; 0x03
    33b6:	28 81       	ld	r18, Y
    33b8:	02 c0       	rjmp	.+4      	; 0x33be <_ZN7base232C1EjP12USART_struct+0x112>
    33ba:	88 0f       	add	r24, r24
    33bc:	99 1f       	adc	r25, r25
    33be:	3a 95       	dec	r19
    33c0:	e2 f7       	brpl	.-8      	; 0x33ba <_ZN7base232C1EjP12USART_struct+0x10e>
    33c2:	80 95       	com	r24
    33c4:	90 95       	com	r25
    33c6:	82 23       	and	r24, r18
    33c8:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    33ca:	80 e1       	ldi	r24, 0x10	; 16
    33cc:	13 96       	adiw	r26, 0x03	; 3
    33ce:	8c 93       	st	X, r24
    33d0:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    33d2:	83 e0       	ldi	r24, 0x03	; 3
    33d4:	15 96       	adiw	r26, 0x05	; 5
    33d6:	8c 93       	st	X, r24
    33d8:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    33da:	80 ef       	ldi	r24, 0xF0	; 240
    33dc:	17 96       	adiw	r26, 0x07	; 7
    33de:	8c 93       	st	X, r24
    33e0:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    33e2:	81 e2       	ldi	r24, 0x21	; 33
    33e4:	16 96       	adiw	r26, 0x06	; 6
    33e6:	8c 93       	st	X, r24
    33e8:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    33ea:	88 e1       	ldi	r24, 0x18	; 24
    33ec:	14 96       	adiw	r26, 0x04	; 4
    33ee:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    33f0:	80 e8       	ldi	r24, 0x80	; 128
    33f2:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    33f4:	80 e4       	ldi	r24, 0x40	; 64
    33f6:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    33f8:	80 e2       	ldi	r24, 0x20	; 32
    33fa:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    33fc:	06 80       	ldd	r0, Z+6	; 0x06
    33fe:	f7 81       	ldd	r31, Z+7	; 0x07
    3400:	e0 2d       	mov	r30, r0
    3402:	80 81       	ld	r24, Z
    3404:	80 81       	ld	r24, Z
}
    3406:	df 91       	pop	r29
    3408:	cf 91       	pop	r28
    340a:	08 95       	ret

0000340c <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    340c:	81 e0       	ldi	r24, 0x01	; 1
    340e:	08 95       	ret

00003410 <_ZN8emstream7getcharEv>:
    3410:	80 e0       	ldi	r24, 0x00	; 0
    3412:	90 e0       	ldi	r25, 0x00	; 0
    3414:	08 95       	ret

00003416 <_ZN8emstream14check_for_charEv>:
    3416:	80 e0       	ldi	r24, 0x00	; 0
    3418:	08 95       	ret

0000341a <_ZN8emstream12transmit_nowEv>:
    341a:	08 95       	ret

0000341c <_ZN8emstream12clear_screenEv>:
    341c:	08 95       	ret

0000341e <_ZN8emstreamC1Ev>:
    341e:	fc 01       	movw	r30, r24
    3420:	87 e4       	ldi	r24, 0x47	; 71
    3422:	90 e2       	ldi	r25, 0x20	; 32
    3424:	80 83       	st	Z, r24
    3426:	91 83       	std	Z+1, r25	; 0x01
    3428:	8a e0       	ldi	r24, 0x0A	; 10
    342a:	82 83       	std	Z+2, r24	; 0x02
    342c:	13 82       	std	Z+3, r1	; 0x03
    342e:	83 e0       	ldi	r24, 0x03	; 3
    3430:	85 83       	std	Z+5, r24	; 0x05
    3432:	14 82       	std	Z+4, r1	; 0x04
    3434:	16 82       	std	Z+6, r1	; 0x06
    3436:	17 82       	std	Z+7, r1	; 0x07
    3438:	08 95       	ret

0000343a <_ZN8emstream4putsEPKc>:
    343a:	0f 93       	push	r16
    343c:	1f 93       	push	r17
    343e:	cf 93       	push	r28
    3440:	df 93       	push	r29
    3442:	8c 01       	movw	r16, r24
    3444:	fb 01       	movw	r30, r22
    3446:	dc 01       	movw	r26, r24
    3448:	14 96       	adiw	r26, 0x04	; 4
    344a:	8c 91       	ld	r24, X
    344c:	81 11       	cpse	r24, r1
    344e:	04 c0       	rjmp	.+8      	; 0x3458 <_ZN8emstream4putsEPKc+0x1e>
    3450:	60 81       	ld	r22, Z
    3452:	61 11       	cpse	r22, r1
    3454:	17 c0       	rjmp	.+46     	; 0x3484 <_ZN8emstream4putsEPKc+0x4a>
    3456:	23 c0       	rjmp	.+70     	; 0x349e <_ZN8emstream4putsEPKc+0x64>
    3458:	d8 01       	movw	r26, r16
    345a:	14 96       	adiw	r26, 0x04	; 4
    345c:	1c 92       	st	X, r1
    345e:	eb 01       	movw	r28, r22
    3460:	21 96       	adiw	r28, 0x01	; 1
    3462:	64 91       	lpm	r22, Z
    3464:	66 23       	and	r22, r22
    3466:	d9 f0       	breq	.+54     	; 0x349e <_ZN8emstream4putsEPKc+0x64>
    3468:	d8 01       	movw	r26, r16
    346a:	ed 91       	ld	r30, X+
    346c:	fc 91       	ld	r31, X
    346e:	02 80       	ldd	r0, Z+2	; 0x02
    3470:	f3 81       	ldd	r31, Z+3	; 0x03
    3472:	e0 2d       	mov	r30, r0
    3474:	c8 01       	movw	r24, r16
    3476:	19 95       	eicall
    3478:	fe 01       	movw	r30, r28
    347a:	64 91       	lpm	r22, Z
    347c:	21 96       	adiw	r28, 0x01	; 1
    347e:	61 11       	cpse	r22, r1
    3480:	f3 cf       	rjmp	.-26     	; 0x3468 <_ZN8emstream4putsEPKc+0x2e>
    3482:	0d c0       	rjmp	.+26     	; 0x349e <_ZN8emstream4putsEPKc+0x64>
    3484:	ef 01       	movw	r28, r30
    3486:	21 96       	adiw	r28, 0x01	; 1
    3488:	d8 01       	movw	r26, r16
    348a:	ed 91       	ld	r30, X+
    348c:	fc 91       	ld	r31, X
    348e:	02 80       	ldd	r0, Z+2	; 0x02
    3490:	f3 81       	ldd	r31, Z+3	; 0x03
    3492:	e0 2d       	mov	r30, r0
    3494:	c8 01       	movw	r24, r16
    3496:	19 95       	eicall
    3498:	69 91       	ld	r22, Y+
    349a:	61 11       	cpse	r22, r1
    349c:	f5 cf       	rjmp	.-22     	; 0x3488 <_ZN8emstream4putsEPKc+0x4e>
    349e:	df 91       	pop	r29
    34a0:	cf 91       	pop	r28
    34a2:	1f 91       	pop	r17
    34a4:	0f 91       	pop	r16
    34a6:	08 95       	ret

000034a8 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    34a8:	cf 93       	push	r28
    34aa:	df 93       	push	r29
    34ac:	ec 01       	movw	r28, r24
	switch (new_manip)
    34ae:	86 2f       	mov	r24, r22
    34b0:	90 e0       	ldi	r25, 0x00	; 0
    34b2:	8b 30       	cpi	r24, 0x0B	; 11
    34b4:	91 05       	cpc	r25, r1
    34b6:	d8 f5       	brcc	.+118    	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
    34b8:	fc 01       	movw	r30, r24
    34ba:	88 27       	eor	r24, r24
    34bc:	e2 50       	subi	r30, 0x02	; 2
    34be:	ff 4f       	sbci	r31, 0xFF	; 255
    34c0:	8f 4f       	sbci	r24, 0xFF	; 255
    34c2:	0c 94 51 1c 	jmp	0x38a2	; 0x38a2 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    34c6:	82 e0       	ldi	r24, 0x02	; 2
    34c8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    34ca:	31 c0       	rjmp	.+98     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    34cc:	88 e0       	ldi	r24, 0x08	; 8
    34ce:	8a 83       	std	Y+2, r24	; 0x02
			break;
    34d0:	2e c0       	rjmp	.+92     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    34d2:	8a e0       	ldi	r24, 0x0A	; 10
    34d4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    34d6:	2b c0       	rjmp	.+86     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    34d8:	80 e1       	ldi	r24, 0x10	; 16
    34da:	8a 83       	std	Y+2, r24	; 0x02
			break;
    34dc:	28 c0       	rjmp	.+80     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    34de:	81 e0       	ldi	r24, 0x01	; 1
    34e0:	8b 83       	std	Y+3, r24	; 0x03
			break;
    34e2:	25 c0       	rjmp	.+74     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    34e4:	1b 82       	std	Y+3, r1	; 0x03
			break;
    34e6:	23 c0       	rjmp	.+70     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    34e8:	e8 81       	ld	r30, Y
    34ea:	f9 81       	ldd	r31, Y+1	; 0x01
    34ec:	02 80       	ldd	r0, Z+2	; 0x02
    34ee:	f3 81       	ldd	r31, Z+3	; 0x03
    34f0:	e0 2d       	mov	r30, r0
    34f2:	6d e0       	ldi	r22, 0x0D	; 13
    34f4:	ce 01       	movw	r24, r28
    34f6:	19 95       	eicall
    34f8:	e8 81       	ld	r30, Y
    34fa:	f9 81       	ldd	r31, Y+1	; 0x01
    34fc:	02 80       	ldd	r0, Z+2	; 0x02
    34fe:	f3 81       	ldd	r31, Z+3	; 0x03
    3500:	e0 2d       	mov	r30, r0
    3502:	6a e0       	ldi	r22, 0x0A	; 10
    3504:	ce 01       	movw	r24, r28
    3506:	19 95       	eicall
			break;
    3508:	12 c0       	rjmp	.+36     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    350a:	e8 81       	ld	r30, Y
    350c:	f9 81       	ldd	r31, Y+1	; 0x01
    350e:	02 84       	ldd	r0, Z+10	; 0x0a
    3510:	f3 85       	ldd	r31, Z+11	; 0x0b
    3512:	e0 2d       	mov	r30, r0
    3514:	ce 01       	movw	r24, r28
    3516:	19 95       	eicall
			break;
    3518:	0a c0       	rjmp	.+20     	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    351a:	e8 81       	ld	r30, Y
    351c:	f9 81       	ldd	r31, Y+1	; 0x01
    351e:	00 84       	ldd	r0, Z+8	; 0x08
    3520:	f1 85       	ldd	r31, Z+9	; 0x09
    3522:	e0 2d       	mov	r30, r0
    3524:	ce 01       	movw	r24, r28
    3526:	19 95       	eicall
			break;
    3528:	02 c0       	rjmp	.+4      	; 0x352e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    352a:	81 e0       	ldi	r24, 0x01	; 1
    352c:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    352e:	ce 01       	movw	r24, r28
    3530:	df 91       	pop	r29
    3532:	cf 91       	pop	r28
    3534:	08 95       	ret

00003536 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3536:	ff 92       	push	r15
    3538:	0f 93       	push	r16
    353a:	1f 93       	push	r17
    353c:	cf 93       	push	r28
    353e:	df 93       	push	r29
    3540:	cd b7       	in	r28, 0x3d	; 61
    3542:	de b7       	in	r29, 0x3e	; 62
    3544:	61 97       	sbiw	r28, 0x11	; 17
    3546:	cd bf       	out	0x3d, r28	; 61
    3548:	de bf       	out	0x3e, r29	; 62
    354a:	8c 01       	movw	r16, r24
    354c:	f6 2e       	mov	r15, r22
    354e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3550:	f8 01       	movw	r30, r16
    3552:	42 81       	ldd	r20, Z+2	; 0x02
    3554:	40 31       	cpi	r20, 0x10	; 16
    3556:	21 f0       	breq	.+8      	; 0x3560 <_ZN8emstreamlsEj+0x2a>
    3558:	48 30       	cpi	r20, 0x08	; 8
    355a:	11 f0       	breq	.+4      	; 0x3560 <_ZN8emstreamlsEj+0x2a>
    355c:	42 30       	cpi	r20, 0x02	; 2
    355e:	41 f4       	brne	.+16     	; 0x3570 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3560:	69 2f       	mov	r22, r25
    3562:	c8 01       	movw	r24, r16
    3564:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    3568:	6f 2d       	mov	r22, r15
    356a:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    356e:	0d c0       	rjmp	.+26     	; 0x358a <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3570:	50 e0       	ldi	r21, 0x00	; 0
    3572:	be 01       	movw	r22, r28
    3574:	6f 5f       	subi	r22, 0xFF	; 255
    3576:	7f 4f       	sbci	r23, 0xFF	; 255
    3578:	8f 2d       	mov	r24, r15
    357a:	0e 94 bf 1c 	call	0x397e	; 0x397e <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    357e:	be 01       	movw	r22, r28
    3580:	6f 5f       	subi	r22, 0xFF	; 255
    3582:	7f 4f       	sbci	r23, 0xFF	; 255
    3584:	c8 01       	movw	r24, r16
    3586:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    358a:	c8 01       	movw	r24, r16
    358c:	61 96       	adiw	r28, 0x11	; 17
    358e:	cd bf       	out	0x3d, r28	; 61
    3590:	de bf       	out	0x3e, r29	; 62
    3592:	df 91       	pop	r29
    3594:	cf 91       	pop	r28
    3596:	1f 91       	pop	r17
    3598:	0f 91       	pop	r16
    359a:	ff 90       	pop	r15
    359c:	08 95       	ret

0000359e <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    359e:	df 92       	push	r13
    35a0:	ef 92       	push	r14
    35a2:	ff 92       	push	r15
    35a4:	0f 93       	push	r16
    35a6:	1f 93       	push	r17
    35a8:	cf 93       	push	r28
    35aa:	df 93       	push	r29
    35ac:	cd b7       	in	r28, 0x3d	; 61
    35ae:	de b7       	in	r29, 0x3e	; 62
    35b0:	a1 97       	sbiw	r28, 0x21	; 33
    35b2:	cd bf       	out	0x3d, r28	; 61
    35b4:	de bf       	out	0x3e, r29	; 62
    35b6:	8c 01       	movw	r16, r24
    35b8:	d4 2e       	mov	r13, r20
    35ba:	e5 2e       	mov	r14, r21
    35bc:	f6 2e       	mov	r15, r22
    35be:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    35c0:	f8 01       	movw	r30, r16
    35c2:	22 81       	ldd	r18, Z+2	; 0x02
    35c4:	20 31       	cpi	r18, 0x10	; 16
    35c6:	21 f0       	breq	.+8      	; 0x35d0 <_ZN8emstreamlsEm+0x32>
    35c8:	28 30       	cpi	r18, 0x08	; 8
    35ca:	11 f0       	breq	.+4      	; 0x35d0 <_ZN8emstreamlsEm+0x32>
    35cc:	22 30       	cpi	r18, 0x02	; 2
    35ce:	71 f4       	brne	.+28     	; 0x35ec <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    35d0:	69 2f       	mov	r22, r25
    35d2:	c8 01       	movw	r24, r16
    35d4:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    35d8:	6f 2d       	mov	r22, r15
    35da:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    35de:	6e 2d       	mov	r22, r14
    35e0:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    35e4:	6d 2d       	mov	r22, r13
    35e6:	0e 94 11 1b 	call	0x3622	; 0x3622 <_ZN8emstreamlsEh>
    35ea:	0f c0       	rjmp	.+30     	; 0x360a <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    35ec:	30 e0       	ldi	r19, 0x00	; 0
    35ee:	ae 01       	movw	r20, r28
    35f0:	4f 5f       	subi	r20, 0xFF	; 255
    35f2:	5f 4f       	sbci	r21, 0xFF	; 255
    35f4:	6d 2d       	mov	r22, r13
    35f6:	7e 2d       	mov	r23, r14
    35f8:	8f 2d       	mov	r24, r15
    35fa:	0e 94 92 1c 	call	0x3924	; 0x3924 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    35fe:	be 01       	movw	r22, r28
    3600:	6f 5f       	subi	r22, 0xFF	; 255
    3602:	7f 4f       	sbci	r23, 0xFF	; 255
    3604:	c8 01       	movw	r24, r16
    3606:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    360a:	c8 01       	movw	r24, r16
    360c:	a1 96       	adiw	r28, 0x21	; 33
    360e:	cd bf       	out	0x3d, r28	; 61
    3610:	de bf       	out	0x3e, r29	; 62
    3612:	df 91       	pop	r29
    3614:	cf 91       	pop	r28
    3616:	1f 91       	pop	r17
    3618:	0f 91       	pop	r16
    361a:	ff 90       	pop	r15
    361c:	ef 90       	pop	r14
    361e:	df 90       	pop	r13
    3620:	08 95       	ret

00003622 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3622:	cf 92       	push	r12
    3624:	df 92       	push	r13
    3626:	ef 92       	push	r14
    3628:	ff 92       	push	r15
    362a:	0f 93       	push	r16
    362c:	1f 93       	push	r17
    362e:	cf 93       	push	r28
    3630:	df 93       	push	r29
    3632:	cd b7       	in	r28, 0x3d	; 61
    3634:	de b7       	in	r29, 0x3e	; 62
    3636:	29 97       	sbiw	r28, 0x09	; 9
    3638:	cd bf       	out	0x3d, r28	; 61
    363a:	de bf       	out	0x3e, r29	; 62
    363c:	8c 01       	movw	r16, r24
    363e:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3640:	dc 01       	movw	r26, r24
    3642:	13 96       	adiw	r26, 0x03	; 3
    3644:	8c 91       	ld	r24, X
    3646:	13 97       	sbiw	r26, 0x03	; 3
    3648:	88 23       	and	r24, r24
    364a:	41 f0       	breq	.+16     	; 0x365c <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    364c:	ed 91       	ld	r30, X+
    364e:	fc 91       	ld	r31, X
    3650:	02 80       	ldd	r0, Z+2	; 0x02
    3652:	f3 81       	ldd	r31, Z+3	; 0x03
    3654:	e0 2d       	mov	r30, r0
    3656:	c8 01       	movw	r24, r16
    3658:	19 95       	eicall
    365a:	56 c0       	rjmp	.+172    	; 0x3708 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    365c:	f8 01       	movw	r30, r16
    365e:	42 81       	ldd	r20, Z+2	; 0x02
    3660:	42 30       	cpi	r20, 0x02	; 2
    3662:	19 f5       	brne	.+70     	; 0x36aa <_ZN8emstreamlsEh+0x88>
    3664:	68 94       	set
    3666:	cc 24       	eor	r12, r12
    3668:	c3 f8       	bld	r12, 3
    366a:	d1 2c       	mov	r13, r1
    366c:	68 94       	set
    366e:	ff 24       	eor	r15, r15
    3670:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3672:	8e 2d       	mov	r24, r14
    3674:	8f 21       	and	r24, r15
    3676:	51 f0       	breq	.+20     	; 0x368c <_ZN8emstreamlsEh+0x6a>
    3678:	d8 01       	movw	r26, r16
    367a:	ed 91       	ld	r30, X+
    367c:	fc 91       	ld	r31, X
    367e:	02 80       	ldd	r0, Z+2	; 0x02
    3680:	f3 81       	ldd	r31, Z+3	; 0x03
    3682:	e0 2d       	mov	r30, r0
    3684:	61 e3       	ldi	r22, 0x31	; 49
    3686:	c8 01       	movw	r24, r16
    3688:	19 95       	eicall
    368a:	09 c0       	rjmp	.+18     	; 0x369e <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    368c:	d8 01       	movw	r26, r16
    368e:	ed 91       	ld	r30, X+
    3690:	fc 91       	ld	r31, X
    3692:	02 80       	ldd	r0, Z+2	; 0x02
    3694:	f3 81       	ldd	r31, Z+3	; 0x03
    3696:	e0 2d       	mov	r30, r0
    3698:	60 e3       	ldi	r22, 0x30	; 48
    369a:	c8 01       	movw	r24, r16
    369c:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    369e:	f6 94       	lsr	r15
    36a0:	b1 e0       	ldi	r27, 0x01	; 1
    36a2:	cb 1a       	sub	r12, r27
    36a4:	d1 08       	sbc	r13, r1
    36a6:	29 f7       	brne	.-54     	; 0x3672 <_ZN8emstreamlsEh+0x50>
    36a8:	2f c0       	rjmp	.+94     	; 0x3708 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    36aa:	40 31       	cpi	r20, 0x10	; 16
    36ac:	f9 f4       	brne	.+62     	; 0x36ec <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    36ae:	62 95       	swap	r22
    36b0:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    36b2:	01 90       	ld	r0, Z+
    36b4:	f0 81       	ld	r31, Z
    36b6:	e0 2d       	mov	r30, r0
    36b8:	02 80       	ldd	r0, Z+2	; 0x02
    36ba:	f3 81       	ldd	r31, Z+3	; 0x03
    36bc:	e0 2d       	mov	r30, r0
    36be:	6a 30       	cpi	r22, 0x0A	; 10
    36c0:	10 f0       	brcs	.+4      	; 0x36c6 <_ZN8emstreamlsEh+0xa4>
    36c2:	69 5c       	subi	r22, 0xC9	; 201
    36c4:	01 c0       	rjmp	.+2      	; 0x36c8 <_ZN8emstreamlsEh+0xa6>
    36c6:	60 5d       	subi	r22, 0xD0	; 208
    36c8:	c8 01       	movw	r24, r16
    36ca:	19 95       	eicall
		temp_char = num & 0x0F;
    36cc:	6e 2d       	mov	r22, r14
    36ce:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    36d0:	d8 01       	movw	r26, r16
    36d2:	ed 91       	ld	r30, X+
    36d4:	fc 91       	ld	r31, X
    36d6:	02 80       	ldd	r0, Z+2	; 0x02
    36d8:	f3 81       	ldd	r31, Z+3	; 0x03
    36da:	e0 2d       	mov	r30, r0
    36dc:	6a 30       	cpi	r22, 0x0A	; 10
    36de:	10 f0       	brcs	.+4      	; 0x36e4 <_ZN8emstreamlsEh+0xc2>
    36e0:	69 5c       	subi	r22, 0xC9	; 201
    36e2:	01 c0       	rjmp	.+2      	; 0x36e6 <_ZN8emstreamlsEh+0xc4>
    36e4:	60 5d       	subi	r22, 0xD0	; 208
    36e6:	c8 01       	movw	r24, r16
    36e8:	19 95       	eicall
    36ea:	0e c0       	rjmp	.+28     	; 0x3708 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    36ec:	50 e0       	ldi	r21, 0x00	; 0
    36ee:	be 01       	movw	r22, r28
    36f0:	6f 5f       	subi	r22, 0xFF	; 255
    36f2:	7f 4f       	sbci	r23, 0xFF	; 255
    36f4:	8e 2d       	mov	r24, r14
    36f6:	90 e0       	ldi	r25, 0x00	; 0
    36f8:	0e 94 bf 1c 	call	0x397e	; 0x397e <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    36fc:	be 01       	movw	r22, r28
    36fe:	6f 5f       	subi	r22, 0xFF	; 255
    3700:	7f 4f       	sbci	r23, 0xFF	; 255
    3702:	c8 01       	movw	r24, r16
    3704:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3708:	c8 01       	movw	r24, r16
    370a:	29 96       	adiw	r28, 0x09	; 9
    370c:	cd bf       	out	0x3d, r28	; 61
    370e:	de bf       	out	0x3e, r29	; 62
    3710:	df 91       	pop	r29
    3712:	cf 91       	pop	r28
    3714:	1f 91       	pop	r17
    3716:	0f 91       	pop	r16
    3718:	ff 90       	pop	r15
    371a:	ef 90       	pop	r14
    371c:	df 90       	pop	r13
    371e:	cf 90       	pop	r12
    3720:	08 95       	ret

00003722 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3722:	0f 93       	push	r16
    3724:	1f 93       	push	r17
    3726:	cf 93       	push	r28
    3728:	df 93       	push	r29
    372a:	cd b7       	in	r28, 0x3d	; 61
    372c:	de b7       	in	r29, 0x3e	; 62
    372e:	6d 97       	sbiw	r28, 0x1d	; 29
    3730:	cd bf       	out	0x3d, r28	; 61
    3732:	de bf       	out	0x3e, r29	; 62
	cli();
    3734:	f8 94       	cli
	// Configure the system clock - see function for details on which clock is enabled
	config_SYSCLOCK();
    3736:	0e 94 45 09 	call	0x128a	; 0x128a <_Z15config_SYSCLOCKv>

	// Maps SYSCLOCK to output on PD7
	PORTD.OUTCLR = PIN7_bm;				// Make sure the pin is off before configuring it as output
    373a:	e0 e6       	ldi	r30, 0x60	; 96
    373c:	f6 e0       	ldi	r31, 0x06	; 6
    373e:	80 e8       	ldi	r24, 0x80	; 128
    3740:	86 83       	std	Z+6, r24	; 0x06
	PORTD.DIRSET = PIN7_bm;				// configure PD7 as output
    3742:	81 83       	std	Z+1, r24	; 0x01
	PORTCFG.CLKEVOUT = PORTCFG_CLKOUT_PD7_gc; //configure clock output on PD7 via event system.
    3744:	82 e0       	ldi	r24, 0x02	; 2
    3746:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    374a:	9d ef       	ldi	r25, 0xFD	; 253
    374c:	88 ed       	ldi	r24, 0xD8	; 216
    374e:	08 b6       	in	r0, 0x38	; 56
    3750:	18 be       	out	0x38, r1	; 56
    3752:	84 bf       	out	0x34, r24	; 52
    3754:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3758:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTD0); // Create a serial device on USART E0
    375a:	40 ea       	ldi	r20, 0xA0	; 160
    375c:	59 e0       	ldi	r21, 0x09	; 9
    375e:	60 e0       	ldi	r22, 0x00	; 0
    3760:	70 e0       	ldi	r23, 0x00	; 0
    3762:	ce 01       	movw	r24, r28
    3764:	01 96       	adiw	r24, 0x01	; 1
    3766:	0e 94 36 03 	call	0x66c	; 0x66c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    376a:	67 e0       	ldi	r22, 0x07	; 7
    376c:	ce 01       	movw	r24, r28
    376e:	01 96       	adiw	r24, 0x01	; 1
    3770:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    3774:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3776:	63 e5       	ldi	r22, 0x53	; 83
    3778:	70 e2       	ldi	r23, 0x20	; 32
    377a:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8emstream4putsEPKc>
    377e:	66 e0       	ldi	r22, 0x06	; 6
    3780:	c8 01       	movw	r24, r16
    3782:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
    3786:	66 e0       	ldi	r22, 0x06	; 6
    3788:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <_ZN8emstreamlsE15ser_manipulator>
	
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    378c:	82 e1       	ldi	r24, 0x12	; 18
    378e:	90 e0       	ldi	r25, 0x00	; 0
    3790:	0e 94 4f 19 	call	0x329e	; 0x329e <_Znwj>
    3794:	8e 01       	movw	r16, r28
    3796:	0f 5f       	subi	r16, 0xFF	; 255
    3798:	1f 4f       	sbci	r17, 0xFF	; 255
    379a:	24 e0       	ldi	r18, 0x04	; 4
    379c:	31 e0       	ldi	r19, 0x01	; 1
    379e:	40 e0       	ldi	r20, 0x00	; 0
    37a0:	62 e7       	ldi	r22, 0x72	; 114
    37a2:	70 e2       	ldi	r23, 0x20	; 32
    37a4:	0e 94 c0 06 	call	0xd80	; 0xd80 <_ZN9task_userC1EPKchjP8emstream>
	
	// The LED blinking task is also low priority and is used to test the timing accuracy
	// of the task transitions.
	new task_LED ("LED BLINKER", task_priority (1), 260, &ser_dev);
    37a8:	83 e1       	ldi	r24, 0x13	; 19
    37aa:	90 e0       	ldi	r25, 0x00	; 0
    37ac:	0e 94 4f 19 	call	0x329e	; 0x329e <_Znwj>
    37b0:	24 e0       	ldi	r18, 0x04	; 4
    37b2:	31 e0       	ldi	r19, 0x01	; 1
    37b4:	41 e0       	ldi	r20, 0x01	; 1
    37b6:	6a e7       	ldi	r22, 0x7A	; 122
    37b8:	70 e2       	ldi	r23, 0x20	; 32
    37ba:	0e 94 b0 06 	call	0xd60	; 0xd60 <_ZN8task_LEDC1EPKchjP8emstream>
	
	// Enable high - low level interrupts and enable global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    37be:	87 e0       	ldi	r24, 0x07	; 7
    37c0:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    37c4:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    37c6:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vTaskStartScheduler>
    37ca:	80 e0       	ldi	r24, 0x00	; 0
    37cc:	90 e0       	ldi	r25, 0x00	; 0
    37ce:	6d 96       	adiw	r28, 0x1d	; 29
    37d0:	cd bf       	out	0x3d, r28	; 61
    37d2:	de bf       	out	0x3e, r29	; 62
    37d4:	df 91       	pop	r29
    37d6:	cf 91       	pop	r28
    37d8:	1f 91       	pop	r17
    37da:	0f 91       	pop	r16
    37dc:	08 95       	ret

000037de <_GLOBAL__sub_I_print_ser_queue>:
    37de:	0f 93       	push	r16
    37e0:	1f 93       	push	r17
#include "task_LED.h"						// Header for user interface task




frt_text_queue print_ser_queue (32, NULL, 10);
    37e2:	0a e0       	ldi	r16, 0x0A	; 10
    37e4:	10 e0       	ldi	r17, 0x00	; 0
    37e6:	20 e0       	ldi	r18, 0x00	; 0
    37e8:	30 e0       	ldi	r19, 0x00	; 0
    37ea:	40 e0       	ldi	r20, 0x00	; 0
    37ec:	50 e0       	ldi	r21, 0x00	; 0
    37ee:	60 e2       	ldi	r22, 0x20	; 32
    37f0:	70 e0       	ldi	r23, 0x00	; 0
    37f2:	8c e1       	ldi	r24, 0x1C	; 28
    37f4:	91 e3       	ldi	r25, 0x31	; 49
    37f6:	0e 94 bb 17 	call	0x2f76	; 0x2f76 <_ZN14frt_text_queueC1EjP8emstreamm>
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    37fa:	1f 91       	pop	r17
    37fc:	0f 91       	pop	r16
    37fe:	08 95       	ret

00003800 <__mulsi3>:
    3800:	db 01       	movw	r26, r22
    3802:	8f 93       	push	r24
    3804:	9f 93       	push	r25
    3806:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <__muluhisi3>
    380a:	bf 91       	pop	r27
    380c:	af 91       	pop	r26
    380e:	a2 9f       	mul	r26, r18
    3810:	80 0d       	add	r24, r0
    3812:	91 1d       	adc	r25, r1
    3814:	a3 9f       	mul	r26, r19
    3816:	90 0d       	add	r25, r0
    3818:	b2 9f       	mul	r27, r18
    381a:	90 0d       	add	r25, r0
    381c:	11 24       	eor	r1, r1
    381e:	08 95       	ret

00003820 <__udivmodsi4>:
    3820:	a1 e2       	ldi	r26, 0x21	; 33
    3822:	1a 2e       	mov	r1, r26
    3824:	aa 1b       	sub	r26, r26
    3826:	bb 1b       	sub	r27, r27
    3828:	fd 01       	movw	r30, r26
    382a:	0d c0       	rjmp	.+26     	; 0x3846 <__udivmodsi4_ep>

0000382c <__udivmodsi4_loop>:
    382c:	aa 1f       	adc	r26, r26
    382e:	bb 1f       	adc	r27, r27
    3830:	ee 1f       	adc	r30, r30
    3832:	ff 1f       	adc	r31, r31
    3834:	a2 17       	cp	r26, r18
    3836:	b3 07       	cpc	r27, r19
    3838:	e4 07       	cpc	r30, r20
    383a:	f5 07       	cpc	r31, r21
    383c:	20 f0       	brcs	.+8      	; 0x3846 <__udivmodsi4_ep>
    383e:	a2 1b       	sub	r26, r18
    3840:	b3 0b       	sbc	r27, r19
    3842:	e4 0b       	sbc	r30, r20
    3844:	f5 0b       	sbc	r31, r21

00003846 <__udivmodsi4_ep>:
    3846:	66 1f       	adc	r22, r22
    3848:	77 1f       	adc	r23, r23
    384a:	88 1f       	adc	r24, r24
    384c:	99 1f       	adc	r25, r25
    384e:	1a 94       	dec	r1
    3850:	69 f7       	brne	.-38     	; 0x382c <__udivmodsi4_loop>
    3852:	60 95       	com	r22
    3854:	70 95       	com	r23
    3856:	80 95       	com	r24
    3858:	90 95       	com	r25
    385a:	9b 01       	movw	r18, r22
    385c:	ac 01       	movw	r20, r24
    385e:	bd 01       	movw	r22, r26
    3860:	cf 01       	movw	r24, r30
    3862:	08 95       	ret

00003864 <__divmodsi4>:
    3864:	05 2e       	mov	r0, r21
    3866:	97 fb       	bst	r25, 7
    3868:	1e f4       	brtc	.+6      	; 0x3870 <__divmodsi4+0xc>
    386a:	00 94       	com	r0
    386c:	0e 94 49 1c 	call	0x3892	; 0x3892 <__negsi2>
    3870:	57 fd       	sbrc	r21, 7
    3872:	07 d0       	rcall	.+14     	; 0x3882 <__divmodsi4_neg2>
    3874:	0e 94 10 1c 	call	0x3820	; 0x3820 <__udivmodsi4>
    3878:	07 fc       	sbrc	r0, 7
    387a:	03 d0       	rcall	.+6      	; 0x3882 <__divmodsi4_neg2>
    387c:	4e f4       	brtc	.+18     	; 0x3890 <__divmodsi4_exit>
    387e:	0c 94 49 1c 	jmp	0x3892	; 0x3892 <__negsi2>

00003882 <__divmodsi4_neg2>:
    3882:	50 95       	com	r21
    3884:	40 95       	com	r20
    3886:	30 95       	com	r19
    3888:	21 95       	neg	r18
    388a:	3f 4f       	sbci	r19, 0xFF	; 255
    388c:	4f 4f       	sbci	r20, 0xFF	; 255
    388e:	5f 4f       	sbci	r21, 0xFF	; 255

00003890 <__divmodsi4_exit>:
    3890:	08 95       	ret

00003892 <__negsi2>:
    3892:	90 95       	com	r25
    3894:	80 95       	com	r24
    3896:	70 95       	com	r23
    3898:	61 95       	neg	r22
    389a:	7f 4f       	sbci	r23, 0xFF	; 255
    389c:	8f 4f       	sbci	r24, 0xFF	; 255
    389e:	9f 4f       	sbci	r25, 0xFF	; 255
    38a0:	08 95       	ret

000038a2 <__tablejump2__>:
    38a2:	ee 0f       	add	r30, r30
    38a4:	ff 1f       	adc	r31, r31
    38a6:	88 1f       	adc	r24, r24
    38a8:	8b bf       	out	0x3b, r24	; 59
    38aa:	07 90       	elpm	r0, Z+
    38ac:	f6 91       	elpm	r31, Z
    38ae:	e0 2d       	mov	r30, r0
    38b0:	19 94       	eijmp

000038b2 <__muluhisi3>:
    38b2:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <__umulhisi3>
    38b6:	a5 9f       	mul	r26, r21
    38b8:	90 0d       	add	r25, r0
    38ba:	b4 9f       	mul	r27, r20
    38bc:	90 0d       	add	r25, r0
    38be:	a4 9f       	mul	r26, r20
    38c0:	80 0d       	add	r24, r0
    38c2:	91 1d       	adc	r25, r1
    38c4:	11 24       	eor	r1, r1
    38c6:	08 95       	ret

000038c8 <__umulhisi3>:
    38c8:	a2 9f       	mul	r26, r18
    38ca:	b0 01       	movw	r22, r0
    38cc:	b3 9f       	mul	r27, r19
    38ce:	c0 01       	movw	r24, r0
    38d0:	a3 9f       	mul	r26, r19
    38d2:	70 0d       	add	r23, r0
    38d4:	81 1d       	adc	r24, r1
    38d6:	11 24       	eor	r1, r1
    38d8:	91 1d       	adc	r25, r1
    38da:	b2 9f       	mul	r27, r18
    38dc:	70 0d       	add	r23, r0
    38de:	81 1d       	adc	r24, r1
    38e0:	11 24       	eor	r1, r1
    38e2:	91 1d       	adc	r25, r1
    38e4:	08 95       	ret

000038e6 <memcpy>:
    38e6:	fb 01       	movw	r30, r22
    38e8:	dc 01       	movw	r26, r24
    38ea:	02 c0       	rjmp	.+4      	; 0x38f0 <memcpy+0xa>
    38ec:	01 90       	ld	r0, Z+
    38ee:	0d 92       	st	X+, r0
    38f0:	41 50       	subi	r20, 0x01	; 1
    38f2:	50 40       	sbci	r21, 0x00	; 0
    38f4:	d8 f7       	brcc	.-10     	; 0x38ec <memcpy+0x6>
    38f6:	08 95       	ret

000038f8 <memset>:
    38f8:	dc 01       	movw	r26, r24
    38fa:	01 c0       	rjmp	.+2      	; 0x38fe <memset+0x6>
    38fc:	6d 93       	st	X+, r22
    38fe:	41 50       	subi	r20, 0x01	; 1
    3900:	50 40       	sbci	r21, 0x00	; 0
    3902:	e0 f7       	brcc	.-8      	; 0x38fc <memset+0x4>
    3904:	08 95       	ret

00003906 <strncpy>:
    3906:	fb 01       	movw	r30, r22
    3908:	dc 01       	movw	r26, r24
    390a:	41 50       	subi	r20, 0x01	; 1
    390c:	50 40       	sbci	r21, 0x00	; 0
    390e:	48 f0       	brcs	.+18     	; 0x3922 <strncpy+0x1c>
    3910:	01 90       	ld	r0, Z+
    3912:	0d 92       	st	X+, r0
    3914:	00 20       	and	r0, r0
    3916:	c9 f7       	brne	.-14     	; 0x390a <strncpy+0x4>
    3918:	01 c0       	rjmp	.+2      	; 0x391c <strncpy+0x16>
    391a:	1d 92       	st	X+, r1
    391c:	41 50       	subi	r20, 0x01	; 1
    391e:	50 40       	sbci	r21, 0x00	; 0
    3920:	e0 f7       	brcc	.-8      	; 0x391a <strncpy+0x14>
    3922:	08 95       	ret

00003924 <ultoa>:
    3924:	25 32       	cpi	r18, 0x25	; 37
    3926:	31 05       	cpc	r19, r1
    3928:	20 f4       	brcc	.+8      	; 0x3932 <ultoa+0xe>
    392a:	22 30       	cpi	r18, 0x02	; 2
    392c:	10 f0       	brcs	.+4      	; 0x3932 <ultoa+0xe>
    392e:	0c 94 9d 1c 	jmp	0x393a	; 0x393a <__ultoa_ncheck>
    3932:	fa 01       	movw	r30, r20
    3934:	10 82       	st	Z, r1
    3936:	ca 01       	movw	r24, r20
    3938:	08 95       	ret

0000393a <__ultoa_ncheck>:
    393a:	bb 27       	eor	r27, r27

0000393c <__ultoa_common>:
    393c:	fa 01       	movw	r30, r20
    393e:	a6 2f       	mov	r26, r22
    3940:	62 17       	cp	r22, r18
    3942:	71 05       	cpc	r23, r1
    3944:	81 05       	cpc	r24, r1
    3946:	91 05       	cpc	r25, r1
    3948:	33 0b       	sbc	r19, r19
    394a:	30 fb       	bst	r19, 0
    394c:	66 f0       	brts	.+24     	; 0x3966 <__ultoa_common+0x2a>
    394e:	aa 27       	eor	r26, r26
    3950:	66 0f       	add	r22, r22
    3952:	77 1f       	adc	r23, r23
    3954:	88 1f       	adc	r24, r24
    3956:	99 1f       	adc	r25, r25
    3958:	aa 1f       	adc	r26, r26
    395a:	a2 17       	cp	r26, r18
    395c:	10 f0       	brcs	.+4      	; 0x3962 <__ultoa_common+0x26>
    395e:	a2 1b       	sub	r26, r18
    3960:	63 95       	inc	r22
    3962:	38 50       	subi	r19, 0x08	; 8
    3964:	a9 f7       	brne	.-22     	; 0x3950 <__ultoa_common+0x14>
    3966:	a0 5d       	subi	r26, 0xD0	; 208
    3968:	aa 33       	cpi	r26, 0x3A	; 58
    396a:	08 f0       	brcs	.+2      	; 0x396e <__ultoa_common+0x32>
    396c:	a9 5d       	subi	r26, 0xD9	; 217
    396e:	a1 93       	st	Z+, r26
    3970:	36 f7       	brtc	.-52     	; 0x393e <__ultoa_common+0x2>
    3972:	b1 11       	cpse	r27, r1
    3974:	b1 93       	st	Z+, r27
    3976:	10 82       	st	Z, r1
    3978:	ca 01       	movw	r24, r20
    397a:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <strrev>

0000397e <utoa>:
    397e:	45 32       	cpi	r20, 0x25	; 37
    3980:	51 05       	cpc	r21, r1
    3982:	20 f4       	brcc	.+8      	; 0x398c <utoa+0xe>
    3984:	42 30       	cpi	r20, 0x02	; 2
    3986:	10 f0       	brcs	.+4      	; 0x398c <utoa+0xe>
    3988:	0c 94 ca 1c 	jmp	0x3994	; 0x3994 <__utoa_ncheck>
    398c:	fb 01       	movw	r30, r22
    398e:	10 82       	st	Z, r1
    3990:	cb 01       	movw	r24, r22
    3992:	08 95       	ret

00003994 <__utoa_ncheck>:
    3994:	bb 27       	eor	r27, r27

00003996 <__utoa_common>:
    3996:	fb 01       	movw	r30, r22
    3998:	55 27       	eor	r21, r21
    399a:	aa 27       	eor	r26, r26
    399c:	88 0f       	add	r24, r24
    399e:	99 1f       	adc	r25, r25
    39a0:	aa 1f       	adc	r26, r26
    39a2:	a4 17       	cp	r26, r20
    39a4:	10 f0       	brcs	.+4      	; 0x39aa <__utoa_common+0x14>
    39a6:	a4 1b       	sub	r26, r20
    39a8:	83 95       	inc	r24
    39aa:	50 51       	subi	r21, 0x10	; 16
    39ac:	b9 f7       	brne	.-18     	; 0x399c <__utoa_common+0x6>
    39ae:	a0 5d       	subi	r26, 0xD0	; 208
    39b0:	aa 33       	cpi	r26, 0x3A	; 58
    39b2:	08 f0       	brcs	.+2      	; 0x39b6 <__utoa_common+0x20>
    39b4:	a9 5d       	subi	r26, 0xD9	; 217
    39b6:	a1 93       	st	Z+, r26
    39b8:	00 97       	sbiw	r24, 0x00	; 0
    39ba:	79 f7       	brne	.-34     	; 0x399a <__utoa_common+0x4>
    39bc:	b1 11       	cpse	r27, r1
    39be:	b1 93       	st	Z+, r27
    39c0:	11 92       	st	Z+, r1
    39c2:	cb 01       	movw	r24, r22
    39c4:	0c 94 e4 1c 	jmp	0x39c8	; 0x39c8 <strrev>

000039c8 <strrev>:
    39c8:	dc 01       	movw	r26, r24
    39ca:	fc 01       	movw	r30, r24
    39cc:	67 2f       	mov	r22, r23
    39ce:	71 91       	ld	r23, Z+
    39d0:	77 23       	and	r23, r23
    39d2:	e1 f7       	brne	.-8      	; 0x39cc <strrev+0x4>
    39d4:	32 97       	sbiw	r30, 0x02	; 2
    39d6:	04 c0       	rjmp	.+8      	; 0x39e0 <strrev+0x18>
    39d8:	7c 91       	ld	r23, X
    39da:	6d 93       	st	X+, r22
    39dc:	70 83       	st	Z, r23
    39de:	62 91       	ld	r22, -Z
    39e0:	ae 17       	cp	r26, r30
    39e2:	bf 07       	cpc	r27, r31
    39e4:	c8 f3       	brcs	.-14     	; 0x39d8 <strrev+0x10>
    39e6:	08 95       	ret

000039e8 <_exit>:
    39e8:	f8 94       	cli

000039ea <__stop_program>:
    39ea:	ff cf       	rjmp	.-2      	; 0x39ea <__stop_program>
